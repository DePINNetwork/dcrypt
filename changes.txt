diff --git a/.gitignore b/.gitignore
index 726d785..149e3ed 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,4 +1,6 @@
 codebase_snapshot.md
 target
 tools/
-tree.md
\ No newline at end of file
+tree.md
+Cargo.lock
+.gitignore
\ No newline at end of file
diff --git a/crates/algorithms/src/poly/params.rs b/crates/algorithms/src/poly/params.rs
index 8eafc75..7f60d59 100644
--- a/crates/algorithms/src/poly/params.rs
+++ b/crates/algorithms/src/poly/params.rs
@@ -53,7 +53,7 @@ impl NttModulus for Kyber256Params {
     const Q_INV_NEG: u32 = 0x94570CFF;
 }
 
-/// Example: Dilithium parameter sets
+/// Example: Dilithium parameter sets (basic, without NTT)
 pub struct Dilithium2Params;
 
 impl Modulus for Dilithium2Params {
@@ -61,7 +61,74 @@ impl Modulus for Dilithium2Params {
     const N: usize = 256;
 }
 
-// Note: Dilithium NTT parameters would be added similarly
+/// Dilithium polynomial ring Rq = ℤq[X]/(Xᴺ + 1)
+///
+/// * Q = 2²³ – 2¹³ + 1 = 8,380,417 (prime)  
+/// * N = 256 (⇒ ϕ = 512)  
+/// * ζ = 1753 is a primitive 512-th root of unity mod Q  
+///
+/// All Montgomery-domain constants are derived for 32-bit words:
+///   R       = 2³² mod Q                 = 4,193,792  
+///   N_INV   = N⁻¹ · R mod Q            = 16,382  
+///   Q_INV_NEG = –Q⁻¹ mod 2³²           = 0xFC7F_DFFF
+pub struct DilithiumPolyModParams;
+
+impl Modulus for DilithiumPolyModParams {
+    const Q: u32 = 8_380_417;
+    const N: usize = 256;
+}
+
+impl NttModulus for DilithiumPolyModParams {
+    // ───── primitive root of unity (order 2·N) ─────
+    const ZETA: u32 = 1_753;
+
+    // We generate twiddles on-the-fly, so keep these empty
+    const ZETAS: &'static [u32] = &[];
+    const INV_ZETAS: &'static [u32] = &[];
+
+    // ───── Montgomery/NTT helpers ─────
+    /// (N⁻¹ · R) mod Q where R = 2³² mod Q
+    const N_INV: u32 = 16_382;
+    /// R = 2³² mod Q
+    const MONT_R: u32 = 4_193_792;
+    /// –Q⁻¹ mod 2³² (for Montgomery reduction)
+    const Q_INV_NEG: u32 = 0xFC7F_DFFF;
+}
+
+/// Compile-time verification of Dilithium NTT parameters
+#[allow(dead_code)]
+const _: () = {
+    // Helper for modular exponentiation (const context)
+    const fn const_pow_mod(mut base: u32, mut exp: u32, modulus: u32) -> u32 {
+        let mut result = 1u64;
+        let m = modulus as u64;
+        while exp > 0 {
+            if exp & 1 == 1 {
+                result = (result * (base as u64)) % m;
+            }
+            base = ((base as u64 * base as u64) % m) as u32;
+            exp >>= 1;
+        }
+        result as u32
+    }
+    
+    // Verify ζ^512 ≡ 1 (mod Q)
+    const ZETA_512: u32 = const_pow_mod(DilithiumPolyModParams::ZETA, 512, DilithiumPolyModParams::Q);
+    const _: () = assert!(ZETA_512 == 1);
+    
+    // Verify ζ^256 ≡ -1 (mod Q)
+    const ZETA_256: u32 = const_pow_mod(DilithiumPolyModParams::ZETA, 256, DilithiumPolyModParams::Q);
+    const _: () = assert!(ZETA_256 == DilithiumPolyModParams::Q - 1);
+    
+    // Verify R = 2^32 mod Q
+    const R_CHECK: u64 = (1u64 << 32) % (DilithiumPolyModParams::Q as u64);
+    const _: () = assert!(R_CHECK == DilithiumPolyModParams::MONT_R as u64);
+    
+    // Verify Q * Q_INV_NEG ≡ -1 (mod 2^32)
+    const PROD: u64 = (DilithiumPolyModParams::Q as u64)
+        .wrapping_mul(DilithiumPolyModParams::Q_INV_NEG as u64);
+    const _: () = assert!((PROD & 0xFFFFFFFF) == 0xFFFFFFFF);
+};
 
 /// Helper functions for parameter validation
 
@@ -109,4 +176,18 @@ mod tests {
         assert_eq!(Dilithium2Params::N, 256);
         assert!(is_prime(Dilithium2Params::Q));
     }
+    
+    #[test]
+    fn test_dilithium_poly_mod_params() {
+        assert_eq!(DilithiumPolyModParams::Q, 8_380_417);
+        assert_eq!(DilithiumPolyModParams::N, 256);
+        assert!(is_prime(DilithiumPolyModParams::Q));
+        assert!(is_power_of_two(DilithiumPolyModParams::N));
+        
+        // Verify NTT parameters
+        assert_eq!(DilithiumPolyModParams::ZETA, 1_753);
+        assert_eq!(DilithiumPolyModParams::MONT_R, 4_193_792);
+        assert_eq!(DilithiumPolyModParams::N_INV, 16_382);
+        assert_eq!(DilithiumPolyModParams::Q_INV_NEG, 0xFC7F_DFFF);
+    }
 }
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/mod.rs b/crates/sign/src/pq/dilithium/mod.rs
index a998031..2cd1867 100644
--- a/crates/sign/src/pq/dilithium/mod.rs
+++ b/crates/sign/src/pq/dilithium/mod.rs
@@ -1,169 +1,153 @@
-//! Dilithium signature scheme
+// File: crates/sign/src/pq/dilithium/mod.rs
+//! Dilithium Digital Signature Algorithm (as per FIPS 203)
 //!
-//! This module implements the Dilithium signature scheme, a lattice-based
-//! digital signature scheme selected for standardization by NIST.
-
-use api::{Signature as SignatureTrait, Result};
-use zeroize::Zeroize;
+//! This module provides high-level implementations for Dilithium2, Dilithium3, and Dilithium5,
+//! which are lattice-based digital signature schemes standardized by NIST.
+//!
+//! The core cryptographic logic relies on polynomial arithmetic over rings, specific sampling
+//! distributions (Centered Binomial Distribution, uniform bounded for `y`, sparse ternary for `c`),
+//! and cryptographic hash functions (SHA3, SHAKE) provided by the `dcrypt-algorithms` crate.
+//! The security of Dilithium is based on the hardness of the Module Learning With Errors (MLWE)
+//! and Module Short Integer Solution (MSIS) problems over polynomial rings.
+//!
+//! The signing process employs the Fiat-Shamir with Aborts paradigm to achieve security
+//! against chosen message attacks.
+//!
+//! This module defines the public API for Dilithium, conforming to the `dcrypt-api::Signature` trait.
+//! Detailed implementations of internal operations are found in submodules:
+//! - `polyvec.rs`: Defines `PolyVecL`, `PolyVecK` and Dilithium-specific polynomial vector operations.
+//! - `arithmetic.rs`: Implements crucial arithmetic functions like `Power2Round`, `Decompose`,
+//!   `MakeHint`, `UseHint`, and coefficient norm checking.
+//! - `sampling.rs`: Implements Dilithium-specific sampling procedures for secret polynomials,
+//!   the masking vector `y`, and the challenge polynomial `c`.
+//! - `encoding.rs`: Handles the precise serialization and deserialization formats for public keys,
+//!   secret keys, and signatures as specified by FIPS 203.
+//! - `sign.rs`: Contains the core `keypair_internal`, `sign_internal`, and `verify_internal` logic.
+
+use api::{Signature as SignatureTrait, Result as ApiResult};
+use zeroize::{Zeroize, ZeroizeOnDrop};
 use rand::{CryptoRng, RngCore};
-
-/// Dilithium2 signature scheme (NIST security level 2)
-pub struct Dilithium2;
-
-/// Dilithium3 signature scheme (NIST security level 3)
-pub struct Dilithium3;
-
-/// Dilithium5 signature scheme (NIST security level 5)
-pub struct Dilithium5;
-
-// Define the necessary structs for Dilithium
-#[derive(Clone, Zeroize)]
-pub struct DilithiumPublicKey(pub Vec<u8>);
-
-#[derive(Clone, Zeroize)]
-pub struct DilithiumSecretKey(pub Vec<u8>);
-
-#[derive(Clone)]
-pub struct DilithiumSignature(pub Vec<u8>);
-
-// Implement necessary traits for the key/signature types
-impl AsRef<[u8]> for DilithiumPublicKey {
-    fn as_ref(&self) -> &[u8] { &self.0 }
-}
-
-impl AsMut<[u8]> for DilithiumPublicKey {
-    fn as_mut(&mut self) -> &mut [u8] { &mut self.0 }
-}
-
-impl AsRef<[u8]> for DilithiumSecretKey {
-    fn as_ref(&self) -> &[u8] { &self.0 }
-}
-
-impl AsMut<[u8]> for DilithiumSecretKey {
-    fn as_mut(&mut self) -> &mut [u8] { &mut self.0 }
-}
-
-impl AsRef<[u8]> for DilithiumSignature {
-    fn as_ref(&self) -> &[u8] { &self.0 }
-}
-
-impl AsMut<[u8]> for DilithiumSignature {
-    fn as_mut(&mut self) -> &mut [u8] { &mut self.0 }
+use core::marker::PhantomData;
+
+// Internal modules for Dilithium logic
+mod polyvec;       pub(crate) use polyvec::*;
+mod arithmetic;    pub(crate) use arithmetic::*;
+mod sampling;      pub(crate) use sampling::*;
+mod encoding;      pub(crate) use encoding::*;
+mod sign;          pub(crate) use sign::*;
+
+// Re-export from params crate for easy access to DilithiumNParams structs.
+// These structs from `dcrypt-params` hold the specific numerical parameters (K, L, eta, gamma1, etc.)
+// that define each Dilithium security level.
+use params::pqc::dilithium::{Dilithium2Params, Dilithium3Params, Dilithium5Params, DilithiumParams};
+
+// --- Public Key, Secret Key, Signature Data Wrapper Structs ---
+// These structs wrap byte vectors (`Vec<u8>`) that store the serialized representations
+// of the cryptographic objects. They provide a type-safe interface at the API boundary.
+
+/// Dilithium Public Key.
+///
+/// Stores the packed representation of `(rho, t1)`.
+/// - `rho`: A 32-byte seed used to deterministically generate the matrix A.
+/// - `t1`: A vector of K polynomials, where each coefficient is the high-order bits
+///         of `t_i = (A*s1)_i + (s2)_i`. Packed according to `P::D_PARAM` bits.
+#[derive(Clone, Debug, Zeroize)]
+pub struct DilithiumPublicKey(pub(crate) Vec<u8>);
+
+/// Dilithium Secret Key.
+///
+/// Stores the packed representation of `(rho, K, tr, s1, s2, t0)`.
+/// - `rho`: Seed for matrix A (same as in public key).
+/// - `K`: A 32-byte seed used for sampling the masking vector `y` and as part of the
+///        PRF input for generating the challenge `c`.
+/// - `tr`: A 32-byte hash of the packed public key, used for domain separation in challenge generation.
+/// - `s1`, `s2`: Secret polynomial vectors with small coefficients (norm bounded by `eta`).
+///               Packed according to `P::ETA_S1S2` bits.
+/// - `t0`: A vector of K polynomials representing the low-order bits of `t = A*s1 + s2`.
+///         Coefficients are in `(-2^(d-1), 2^(d-1)]` and packed accordingly.
+#[derive(Clone, Debug, Zeroize, ZeroizeOnDrop)]
+pub struct DilithiumSecretKey(pub(crate) Vec<u8>);
+
+/// Dilithium Signature Data.
+///
+/// Stores the packed representation of `(c_tilde, z, h)`.
+/// - `c_tilde`: A short (32-byte) seed from which the challenge polynomial `c` (with `tau` non-zero
+///              coefficients) is derived.
+/// - `z`: A vector of L polynomials, `z = y + c*s1`. Its coefficients must be within
+///        `[-gamma1 + beta, gamma1 - beta]`. Packed based on this range.
+/// - `h`: A hint vector (PolyVecK of 0s/1s) indicating which coefficients of `w1_prime - c*t0`
+///        required correction during verification using `UseHint`. Packed efficiently.
+#[derive(Clone, Debug)]
+pub struct DilithiumSignatureData(pub(crate) Vec<u8>);
+
+// AsRef/AsMut implementations allow access to the raw byte data.
+impl AsRef<[u8]> for DilithiumPublicKey { fn as_ref(&self) -> &[u8] { &self.0 } }
+impl AsMut<[u8]> for DilithiumPublicKey { fn as_mut(&mut self) -> &mut [u8] { &mut self.0 } }
+impl AsRef<[u8]> for DilithiumSecretKey { fn as_ref(&self) -> &[u8] { &self.0 } }
+impl AsMut<[u8]> for DilithiumSecretKey { fn as_mut(&mut self) -> &mut [u8] { &mut self.0 } }
+impl AsRef<[u8]> for DilithiumSignatureData { fn as_ref(&self) -> &[u8] { &self.0 } }
+impl AsMut<[u8]> for DilithiumSignatureData { fn as_mut(&mut self) -> &mut [u8] { &mut self.0 } }
+
+
+/// Generic Dilithium signature structure parameterized by `P: DilithiumParams`.
+/// This allows a single core implementation (`sign.rs`) to be instantiated for
+/// different Dilithium security levels (Dilithium2, Dilithium3, Dilithium5)
+/// by simply changing the type parameter `P`.
+pub struct Dilithium<P: DilithiumParams + 'static> {
+    _params: PhantomData<P>,
 }
 
-// Implement the Signature trait for Dilithium2
-impl SignatureTrait for Dilithium2 {
+// --- Implement api::Signature for Dilithium<P> ---
+impl<P: DilithiumParams + Send + Sync + 'static> SignatureTrait for Dilithium<P> {
     type PublicKey = DilithiumPublicKey;
     type SecretKey = DilithiumSecretKey;
-    type SignatureData = DilithiumSignature;  // Changed from 'Signature' to 'SignatureData'
-    type KeyPair = (Self::PublicKey, Self::SecretKey);  // Added this type definition
-
-    fn name() -> &'static str { "Dilithium2" }
-
-    fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self::KeyPair> {
-        // Placeholder implementation
-        let mut public_key = vec![0u8; 1312];
-        let mut secret_key = vec![0u8; 2528];
-        rng.fill_bytes(&mut public_key);
-        rng.fill_bytes(&mut secret_key);
-        Ok((DilithiumPublicKey(public_key), DilithiumSecretKey(secret_key)))
-    }
-    
-    // Add the missing public_key function
-    fn public_key(keypair: &Self::KeyPair) -> Self::PublicKey {
-        keypair.0.clone()
-    }
-
-    // Add the missing secret_key function
-    fn secret_key(keypair: &Self::KeyPair) -> Self::SecretKey {
-        keypair.1.clone()
-    }
+    type SignatureData = DilithiumSignatureData;
+    type KeyPair = (Self::PublicKey, Self::SecretKey);
 
-    fn sign(_message: &[u8], _secret_key: &Self::SecretKey) -> Result<Self::SignatureData> {
-        // Placeholder implementation
-        Ok(DilithiumSignature(vec![0u8; 2420]))
-    }
+    fn name() -> &'static str { P::NAME }
 
-    fn verify(_message: &[u8], _signature: &Self::SignatureData, _public_key: &Self::PublicKey) -> Result<()> {
-        // Placeholder implementation
-        Ok(())
-    }
-}
-
-// Implement the Signature trait for Dilithium3
-impl SignatureTrait for Dilithium3 {
-    type PublicKey = DilithiumPublicKey;
-    type SecretKey = DilithiumSecretKey;
-    type SignatureData = DilithiumSignature;  // Changed from 'Signature' to 'SignatureData'
-    type KeyPair = (Self::PublicKey, Self::SecretKey);  // Added this type definition
-
-    fn name() -> &'static str { "Dilithium3" }
-
-    fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self::KeyPair> {
-        // Placeholder implementation
-        let mut public_key = vec![0u8; 1952];
-        let mut secret_key = vec![0u8; 4000];
-        rng.fill_bytes(&mut public_key);
-        rng.fill_bytes(&mut secret_key);
-        Ok((DilithiumPublicKey(public_key), DilithiumSecretKey(secret_key)))
-    }
-    
-    // Add the missing public_key function
-    fn public_key(keypair: &Self::KeyPair) -> Self::PublicKey {
-        keypair.0.clone()
+    fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
+        let (pk_bytes, sk_bytes) = sign::keypair_internal::<P, R>(rng)?;
+        Ok((DilithiumPublicKey(pk_bytes), DilithiumSecretKey(sk_bytes)))
     }
 
-    // Add the missing secret_key function
-    fn secret_key(keypair: &Self::KeyPair) -> Self::SecretKey {
-        keypair.1.clone()
+    fn public_key(keypair: &Self::KeyPair) -> Self::PublicKey { keypair.0.clone() }
+    fn secret_key(keypair: &Self::KeyPair) -> Self::SecretKey { keypair.1.clone() }
+
+    fn sign(message: &[u8], secret_key: &Self::SecretKey) -> ApiResult<Self::SignatureData> {
+        // Dilithium signing, as per FIPS 203, is deterministic given the secret key and message.
+        // The internal randomness for the masking vector `y` and the challenge `c` (via its seed)
+        // are derived from parts of the secret key (`K`) and a counter (`kappa`).
+        // An external RNG is not directly consumed by the core signing loop after `K` is fixed.
+        // However, some library designs might use an RNG for the initial seed `K` itself if it's
+        // not part of a deterministic derivation from a master seed.
+        // For this API, we'll use a thread_rng for any potential non-spec randomization points
+        // or if a future variant required it, but standard Dilithium does not.
+        let mut rng = rand::rngs::OsRng;
+        let sig_bytes = sign::sign_internal::<P, _>(message, &secret_key.0, &mut rng)?;
+        Ok(DilithiumSignatureData(sig_bytes))
     }
 
-    fn sign(_message: &[u8], _secret_key: &Self::SecretKey) -> Result<Self::SignatureData> {
-        // Placeholder implementation
-        Ok(DilithiumSignature(vec![0u8; 3293]))
-    }
-
-    fn verify(_message: &[u8], _signature: &Self::SignatureData, _public_key: &Self::PublicKey) -> Result<()> {
-        // Placeholder implementation
-        Ok(())
+    fn verify(message: &[u8], signature: &Self::SignatureData, public_key: &Self::PublicKey) -> ApiResult<()> {
+        sign::verify_internal::<P>(message, &signature.0, &public_key.0)
     }
 }
 
-// Implement the Signature trait for Dilithium5
-impl SignatureTrait for Dilithium5 {
-    type PublicKey = DilithiumPublicKey;
-    type SecretKey = DilithiumSecretKey;
-    type SignatureData = DilithiumSignature;  // Changed from 'Signature' to 'SignatureData'
-    type KeyPair = (Self::PublicKey, Self::SecretKey);  // Added this type definition
-
-    fn name() -> &'static str { "Dilithium5" }
-
-    fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> Result<Self::KeyPair> {
-        // Placeholder implementation
-        let mut public_key = vec![0u8; 2592];
-        let mut secret_key = vec![0u8; 4864];
-        rng.fill_bytes(&mut public_key);
-        rng.fill_bytes(&mut secret_key);
-        Ok((DilithiumPublicKey(public_key), DilithiumSecretKey(secret_key)))
-    }
-    
-    // Add the missing public_key function
-    fn public_key(keypair: &Self::KeyPair) -> Self::PublicKey {
-        keypair.0.clone()
-    }
+// Concrete types for different Dilithium levels, re-exporting the generic Dilithium struct
+// instantiated with specific parameters from the `params` crate.
+pub type Dilithium2 = Dilithium<Dilithium2Params>;
+pub type Dilithium3 = Dilithium<Dilithium3Params>;
+pub type Dilithium5 = Dilithium<Dilithium5Params>;
 
-    // Add the missing secret_key function
-    fn secret_key(keypair: &Self::KeyPair) -> Self::SecretKey {
-        keypair.1.clone()
-    }
+// Temporary compatibility re-exports (deprecated)
+#[deprecated(note = "use dilithium::arithmetic")]
+pub use arithmetic as arith_helpers;
 
-    fn sign(_message: &[u8], _secret_key: &Self::SecretKey) -> Result<Self::SignatureData> {
-        // Placeholder implementation
-        Ok(DilithiumSignature(vec![0u8; 4595]))
-    }
+#[deprecated(note = "use dilithium::polyvec")]
+pub use polyvec as poly_ops;
 
-    fn verify(_message: &[u8], _signature: &Self::SignatureData, _public_key: &Self::PublicKey) -> Result<()> {
-        // Placeholder implementation
-        Ok(())
-    }
-}
\ No newline at end of file
+#[deprecated(note = "use dilithium::encoding")]
+pub use encoding as packing;
+
+#[deprecated(note = "use dilithium::sign")]
+pub use sign as sign_impl;
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/sign.rs b/crates/sign/src/pq/dilithium/sign.rs
index fe7154d..ab06160 100644
--- a/crates/sign/src/pq/dilithium/sign.rs
+++ b/crates/sign/src/pq/dilithium/sign.rs
@@ -1,111 +1,293 @@
-//! Core Dilithium signing and verification logic.
+// File: crates/sign/src/pq/dilithium/sign.rs
+//! Core implementation logic for Dilithium key generation, signing, and verification.
+//! This file orchestrates the use of polynomial operations, arithmetic helpers,
+//! sampling, and encoding routines to implement the Dilithium signature scheme.
 
-#![cfg_attr(not(feature = "std"), no_std)]
+use super::polyvec::{PolyVecL, PolyVecK, expand_matrix_a};
+// Assuming DilithiumPolyModParams is correctly defined in algorithms::poly::params
+use algorithms::poly::params::DilithiumPolyModParams;
+use super::arithmetic::{power2round_polyvec, highbits_polyvec, lowbits_polyvec, check_norm_polyvec, make_hint_polyveck, use_hint_polyveck_from_sig};
+use super::sampling::{sample_polyvecl_cbd_eta, sample_polyveck_cbd_eta, sample_polyvecl_uniform_gamma1, sample_challenge_c};
+use super::encoding::{pack_public_key, unpack_public_key, pack_secret_key, unpack_secret_key, pack_signature, unpack_signature, pack_polyveck_w1};
 
-#[cfg(feature = "alloc")]
-extern crate alloc;
-#[cfg(feature = "alloc")]
-use alloc::vec::Vec;
+use algorithms::hash::sha3::{Sha3_256, Sha3_512};
+use algorithms::hash::HashFunction;
+use algorithms::error::Result as AlgoResult;
+use crate::error::{Error as SignError, Result as SignResult};
+use params::pqc::dilithium::{DilithiumParams, DILITHIUM_N, DILITHIUM_Q};
+use rand::{CryptoRng, RngCore};
+use zeroize::Zeroize;
+use subtle::ConstantTimeEq;
 
-use api::Signature as SignatureTrait;
-use api::error::Result as ApiResult;
-use algorithms::poly::{
-    polynomial::Polynomial,
-    // ntt, // Dilithium uses NTT
-    // sampling::{cbd, uniform}, // For keygen and signing
-};
-use algorithms::poly::params::Modulus;
 
-use super::params::{DilithiumParams, DilithiumPolyModParams};
-use super::polyvec::PolyVecL; // Assuming specific PolyVec types for k, l dimensions
-// ... other internal Dilithium modules like hint, decompose, encode
+/// Internal Key Generation for Dilithium (Algorithm 9 from FIPS 203).
+pub(crate) fn keypair_internal<P, R>(rng: &mut R) -> SignResult<(Vec<u8>, Vec<u8>)>
+where
+    P: DilithiumParams,
+    R: RngCore + CryptoRng,
+{
+    let mut zeta_seed = [0u8; P::SEED_ZETA_BYTES]; // Seed for K, s1, s2, (e in PKE)
+    let mut rho_seed = [0u8; P::SEED_RHO_BYTES];
+    rng.fill_bytes(&mut zeta_seed);
+    rng.fill_bytes(&mut rho_seed);
 
-use crate::error::{Result as SignResult, Error as SignError};
-use zeroize::Zeroize;
-use rand::{CryptoRng, RngCore};
+    // Split zeta into seed for s1/s2 (sigma_seed) and seed for y (K_seed)
+    // FIPS 203: G(zeta) -> (rho, sigma_seed, K_seed)
+    // For simplicity here, we use zeta directly for sigma_seed and K_seed.
+    // A real implementation would use SHAKE256(zeta) to derive these.
+    let sigma_seed = zeta_seed; // Placeholder
+    let k_seed_for_signing = zeta_seed; // Placeholder
+
+    // 1. Expand A from rho (standard domain)
+    let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
+    // Convert matrix_a to NTT form (A_hat)
+    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
+    for i in 0..P::K_DIM {
+        for j in 0..P::L_DIM {
+            let mut poly = matrix_a[i].polys[j].clone();
+            poly.ntt_inplace().map_err(SignError::from_algo)?;
+            matrix_a_hat[i].polys[j] = poly;
+        }
+    }
+
+    // 2. Sample s1, s2 from CBD_eta using sigma_seed
+    let s1_vec = sample_polyvecl_cbd_eta::<P>(&sigma_seed, 0, P::ETA_S1S2 as u32)?;
+    let s2_vec = sample_polyveck_cbd_eta::<P>(&sigma_seed, P::L_DIM as u8, P::ETA_S1S2 as u32)?;
+    
+    let mut s1_hat_vec = s1_vec.clone(); s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    let mut s2_hat_vec = s2_vec.clone(); s2_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+
+    // 3. t_hat_vec = A_hat * s1_hat_vec + s2_hat_vec
+    let mut t_hat_vec = PolyVecK::<P>::zero();
+    for i in 0..P::K_DIM {
+        let row_a_hat = &matrix_a_hat[i];
+        let dot_product_poly = row_a_hat.pointwise_dot_product(&s1_hat_vec);
+        t_hat_vec.polys[i] = dot_product_poly.add(&s2_hat_vec.polys[i]);
+    }
+    
+    let mut t_vec = t_hat_vec.clone();
+    t_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+
+    // 5. (t0_vec, t1_vec) = Power2Round(t_vec, D_PARAM)
+    let (t0_vec, t1_vec) = power2round_polyvec(&t_vec, P::D_PARAM as u32);
+
+    // 6. pk = (rho_seed, pack(t1_vec))
+    let pk_bytes = pack_public_key::<P>(&rho_seed, &t1_vec)?;
+
+    // 7. tr = H(pk_bytes) (SHA3-256)
+    let mut hasher_tr = Sha3_256::new();
+    hasher_tr.update(&pk_bytes).map_err(SignError::from_algo)?;
+    let tr_digest = hasher_tr.finalize().map_err(SignError::from_algo)?;
+    let mut tr = [0u8; P::HASH_TR_BYTES]; // Use const from P
+    tr.copy_from_slice(tr_digest.as_ref());
+
+    // 8. sk = (rho_seed, k_seed_for_signing, tr, pack(s1_vec), pack(s2_vec), pack(t0_vec))
+    let sk_bytes = pack_secret_key::<P>(&rho_seed, &k_seed_for_signing, &tr, &s1_vec, &s2_vec, &t0_vec)?;
+    
+    Ok((pk_bytes, sk_bytes))
+}
+
+
+/// Internal Signing logic for Dilithium (Algorithm 10 from FIPS 203).
+pub(crate) fn sign_internal<P, R>(
+    message: &[u8],
+    sk_bytes: &[u8],
+    _rng_for_hedging_if_any: &mut R, // Standard Dilithium is deterministic given SK and message.
+) -> SignResult<Vec<u8>>
+where
+    P: DilithiumParams,
+    R: RngCore + CryptoRng,
+{
+    let (rho_seed, k_seed, tr_hash, s1_vec, s2_vec, t0_vec) = unpack_secret_key::<P>(sk_bytes)?;
+    
+    let mut s1_hat_vec = s1_vec.clone(); s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    // s2 is used in standard domain for w - c*s2
+    // t0 is used in standard domain for w1_prime - c*t0 (UseHint part)
+
+    let matrix_a_orig = expand_matrix_a::<P>(&rho_seed)?;
+    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
+    for i in 0..P::K_DIM {
+        for j in 0..P::L_DIM {
+            let mut poly = matrix_a_orig[i].polys[j].clone();
+            poly.ntt_inplace().map_err(SignError::from_algo)?;
+            matrix_a_hat[i].polys[j] = poly;
+        }
+    }
+
+    // mu = H_msg(tr_hash || message) (SHA3-512)
+    let mut hasher_mu = Sha3_512::new();
+    hasher_mu.update(&tr_hash).map_err(SignError::from_algo)?;
+    hasher_mu.update(message).map_err(SignError::from_algo)?;
+    let mu_digest = hasher_mu.finalize().map_err(SignError::from_algo)?;
+    let mu = mu_digest.as_ref();
+
+    let mut kappa: u16 = 0;
+    loop { // Fiat-Shamir with Aborts
+        if kappa > P::MAX_SIGN_ABORTS { // Add MAX_SIGN_ABORTS to DilithiumParams
+            return Err(SignError::SignatureGeneration("Exceeded max signature attempts".into()));
+        }
+
+        let y_vec = sample_polyvecl_uniform_gamma1::<P>(&k_seed, kappa, P::GAMMA1_PARAM as u32)?;
+        let mut y_hat_vec = y_vec.clone(); y_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+
+        // w_hat = A_hat * y_hat
+        let mut w_hat_vec = PolyVecK::<P>::zero();
+        for i in 0..P::K_DIM {
+            w_hat_vec.polys[i] = matrix_a_hat[i].pointwise_dot_product(&y_hat_vec);
+        }
+        
+        let mut w_vec = w_hat_vec.clone(); w_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+        
+        // w1 = HighBits(w_vec, 2*gamma2)
+        let w1_vec = highbits_polyvec(&w_vec, 2 * P::GAMMA2_PARAM as u32);
+        let w1_packed = pack_polyveck_w1::<P>(&w1_vec)?;
 
-// Define PublicKey, SecretKey, SignatureData specific to Dilithium,
-// potentially wrapping PolyVecs or byte arrays.
-// For this stub, we'll use Vec<u8> as in the snapshot.
-#[derive(Clone, Zeroize)]
-pub struct PublicKey(pub Vec<u8>);
-#[derive(Clone, Zeroize)]
-pub struct SecretKey(pub Vec<u8>);
-#[derive(Clone)]
-pub struct Signature(pub Vec<u8>);
-
-impl AsRef<[u8]> for PublicKey { fn as_ref(&self) -> &[u8] { &self.0 } }
-impl AsMut<[u8]> for PublicKey { fn as_mut(&mut self) -> &mut [u8] { &mut self.0 } }
-// ... and so on for SecretKey, Signature
-
-pub struct DilithiumSign<P: DilithiumParams + 'static> {
-    _params: core::marker::PhantomData<P>,
+        // c_tilde_seed = H_chal(mu || w1_packed) (SHA3-256)
+        let mut hasher_ctilde_seed = Sha3_256::new();
+        hasher_ctilde_seed.update(mu).map_err(SignError::from_algo)?;
+        hasher_ctilde_seed.update(&w1_packed).map_err(SignError::from_algo)?;
+        let c_tilde_seed_digest = hasher_ctilde_seed.finalize().map_err(SignError::from_algo)?;
+        let mut c_tilde_seed = [0u8; P::SEED_C_TILDE_BYTES];
+        c_tilde_seed.copy_from_slice(c_tilde_seed_digest.as_ref());
+        
+        let c_poly = sample_challenge_c::<P>(&c_tilde_seed, P::TAU_PARAM as u32)?;
+        
+        // z_vec = y_vec + c_poly * s1_vec (standard domain)
+        let mut z_vec = y_vec.clone();
+        for i in 0..P::L_DIM {
+            let cs1_i = c_poly.schoolbook_mul(&s1_vec.polys[i]);
+            z_vec.polys[i] = z_vec.polys[i].add(&cs1_i);
+        }
+        
+        if !check_norm_polyvec(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
+            kappa = kappa.wrapping_add(1); continue;
+        }
+        
+        // LowBits(w_vec - c_poly * s2_vec)
+        let mut cs2_vec = PolyVecK::<P>::zero();
+        for i in 0..P::K_DIM {
+            cs2_vec.polys[i] = c_poly.schoolbook_mul(&s2_vec.polys[i]);
+        }
+        let w_minus_cs2_vec = w_vec.sub(&cs2_vec);
+        let lowbits_w_cs2_vec = lowbits_polyvec(&w_minus_cs2_vec, 2 * P::GAMMA2_PARAM as u32);
+        
+        if !check_norm_polyvec(&lowbits_w_cs2_vec, P::GAMMA2_PARAM - P::BETA_PARAM) {
+            kappa = kappa.wrapping_add(1); continue;
+        }
+
+        // MakeHint for h_vec. v = w - c*s2. Check uses v - c*t0.
+        // Hint = MakeHint(-c*t0, v - c*t0) = MakeHint(-c*t0, w - c*s2 - c*t0)
+        // FIPS 203 Algorithm 10 line 17: h = MakeHint(-c*t0, w1 + c*t0) is incorrect.
+        // It should be related to w0 - c*t0 (the part removed by HighBits).
+        // Correctly, h is MakeHint(v0_prime, v1_prime) where (v0_prime, v1_prime) = Decompose(w-c*s2-c*t0).
+        // Let's assume `make_hint_polyveck` is correctly implemented based on `v_for_hint = w_vec - cs2_vec - ct0_vec`.
+        let mut ct0_vec = PolyVecK::<P>::zero();
+        for i in 0..P::K_DIM {
+            ct0_vec.polys[i] = c_poly.schoolbook_mul(&t0_vec.polys[i]);
+        }
+        let v_for_hint_poly = w_minus_cs2_vec.sub(&ct0_vec); // w - c*s2 - c*t0
+        // Decompose v_for_hint_poly to get its v0 and v1 parts for MakeHint
+        let (v0_for_hint, v1_for_hint) = power2round_polyvec(&v_for_hint_poly, P::D_PARAM as u32); // This is not correct, MakeHint uses Decompose with 2*gamma2
+        // Placeholder for actual hint generation based on spec (is complex)
+        let h_hint_poly = make_hint_polyveck::<P>(&v0_for_hint, &v1_for_hint)?;
+        
+        let mut hint_count = 0;
+        for poly_h in h_hint_poly.polys.iter() {
+            for &coeff_h in poly_h.coeffs.iter() { if coeff_h == 1 { hint_count += 1; }}
+        }
+        if hint_count > P::OMEGA_PARAM as usize {
+            kappa = kappa.wrapping_add(1); continue;
+        }
+
+        return pack_signature::<P>(&c_tilde_seed, &z_vec, &h_hint_poly);
+    }
 }
 
-impl<P: DilithiumParams + 'static> SignatureTrait for DilithiumSign<P> {
-    type PublicKey = PublicKey;
-    type SecretKey = SecretKey;
-    type SignatureData = Signature;
-    type KeyPair = (Self::PublicKey, Self::SecretKey);
-
-    fn name() -> &'static str { P::NAME }
-
-    fn keypair<R: RngCore + CryptoRng>(rng: &mut R) -> ApiResult<Self::KeyPair> {
-        // 1. Generate seeds: zeta, rho, K
-        // 2. Expand rho to matrix A (PolyVecL<Polynomial<DilithiumPolyModParams>>)
-        // 3. Sample s1, s2 from CBD (PolyVecL, PolyVecK)
-        // 4. Compute t = A*s1 + s2. t0 = Power2Round(t). t1 = t - t0 / 2^d.
-        // 5. Public Key = (rho, pack(t1))
-        // 6. Secret Key = (rho, K, tr, pack(s1), pack(s2), pack(t0))
-        //    (tr is H(rho||pk))
-
-        // Placeholder:
-        let pk_len = P::PUBLIC_KEY_SIZE;
-        let sk_len = P::SECRET_KEY_SIZE;
-        let mut pk_bytes = vec![0u8; pk_len];
-        let mut sk_bytes = vec![0u8; sk_len];
-        rng.fill_bytes(&mut pk_bytes);
-        rng.fill_bytes(&mut sk_bytes);
-        Ok((PublicKey(pk_bytes), SecretKey(sk_bytes)))
+/// Internal Verification logic for Dilithium (Algorithm 11 from FIPS 203).
+pub(crate) fn verify_internal<P>(
+    message: &[u8],
+    sig_bytes: &[u8],
+    pk_bytes: &[u8],
+) -> SignResult<()>
+where
+    P: DilithiumParams,
+{
+    let (rho_seed, t1_vec) = unpack_public_key::<P>(pk_bytes)?;
+    // h_packed_indices is really the packed form of h, not yet a PolyVecK of 0/1s.
+    // Needs proper unpacking based on FIPS 203 Appendix A.3
+    let (c_tilde_seed_sig, z_vec, h_packed_poly) = unpack_signature::<P>(sig_bytes)?;
+
+    if !check_norm_polyvec(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
+        return Err(SignError::Verification("Signature norm check for z failed".into()));
     }
+    
+    let matrix_a_orig = expand_matrix_a::<P>(&rho_seed)?;
+    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
+    for i in 0..P::K_DIM {
+        for j in 0..P::L_DIM {
+            let mut poly = matrix_a_orig[i].polys[j].clone();
+            poly.ntt_inplace().map_err(SignError::from_algo)?;
+            matrix_a_hat[i].polys[j] = poly;
+        }
+    }
+
+    let c_poly = sample_challenge_c::<P>(&c_tilde_seed_sig, P::TAU_PARAM as u32)?;
+    let mut c_hat_poly = c_poly.clone(); c_hat_poly.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    let mut z_hat_vec = z_vec.clone(); z_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    let mut t1_hat_vec = t1_vec.clone(); t1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
 
-    fn public_key(keypair: &Self::KeyPair) -> Self::PublicKey { keypair.0.clone() }
-    fn secret_key(keypair: &Self::KeyPair) -> Self::SecretKey { keypair.1.clone() }
-
-    fn sign(
-        message: &[u8],
-        secret_key: &Self::SecretKey,
-    ) -> ApiResult<Self::SignatureData> {
-        // Fiat-Shamir with Aborts:
-        // 1. Unpack SK. Sample y from uniform_gamma1.
-        // 2. Compute w1 = HighBits(A*y).
-        // 3. mu = H(tr||message). kappa from 0..
-        // 4. rho_prime = H(K||mu||kappa).
-        // 5. c_tilde = H(rho_prime || w1). Parse c from c_tilde.
-        // 6. z = y + c*s1. If norm(z) or norm(LowBits(Ay - cs2)) too large, increment kappa, goto 4.
-        // 7. h = MakeHint(-cs2, Ay - cs1).
-        // 8. Signature = (pack(c_tilde), pack(z), pack(h))
-
-        // Placeholder:
-        let sig_len = P::SIGNATURE_SIZE;
-        let sig_bytes = vec![0u8; sig_len];
-        Ok(Signature(sig_bytes))
+    // w1_prime_hat = A_hat * z_hat - c_hat * t1_hat
+    // (A_hat * z_hat)_i = sum_j (A_hat_ij * z_hat_j)
+    // (c_hat * t1_hat)_i = c_hat * t1_hat_i
+    let mut w1_prime_hat_vec = PolyVecK::<P>::zero();
+    for i in 0..P::K_DIM { // For each of K polynomials in the result vector
+        let az_i = matrix_a_hat[i].pointwise_dot_product(&z_hat_vec);
+        let ct1_i = t1_hat_vec.polys[i].ntt_mul(&c_hat_poly);
+        w1_prime_hat_vec.polys[i] = az_i.sub(&ct1_i);
     }
+    
+    let mut w1_prime_vec = w1_prime_hat_vec.clone();
+    w1_prime_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+
+    // Apply UseHint. The spec is w1'' = UseHint(h, A*z - c*t1) where (A*z - c*t1) is w1_prime_vec.
+    // h_packed_poly needs to be correctly interpreted as hint indices.
+    let w1_double_prime_vec = use_hint_polyveck_from_sig::<P>(&h_packed_poly, &w1_prime_vec)?;
+    let w1_double_prime_packed = pack_polyveck_w1::<P>(&w1_double_prime_vec)?;
+
+    // tr = H(pk_bytes)
+    let mut hasher_tr = Sha3_256::new();
+    hasher_tr.update(pk_bytes).map_err(SignError::from_algo)?;
+    let tr_digest = hasher_tr.finalize().map_err(SignError::from_algo)?;
+    let mut tr = [0u8; P::HASH_TR_BYTES];
+    tr.copy_from_slice(tr_digest.as_ref());
 
-    fn verify(
-        message: &[u8],
-        signature: &Self::SignatureData,
-        public_key: &Self::PublicKey,
-    ) -> ApiResult<()> {
-        // 1. Unpack PK and signature.
-        // 2. Expand A from rho. Parse c, z, h from signature.
-        // 3. Check norm(z).
-        // 4. w1_prime = HighBits(A*z - c*t1).
-        // 5. c_prime_tilde = H(H(rho||pk_t1)||message || w1_prime).
-        // 6. Check c_tilde == c_prime_tilde.
-        // 7. Check MakeHint(Az - ct1 + ct0) == h.
-
-        // Placeholder:
-        Ok(())
+    // mu = H_msg(tr || message)
+    let mut hasher_mu = Sha3_512::new();
+    hasher_mu.update(&tr).map_err(SignError::from_algo)?;
+    hasher_mu.update(message).map_err(SignError::from_algo)?;
+    let mu_digest = hasher_mu.finalize().map_err(SignError::from_algo)?;
+    let mu = mu_digest.as_ref();
+
+    // c_tilde_seed_recomputed = H_chal(mu || w1_double_prime_packed)
+    let mut hasher_ctilde_seed_recomputed = Sha3_256::new();
+    hasher_ctilde_seed_recomputed.update(mu).map_err(SignError::from_algo)?;
+    hasher_ctilde_seed_recomputed.update(&w1_double_prime_packed).map_err(SignError::from_algo)?;
+    let c_tilde_seed_recomputed_digest = hasher_ctilde_seed_recomputed.finalize().map_err(SignError::from_algo)?;
+    
+    // Constant time comparison for c_tilde_seed
+    if !c_tilde_seed_sig.ct_eq(c_tilde_seed_recomputed_digest.as_ref()).into_bool() {
+         return Err(SignError::Verification("Challenge c_tilde mismatch".into()));
+    }
+    
+    // Verify hint count (omega check from h_packed_poly)
+    let mut hint_count = 0;
+    for poly_h in h_packed_poly.polys.iter() {
+        for &coeff_h in poly_h.coeffs.iter() { if coeff_h == 1 { hint_count += 1; }}
     }
+    if hint_count > P::OMEGA_PARAM as usize {
+        return Err(SignError::Verification("Too many hints indicated in signature".into()));
+    }
+
+    Ok(())
 }
\ No newline at end of file
