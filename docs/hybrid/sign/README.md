# Hybrid Digital Signatures 

## Overview

This module provides hybrid digital signature schemes by combining traditional, battle-tested cryptographic algorithms with modern, post-quantum algorithms. The goal is to ensure signature validity and authenticity against both classical and quantum adversaries.

A hybrid signature is created by signing a message with two separate algorithms. The resulting signature is a concatenation of both individual signatures. For a hybrid signature to be considered valid, both of its components must be successfully verified. This ensures security as long as at least one of the underlying signature schemes remains unbroken.

This module exports the following hybrid signature schemes:

*   `EcdsaDilithiumHybrid`: Combines the classical **ECDSA P-384** with the post-quantum **Dilithium3**. [1]
*   `RsaFalconHybrid`: Combines the classical **RSA-PSS** with the post-quantum **Falcon-512**. [4]

## How It Works

1.  **Key Generation**: A hybrid key pair is generated by creating a key pair for the classical algorithm and another for the post-quantum algorithm. The public and secret keys are stored together in `HybridPublicKey` and `HybridSecretKey` structs. [1, 4]
2.  **Signing**: To sign a message, the `sign` function is called with the hybrid secret key. The function internally signs the message once using the classical key and a second time using the post-quantum key. The two resulting signatures are bundled into a `HybridSignature`. [1, 4]
3.  **Verification**: To verify, the `verify` function is called with the hybrid public key and the `HybridSignature`. The function performs two separate verifications: one for the classical signature component and one for the post-quantum component. The overall verification succeeds only if *both* individual verifications pass. [1, 4]

## Example Usage

Here is an example demonstrating a full sign-and-verify roundtrip using the `EcdsaDilithiumHybrid` scheme. This assumes you are using the top-level `dcrypt` crate which re-exports the necessary modules.

```rust
use dcrypt::hybrid::sign::EcdsaDilithiumHybrid;
use dcrypt::api::Signature; // Use the generic Signature trait
use rand::rngs::OsRng;

// 1. Generate a hybrid key pair.
// This creates both an ECDSA P-384 key pair and a Dilithium3 key pair.
let (public_key, secret_key) = EcdsaDilithiumHybrid::keypair(&mut OsRng)
    .expect("Hybrid key pair generation failed");

let message = b"This is a message that needs to be securely signed.";

// 2. Sign the message with the hybrid secret key.
// This produces both an ECDSA signature and a Dilithium3 signature.
let hybrid_signature = EcdsaDilithiumHybrid::sign(message, &secret_key)
    .expect("Signing failed");

// 3. Verify the hybrid signature with the hybrid public key.
// This verifies both signature components. The function will return an
// error if either of the two verifications fails.
let verification_result = EcdsaDilithiumHybrid::verify(
    message,
    &hybrid_signature,
    &public_key,
);

assert!(verification_result.is_ok());

println!("Successfully created and verified a hybrid ECDSA + Dilithium signature!");

// --- Example of a failed verification ---

// Generate a different key pair
let (other_pk, _) = EcdsaDilithiumHybrid::keypair(&mut OsRng).unwrap();

// Verification with the wrong public key must fail.
let failed_verification = EcdsaDilithiumHybrid::verify(
    message,
    &hybrid_signature,
    &other_pk,
);

assert!(failed_verification.is_err());

println!("Verification correctly failed when using the wrong key.");
```