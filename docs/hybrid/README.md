# docs/hybrid/README.md

[![Crates.io](https://img.shields.io/crates/v/dcrypt-hybrid.svg)](https://crates.io/crates/dcrypt-hybrid)
[![Docs.rs](https://docs.rs/dcrypt-hybrid/badge.svg)](https://docs.rs/dcrypt-hybrid)
[![License](https://img.shields.io/badge/license-Apache--2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Repository](https://img.shields.io/badge/repository-GitHub-blue.svg)](https://github.com/DePINNetwork/dcrypt)

## Overview

`dcrypt-hybrid` is a Rust crate that provides hybrid cryptographic schemes by combining classical and post-quantum algorithms. [2, 3] This approach is vital for ensuring long-term security against future threats, particularly from quantum computers, by providing resistance to "Harvest Now, Decrypt Later" attacks.

The core principle is to combine two cryptographic primitives—one classical (like ECDH or ECDSA) and one post-quantum (like Kyber or Dilithium)—such that the resulting scheme is secure as long as *at least one* of the underlying primitives remains secure. [6, 7]

This crate is part of the broader `dcrypt` library ecosystem, which is structured as a Cargo workspace. [2, 7]

## Implemented Schemes

The crate provides hybrid implementations for two primary cryptographic functions: Key Encapsulation Mechanisms (KEMs) and Digital Signatures.

### Hybrid Key Encapsulation Mechanisms (KEMs)

A Key Encapsulation Mechanism (KEM) is used to securely establish a shared secret between two parties. Our hybrid KEM ensures that the shared secret remains confidential even if one of the constituent algorithms is broken in the future.

#### **`EcdhKyber768`**

This scheme combines:
*   **Classical:** Elliptic Curve Diffie-Hellman over P-256 (`EcdhP256`).
*   **Post-Quantum:** `Kyber-768`, a KEM standardized by NIST. [6]

**How it works:**
1.  A key pair is generated by creating both an ECDH key pair and a Kyber key pair. The public keys are concatenated.
2.  To encapsulate (generate a shared secret), the sender uses the recipient's hybrid public key to perform two separate encapsulation operations, one for ECDH and one for Kyber.
3.  This results in two different shared secrets. These are combined into a single, final shared secret using HKDF-SHA256.
4.  The recipient performs two decapsulation operations using their hybrid secret key and combines the resulting secrets in the same way to derive the identical final shared secret.

**Example Usage:**
```rust
// Assumes a top-level `dcrypt` crate re-exports the necessary modules.
use dcrypt::api::Kem;
use dcrypt::hybrid::kem::EcdhKyber768;
use rand::rngs::OsRng;

// 1. Generate a hybrid key pair for the recipient.
let (pk, sk) = EcdhKyber768::keypair(&mut OsRng).expect("Keypair generation failed");

// 2. The sender encapsulates a secret for the recipient's public key.
let (ciphertext, shared_secret_sender) = EcdhKyber768::encapsulate(&mut OsRng, &pk)
    .expect("Encapsulation failed");

// 3. The recipient decapsulates the ciphertext with their secret key.
let shared_secret_recipient = EcdhKyber768::decapsulate(&sk, &ciphertext)
    .expect("Decapsulation failed");

// 4. Both parties now have the same shared secret.
assert_eq!(
    shared_secret_sender.to_bytes_zeroizing().as_ref(),
    shared_secret_recipient.to_bytes_zeroizing().as_ref()
);

println!("Successfully established a hybrid shared secret!");
```

### Hybrid Digital Signatures

A digital signature is used to verify the authenticity and integrity of a message. A hybrid signature requires that both the classical and post-quantum signatures are valid.

#### **`EcdsaDilithiumHybrid`**

This scheme combines:
*   **Classical:** `ECDSA` with the P-384 curve.
*   **Post-Quantum:** `Dilithium3`, a signature algorithm selected by the NIST PQC standardization process.

#### **`RsaFalconHybrid`**

This scheme combines:
*   **Classical:** `RSA-PSS`.
*   **Post-Quantum:** `Falcon-512`, another signature algorithm from the NIST PQC process.

**How it works:**
1.  A hybrid key pair consists of both a classical and a post-quantum key pair.
2.  To sign a message, two separate signatures are generated—one with the classical key and one with the post-quantum key. These are concatenated to form the hybrid signature.
3.  To verify, a recipient must successfully verify *both* component signatures using the hybrid public key. If either fails, the entire signature is considered invalid.

**Example Usage:**
```rust
// Assumes a top-level `dcrypt` crate re-exports the necessary modules.
use dcrypt::api::Signature;
use dcrypt::hybrid::sign::EcdsaDilithiumHybrid;
use rand::rngs::OsRng;

// 1. Generate a hybrid key pair.
let (pk, sk) = EcdsaDilithiumHybrid::keypair(&mut OsRng).expect("Keypair generation failed");

let message = b"This message needs a hybrid signature.";

// 2. Sign the message with the hybrid secret key.
let signature = EcdsaDilithiumHybrid::sign(message, &sk).expect("Signing failed");

// 3. Verify the hybrid signature with the public key.
let verification_result = EcdsaDilithiumHybrid::verify(message, &signature, &pk);

assert!(verification_result.is_ok());

println!("Successfully created and verified a hybrid signature!");
```

## Installation

Add `dcrypt-hybrid` to your `Cargo.toml` dependencies:
```toml
[dependencies]
dcrypt-hybrid = { version = "0.12.0-beta.1", path = "../hybrid" } # Example for local workspace dependency
# Or from crates.io
# dcrypt-hybrid = "0.12.0-beta.1"
```
Or use the cargo command:
```sh
cargo add dcrypt-hybrid
```

## Features

This crate is designed to be flexible and supports `no_std` environments.

*   **`std`** (default): Enables functionality that requires the standard library.
*   **`no_std`**: For use in environments without the standard library, such as embedded systems or WASM. You must depend on the crate with `default-features = false`.
*   **`serde`**: Enables serialization and deserialization for public key and signature types via the [Serde](https://serde.rs/) framework.

## License

This crate is licensed under the Apache-2.0 License. See the [LICENSE](https://github.com/DePINNetwork/dcrypt/blob/main/LICENSE) file for details.