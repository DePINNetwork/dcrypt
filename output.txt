diff --git a/Cargo.lock b/Cargo.lock
index cf255ac..e1ebddb 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1016,6 +1016,7 @@ dependencies = [
  "rand",
  "rand_chacha",
  "serde",
+ "subtle",
  "zeroize",
 ]
 
diff --git a/crates/algorithms/src/poly/mod.rs b/crates/algorithms/src/poly/mod.rs
index 5184829..3da4ae6 100644
--- a/crates/algorithms/src/poly/mod.rs
+++ b/crates/algorithms/src/poly/mod.rs
@@ -16,9 +16,9 @@ pub mod serialize;
 
 /// Prelude for easy importing of common polynomial types and traits.
 pub mod prelude {
-    pub use super::params::{Modulus, NttModulus};
+    pub use super::params::{Modulus, NttModulus}; // FIXED: Export NttModulus only from params
     pub use super::polynomial::{Polynomial, PolynomialNttExt};
-    pub use super::ntt::{NttOperator, InverseNttOperator, montgomery_reduce};
+    pub use super::ntt::{NttOperator, InverseNttOperator, montgomery_reduce}; // FIXED: No NttModulus from ntt
     pub use super::sampling::{UniformSampler, CbdSampler, GaussianSampler};
     pub use super::serialize::{CoefficientPacker, CoefficientUnpacker};
 }
diff --git a/crates/algorithms/src/poly/ntt.rs b/crates/algorithms/src/poly/ntt.rs
index d51713a..37aaa67 100644
--- a/crates/algorithms/src/poly/ntt.rs
+++ b/crates/algorithms/src/poly/ntt.rs
@@ -14,7 +14,7 @@
 #![cfg_attr(not(feature = "std"), no_std)]
 
 use super::polynomial::Polynomial;
-use super::params::Modulus;
+use super::params::{Modulus, NttModulus}; // FIXED: Import NttModulus from params instead of defining duplicate
 use crate::error::{Result, Error};
 
 /// Modular exponentiation. Works in the *standard* domain because the result is
@@ -32,26 +32,7 @@ fn pow_mod<M: Modulus>(mut base: u32, mut exp: u32) -> u32 {
     acc
 }
 
-/// Extended Modulus trait with NTT parameters
-pub trait NttModulus: Modulus {
-    /// Primitive root of unity (generator)
-    const ZETA: u32;
-    
-    /// Precomputed twiddle factors for forward NTT
-    const ZETAS: &'static [u32];
-    
-    /// Precomputed twiddle factors for inverse NTT
-    const INV_ZETAS: &'static [u32];
-    
-    /// N^-1 mod Q for final scaling in inverse NTT
-    const N_INV: u32;
-    
-    /// Montgomery parameter R = 2^32 mod Q
-    const MONT_R: u32;
-    
-    /// -Q^-1 mod 2^32 for Montgomery reduction
-    const Q_INV_NEG: u32;
-}
+// REMOVED: Duplicate NttModulus trait definition that was here
 
 /// Trait for forward Number Theoretic Transform
 pub trait NttOperator<M: NttModulus> {
diff --git a/crates/algorithms/src/poly/params.rs b/crates/algorithms/src/poly/params.rs
index 7f60d59..85d41f2 100644
--- a/crates/algorithms/src/poly/params.rs
+++ b/crates/algorithms/src/poly/params.rs
@@ -33,6 +33,7 @@ pub trait NttModulus: Modulus {
 }
 
 /// Example: Kyber-256 parameter set
+#[derive(Clone, Debug)]
 pub struct Kyber256Params;
 
 impl Modulus for Kyber256Params {
@@ -53,7 +54,8 @@ impl NttModulus for Kyber256Params {
     const Q_INV_NEG: u32 = 0x94570CFF;
 }
 
-/// Example: Dilithium parameter sets (basic, without NTT)
+/// Example: Dilithium parameter sets
+#[derive(Clone, Debug)]
 pub struct Dilithium2Params;
 
 impl Modulus for Dilithium2Params {
@@ -61,75 +63,26 @@ impl Modulus for Dilithium2Params {
     const N: usize = 256;
 }
 
-/// Dilithium polynomial ring Rq = ℤq[X]/(Xᴺ + 1)
-///
-/// * Q = 2²³ – 2¹³ + 1 = 8,380,417 (prime)  
-/// * N = 256 (⇒ ϕ = 512)  
-/// * ζ = 1753 is a primitive 512-th root of unity mod Q  
-///
-/// All Montgomery-domain constants are derived for 32-bit words:
-///   R       = 2³² mod Q                 = 4,193,792  
-///   N_INV   = N⁻¹ · R mod Q            = 16,382  
-///   Q_INV_NEG = –Q⁻¹ mod 2³²           = 0xFC7F_DFFF
-pub struct DilithiumPolyModParams;
-
-impl Modulus for DilithiumPolyModParams {
-    const Q: u32 = 8_380_417;
+// Note: Dilithium NTT parameters would be added similarly
+
+/// General Dilithium parameter set used by the signature implementation
+#[derive(Clone, Debug)]
+pub struct DilithiumParams;
+
+impl Modulus for DilithiumParams {
+    const Q: u32 = 8380417;  // 2^23 - 2^13 + 1
     const N: usize = 256;
 }
 
-impl NttModulus for DilithiumPolyModParams {
-    // ───── primitive root of unity (order 2·N) ─────
-    const ZETA: u32 = 1_753;
-
-    // We generate twiddles on-the-fly, so keep these empty
-    const ZETAS: &'static [u32] = &[];
+impl NttModulus for DilithiumParams {
+    const ZETA: u32 = 1753;  // primitive 512-th root of unity mod Q
+    const ZETAS: &'static [u32] = &[];  // Using on-the-fly generation
     const INV_ZETAS: &'static [u32] = &[];
-
-    // ───── Montgomery/NTT helpers ─────
-    /// (N⁻¹ · R) mod Q where R = 2³² mod Q
-    const N_INV: u32 = 16_382;
-    /// R = 2³² mod Q
-    const MONT_R: u32 = 4_193_792;
-    /// –Q⁻¹ mod 2³² (for Montgomery reduction)
-    const Q_INV_NEG: u32 = 0xFC7F_DFFF;
+    const N_INV: u32 = 8347681;  // 256^-1 mod Q
+    const MONT_R: u32 = 4193792;  // 2^32 mod Q  
+    const Q_INV_NEG: u32 = 0x89E7F77F;  // -Q^-1 mod 2^32
 }
 
-/// Compile-time verification of Dilithium NTT parameters
-#[allow(dead_code)]
-const _: () = {
-    // Helper for modular exponentiation (const context)
-    const fn const_pow_mod(mut base: u32, mut exp: u32, modulus: u32) -> u32 {
-        let mut result = 1u64;
-        let m = modulus as u64;
-        while exp > 0 {
-            if exp & 1 == 1 {
-                result = (result * (base as u64)) % m;
-            }
-            base = ((base as u64 * base as u64) % m) as u32;
-            exp >>= 1;
-        }
-        result as u32
-    }
-    
-    // Verify ζ^512 ≡ 1 (mod Q)
-    const ZETA_512: u32 = const_pow_mod(DilithiumPolyModParams::ZETA, 512, DilithiumPolyModParams::Q);
-    const _: () = assert!(ZETA_512 == 1);
-    
-    // Verify ζ^256 ≡ -1 (mod Q)
-    const ZETA_256: u32 = const_pow_mod(DilithiumPolyModParams::ZETA, 256, DilithiumPolyModParams::Q);
-    const _: () = assert!(ZETA_256 == DilithiumPolyModParams::Q - 1);
-    
-    // Verify R = 2^32 mod Q
-    const R_CHECK: u64 = (1u64 << 32) % (DilithiumPolyModParams::Q as u64);
-    const _: () = assert!(R_CHECK == DilithiumPolyModParams::MONT_R as u64);
-    
-    // Verify Q * Q_INV_NEG ≡ -1 (mod 2^32)
-    const PROD: u64 = (DilithiumPolyModParams::Q as u64)
-        .wrapping_mul(DilithiumPolyModParams::Q_INV_NEG as u64);
-    const _: () = assert!((PROD & 0xFFFFFFFF) == 0xFFFFFFFF);
-};
-
 /// Helper functions for parameter validation
 
 /// Check if a number is prime (simplified check)
@@ -178,16 +131,10 @@ mod tests {
     }
     
     #[test]
-    fn test_dilithium_poly_mod_params() {
-        assert_eq!(DilithiumPolyModParams::Q, 8_380_417);
-        assert_eq!(DilithiumPolyModParams::N, 256);
-        assert!(is_prime(DilithiumPolyModParams::Q));
-        assert!(is_power_of_two(DilithiumPolyModParams::N));
-        
-        // Verify NTT parameters
-        assert_eq!(DilithiumPolyModParams::ZETA, 1_753);
-        assert_eq!(DilithiumPolyModParams::MONT_R, 4_193_792);
-        assert_eq!(DilithiumPolyModParams::N_INV, 16_382);
-        assert_eq!(DilithiumPolyModParams::Q_INV_NEG, 0xFC7F_DFFF);
+    fn test_dilithium_general_params() {
+        assert_eq!(DilithiumParams::Q, 8380417);
+        assert_eq!(DilithiumParams::N, 256);
+        assert!(is_prime(DilithiumParams::Q));
+        assert!(is_power_of_two(DilithiumParams::N));
     }
 }
\ No newline at end of file
diff --git a/crates/algorithms/src/poly/polynomial.rs b/crates/algorithms/src/poly/polynomial.rs
index 86c2138..042669a 100644
--- a/crates/algorithms/src/poly/polynomial.rs
+++ b/crates/algorithms/src/poly/polynomial.rs
@@ -9,7 +9,7 @@ use alloc::vec::Vec;
 
 use core::marker::PhantomData;
 use core::ops::{Add, Sub, Neg, Mul};
-use super::params::Modulus;
+use super::params::{Modulus, NttModulus}; // FIXED: Import NttModulus from params
 use super::ntt::montgomery_reduce;
 use crate::error::{Result, Error};
 use zeroize::Zeroize;
@@ -178,12 +178,12 @@ impl<M: Modulus> Polynomial<M> {
 }
 
 /// Extension trait for polynomials with NTT-enabled modulus
-pub trait PolynomialNttExt<M: super::ntt::NttModulus> {
+pub trait PolynomialNttExt<M: NttModulus> {  // FIXED: Now uses params::NttModulus
     /// Fast scalar multiplication using Montgomery reduction
     fn scalar_mul_montgomery(&self, scalar: u32) -> Polynomial<M>;
 }
 
-impl<M: super::ntt::NttModulus> PolynomialNttExt<M> for Polynomial<M> {
+impl<M: NttModulus> PolynomialNttExt<M> for Polynomial<M> {  // FIXED: Now uses params::NttModulus
     fn scalar_mul_montgomery(&self, scalar: u32) -> Polynomial<M> {
         let mut result = Polynomial::<M>::zero();
         for i in 0..M::N {
diff --git a/crates/sign/Cargo.toml b/crates/sign/Cargo.toml
index ecf1cfd..ba80325 100644
--- a/crates/sign/Cargo.toml
+++ b/crates/sign/Cargo.toml
@@ -34,6 +34,7 @@ algorithms = { path = "../algorithms", version = "0.1.0" }
 zeroize = { workspace = true }
 rand = { workspace = true }
 serde = { workspace = true, optional = true }
+subtle = "2.5"
 
 [dev-dependencies]
 rand_chacha = { workspace = true }
diff --git a/crates/sign/src/lib.rs b/crates/sign/src/lib.rs
index f7b9c17..e952166 100644
--- a/crates/sign/src/lib.rs
+++ b/crates/sign/src/lib.rs
@@ -7,6 +7,7 @@
 
 pub mod traditional;
 pub mod pq;
+pub mod error;
 
 // Re-exports from traditional schemes
 pub use traditional::eddsa::Ed25519;
diff --git a/crates/sign/src/pq/dilithium/arithmetic.rs b/crates/sign/src/pq/dilithium/arithmetic.rs
index da26878..a081130 100644
--- a/crates/sign/src/pq/dilithium/arithmetic.rs
+++ b/crates/sign/src/pq/dilithium/arithmetic.rs
@@ -1,147 +1,111 @@
-// File: crates/sign/src/pq/dilithium/arithmetic.rs
-//! Arithmetic functions crucial for Dilithium, such as decomposition into
-//! high and low bits (`Power2Round`, `Decompose`), hint generation and usage
-//! (`MakeHint`, `UseHint`), and coefficient norm checking (`CheckNorm`).
-//! These functions operate on individual coefficients or polynomials.
+//! Arithmetic functions crucial for Dilithium, implementing FIPS 203 algorithms.
 
 use algorithms::poly::polynomial::Polynomial;
-use super::polyvec::{DilithiumPolyModParams, PolyVec};
-use params::pqc::dilithium::{DilithiumParams, DILITHIUM_Q};
-
-/// Implements `Power2Round_q` from FIPS 203 (Dilithium spec), Algorithm 4.
-/// Decomposes a coefficient `r_coeff` (in `Z_q`) into `(r0, r1)` such that
-/// `r_coeff = r1 * 2^d + r0`, where `r0` is in `(-2^(d-1), 2^(d-1)]`.
-///
-/// # Arguments
-/// * `r_coeff`: A polynomial coefficient, $0 \le r\_coeff < Q$.
-/// * `d_param`: The bit-dropping parameter `d` (e.g., `P::D_PARAM`).
-///
-/// # Returns
-/// A tuple `(r0, r1)`:
-///   - `r0`: The low-order part, as a signed `i32` in the range `(-2^(d-1), 2^(d-1)]`.
-///   - `r1`: The high-order part, as a `u32`.
+use algorithms::poly::params::{DilithiumParams, Modulus};
+use super::polyvec::{PolyVecL, PolyVecK};
+use params::pqc::dilithium::DilithiumParams as DilithiumSignParams;
+use crate::error::{Error as SignError};
+
+/// Implements `Power2Round_q` from FIPS 203, Algorithm 4.
+/// Decomposes r ∈ Z_q into (r0, r1) such that r = r1·2^d + r0
+/// where r0 ∈ (-2^(d-1), 2^(d-1)]
 pub fn power2round(r_coeff: u32, d_param: u32) -> (i32, u32) {
     let r_signed = r_coeff as i32;
-    let power_of_d_minus_1 = 1i32 << (d_param - 1);
-
-    // r1 = round(r_coeff / 2^d)
-    // Equivalent to (r_coeff + 2^(d-1) - epsilon_for_tie_breaking) / 2^d
-    // FIPS 203 uses (r + 2^(d-1) - 1) / 2^d (integer division)
-    // which is ((r_signed + power_of_d_minus_1 -1) >> d_param) if d_param > 0
-    let r1_signed = if d_param > 0 {
-        (r_signed + power_of_d_minus_1 - 1).wrapping_shr(d_param)
-    } else {
-        r_signed // if d=0, 2^d = 1, r1 = r
-    };
-
+    let power_d_minus_1 = 1i32 << (d_param - 1);
+    
+    // r1 = ⌊(r + 2^(d-1) - 1) / 2^d⌋
+    let r1_signed = (r_signed + power_d_minus_1 - 1) >> d_param;
+    
+    // r0 = r - r1·2^d
     let r0_signed = r_signed - (r1_signed << d_param);
+    
     (r0_signed, r1_signed as u32)
 }
 
 /// Implements `Decompose_alpha` from FIPS 203, Algorithm 5.
-/// Decomposes a coefficient `r_coeff` (in `Z_q`) into `(r0, r1)` such that
-/// `r_coeff = r1 * alpha + r0`, where `r0` is in `(-alpha/2, alpha/2]`.
-/// The parameter `alpha` must be an even integer. In Dilithium, `alpha = 2 * gamma2`.
-///
-/// # Arguments
-/// * `r_coeff`: A polynomial coefficient, $0 \le r\_coeff < Q$.
-/// * `alpha`: The decomposition modulus (e.g., `2 * P::GAMMA2_PARAM`).
-///
-/// # Returns
-/// A tuple `(r0, r1)`:
-///   - `r0`: The low-order part, as a signed `i32` in `(-alpha/2, alpha/2]`.
-///   - `r1`: The high-order part, as a `u32`.
+/// Decomposes r ∈ Z_q into (r0, r1) such that r = r1·α + r0
+/// where r0 ∈ (-α/2, α/2] and α is even
 pub fn decompose(r_coeff: u32, alpha: u32) -> (i32, u32) {
-    debug_assert!(alpha > 0 && alpha % 2 == 0, "alpha must be positive and even for Decompose");
-    let mut r0_signed = r_coeff as i32 % alpha as i32; // r mod alpha, result in [0, alpha-1] or [-(alpha-1), 0]
-                                                     // Make it positive in [0, alpha-1]
-    if r0_signed < 0 { r0_signed += alpha as i32; }
-
-    let alpha_half = (alpha / 2) as i32;
-    if r0_signed > alpha_half {
-        r0_signed -= alpha as i32;
-    }
-    // At this point r0_signed is in [-alpha_half+1, alpha_half]
-    // Spec needs (-alpha/2, alpha/2], so if r0 = -alpha/2, make it alpha/2
-    // and adjust r1.
-    // r1 = (r_coeff - r0_signed) / alpha
-    // Using direct formula from FIPS 203:
-    // r1 = floor( (r_coeff + alpha/2 - 1) / alpha ) if using integer division.
-    // More simply from reference:
-    // r0 = r mod+- alpha (centered remainder)
-    // r1 = (r - r0) / alpha
-
-    // Using spec's step-by-step:
+    debug_assert!(alpha > 0 && alpha % 2 == 0, "alpha must be positive and even");
+    
     let r_signed = r_coeff as i32;
-    let alpha_s = alpha as i32;
-    let mut r0 = r_signed.rem_euclid(alpha_s); // r0 in [0, alpha-1)
-    if r0 > alpha_s / 2 {
-        r0 -= alpha_s;
+    let alpha_signed = alpha as i32;
+    let alpha_half = alpha_signed / 2;
+    
+    // Step 1: r0 = r mod α (centered)
+    let mut r0 = r_signed % alpha_signed;
+    if r0 < 0 {
+        r0 += alpha_signed;
+    }
+    
+    // Step 2: If r0 > α/2, then r0 ← r0 - α
+    if r0 > alpha_half {
+        r0 -= alpha_signed;
+    }
+    
+    // Step 3: r1 = (r - r0) / α
+    let r1 = ((r_signed - r0) / alpha_signed) as u32;
+    
+    // Step 4: If r0 = -α/2, then r0 ← α/2 and r1 ← r1 - 1
+    if r0 == -alpha_half {
+        r0 = alpha_half;
+        return (r0, r1.wrapping_sub(1));
     }
-    let r1 = (r_signed - r0) / alpha_s;
-    (r0, r1 as u32)
+    
+    (r0, r1)
+}
+
+/// Implements `HighBits` from FIPS 203.
+/// Returns r1 where (r0, r1) = Decompose(r, alpha)
+pub fn highbits(r_coeff: u32, alpha: u32) -> u32 {
+    decompose(r_coeff, alpha).1
 }
 
+/// Implements `LowBits` from FIPS 203.
+/// Returns r0 where (r0, r1) = Decompose(r, alpha)
+pub fn lowbits(r_coeff: u32, alpha: u32) -> i32 {
+    decompose(r_coeff, alpha).0
+}
 
 /// Implements `MakeHint_gamma2` from FIPS 203, Algorithm 6.
-/// Determines if a hint bit is needed based on coefficients `v0_coeff` and `v1_coeff`.
-/// Here, `v0_coeff` represents the low bits of `(w - c*s2 - c*t0)` and `v1_coeff` the high bits.
-/// The hint is 1 iff `v0 != 0` AND `v0 != +-gamma2`.
-///
-/// # Arguments
-/// * `v0_coeff`: The low-order coefficient (signed, centered) from `Decompose(v_k, 2*gamma2)`.
-/// * `v1_coeff`: The high-order coefficient from `Decompose(v_k, 2*gamma2)`. (Not directly used by this check).
-/// * `gamma2`: The `gamma2` parameter of the Dilithium scheme.
-///
-/// # Returns
-/// `true` (hint=1) if conditions are met, `false` (hint=0) otherwise.
+/// Returns 1 if high bits of (v0, v1) need adjustment, 0 otherwise
 pub fn make_hint_coeff(v0_coeff: i32, _v1_coeff: u32, gamma2: u32) -> bool {
-    v0_coeff != 0 && v0_coeff != (gamma2 as i32) && v0_coeff != -(gamma2 as i32)
+    let gamma2_signed = gamma2 as i32;
+    v0_coeff != 0 && v0_coeff != gamma2_signed && v0_coeff != -gamma2_signed
 }
 
-
 /// Implements `UseHint_gamma2` from FIPS 203, Algorithm 7.
-/// Corrects a high-bits coefficient `r1_coeff` using a hint bit.
-/// `r_coeff` is a coefficient of `w1_prime = A*z - c*t1`.
-///
-/// # Arguments
-/// * `hint_bit`: The hint bit (0 or 1).
-/// * `r_coeff`: A coefficient of `w1_prime`.
-/// * `gamma2`: The `gamma2` parameter.
-///
-/// # Returns
-/// The corrected high-bits coefficient `r1_coeff`.
+/// Corrects high bits r1 using hint bit
 pub fn use_hint_coeff(hint_bit: bool, r_coeff: u32, gamma2: u32) -> u32 {
-    let (r0_signed, r1) = decompose(r_coeff, 2 * gamma2);
-
-    if hint_bit { // If hint is 1
+    let (r0_signed, mut r1) = decompose(r_coeff, 2 * gamma2);
+    
+    if hint_bit {
         if r0_signed > 0 {
-            // (r1 + 1) mod (Q / (2*gamma2))
-            // Dilithium Q is 8380417. 2*gamma2 for L2/3 is (Q-1)/44.
-            // Q / (2*gamma2) is not necessarily a power of 2.
-            // The spec states r1 is in Z_{floor( (q-1) / (2*gamma2) ) + 1}
-            // This function corrects r1 to be the high bits of r0 or r0+-gamma2.
-            // If r0 > 0 and hint is 1, it means r0 was gamma2, so effectively r1 should be r1+1.
-            // If r0 < 0 and hint is 1, it means r0 was -gamma2, so effectively r1 should be r1-1.
-            // The modulo operation on r1 is implicit in the range it's sampled from/used.
-            // For now, simple addition/subtraction.
-            return r1.wrapping_add(1);
-        } else if r0_signed < 0 { // r0_signed is not 0 because make_hint would be false
-            return r1.wrapping_sub(1);
+            // r1' = (r1 + 1) mod m where m = ⌊(q-1)/(2γ2)⌋ + 1
+            // For Dilithium parameters, this wrapping is implicit
+            r1 = r1.wrapping_add(1);
+        } else if r0_signed < 0 {
+            r1 = r1.wrapping_sub(1);
         }
-        // if r0_signed == 0, hint should be 0, this branch not taken.
+        // If r0 == 0, hint should be 0, so this branch shouldn't execute
     }
+    
     r1
 }
 
-/// Checks if the infinity norm of a polynomial `p` is less than or equal to `bound`.
-/// Coefficients are treated as centered in `(-Q/2, Q/2]`.
-pub fn check_norm_poly<P: DilithiumParams>(poly: &Polynomial<DilithiumPolyModParams>, bound: u32) -> bool {
+/// Checks if the infinity norm of a polynomial is at most `bound`.
+/// Coefficients are centered in (-Q/2, Q/2]
+pub fn check_norm_poly<P: DilithiumSignParams>(
+    poly: &Polynomial<DilithiumParams>, 
+    bound: u32
+) -> bool {
+    let q_half = (DilithiumParams::Q / 2) as i32;
+    
     for &coeff in poly.coeffs.iter() {
         let mut centered_coeff = coeff as i32;
-        // Center coefficient around 0: if coeff > Q/2, then centered_coeff = coeff - Q
-        if centered_coeff > (DILITHIUM_Q / 2) as i32 {
-            centered_coeff = centered_coeff.wrapping_sub(DILITHIUM_Q as i32);
+        // Center coefficient
+        if centered_coeff > q_half {
+            centered_coeff -= DilithiumParams::Q as i32;
         }
         if centered_coeff.abs() > bound as i32 {
             return false;
@@ -150,109 +114,115 @@ pub fn check_norm_poly<P: DilithiumParams>(poly: &Polynomial<DilithiumPolyModPar
     true
 }
 
-/// Checks if the infinity norm of all polynomials in a PolyVec `pv` is less than or equal to `bound`.
-pub fn check_norm_polyvec<P: DilithiumParams, const DIM: usize>(pv: &PolyVec<P, DIM>, bound: u32) -> bool {
+/// Checks if the infinity norm of all polynomials in a PolyVecL is at most `bound`.
+pub fn check_norm_polyvec_l<P: DilithiumSignParams>(
+    pv: &PolyVecL<P>, 
+    bound: u32
+) -> bool {
+    pv.polys.iter().all(|p| check_norm_poly::<P>(p, bound))
+}
+
+/// Checks if the infinity norm of all polynomials in a PolyVecK is at most `bound`.
+pub fn check_norm_polyvec_k<P: DilithiumSignParams>(
+    pv: &PolyVecK<P>, 
+    bound: u32
+) -> bool {
     pv.polys.iter().all(|p| check_norm_poly::<P>(p, bound))
 }
 
-/// Applies `Power2Round` element-wise to a `PolyVec`.
-/// Returns two `PolyVec`s: `(pv0, pv1)`.
-pub fn power2round_polyvec<P: DilithiumParams, const DIM: usize>(
-    pv: &PolyVec<P, DIM>,
+/// Applies `Power2Round` element-wise to a PolyVecK.
+pub fn power2round_polyvec<P: DilithiumSignParams>(
+    pv: &PolyVecK<P>,
     d_param: u32,
-) -> (PolyVec<P, DIM>, PolyVec<P, DIM>) {
-    let mut pv0_signed_coeffs = PolyVec::<P, DIM>::zero(); // Temporarily store signed r0
-    let mut pv1 = PolyVec::<P, DIM>::zero();
-    for i in 0..DIM {
-        for j in 0..DILITHIUM_N {
+) -> (PolyVecK<P>, PolyVecK<P>) {
+    let mut pv0 = PolyVecK::<P>::zero();
+    let mut pv1 = PolyVecK::<P>::zero();
+    
+    for i in 0..P::K_DIM {
+        for j in 0..DilithiumParams::N {
             let (r0_signed, r1) = power2round(pv.polys[i].coeffs[j], d_param);
-            // Store r0_signed as positive representative in [0, Q-1] for PolyVec
-            pv0_signed_coeffs.polys[i].coeffs[j] = (r0_signed + DILITHIUM_Q as i32) as u32 % (DILITHIUM_Q as u32);
+            // Store r0 as positive representative in [0, Q-1]
+            pv0.polys[i].coeffs[j] = ((r0_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
             pv1.polys[i].coeffs[j] = r1;
         }
     }
-    (pv0_signed_coeffs, pv1)
+    
+    (pv0, pv1)
 }
 
-/// Applies `HighBits` element-wise to a `PolyVec`.
-/// `HighBits(r, alpha) = r1` where `(r0, r1) = Decompose(r, alpha)`.
-pub fn highbits_polyvec<P: DilithiumParams, const DIM: usize>(
-    pv: &PolyVec<P, DIM>,
+/// Applies `HighBits` element-wise to a PolyVecK.
+pub fn highbits_polyvec<P: DilithiumSignParams>(
+    pv: &PolyVecK<P>,
     alpha: u32,
-) -> PolyVec<P, DIM> {
-    let mut res = PolyVec::<P, DIM>::zero();
-    for i in 0..DIM {
-        for j in 0..DILITHIUM_N {
-            let (_, r1) = decompose(pv.polys[i].coeffs[j], alpha);
-            res.polys[i].coeffs[j] = r1;
+) -> PolyVecK<P> {
+    let mut res = PolyVecK::<P>::zero();
+    
+    for i in 0..P::K_DIM {
+        for j in 0..DilithiumParams::N {
+            res.polys[i].coeffs[j] = highbits(pv.polys[i].coeffs[j], alpha);
         }
     }
+    
     res
 }
 
-/// Applies `LowBits` element-wise to a `PolyVec`.
-/// `LowBits(r, alpha) = r0` where `(r0, r1) = Decompose(r, alpha)`.
-/// `r0` is returned as its representative in `[0, Q-1]`.
-pub fn lowbits_polyvec<P: DilithiumParams, const DIM: usize>(
-    pv: &PolyVec<P, DIM>,
+/// Applies `LowBits` element-wise to a PolyVecK.
+pub fn lowbits_polyvec<P: DilithiumSignParams>(
+    pv: &PolyVecK<P>,
     alpha: u32,
-) -> PolyVec<P, DIM> {
-    let mut res = PolyVec::<P, DIM>::zero();
-    for i in 0..DIM {
-        for j in 0..DILITHIUM_N {
-            let (r0_signed, _) = decompose(pv.polys[i].coeffs[j], alpha);
-            res.polys[i].coeffs[j] = (r0_signed + DILITHIUM_Q as i32) as u32 % (DILITHIUM_Q as u32);
+) -> PolyVecK<P> {
+    let mut res = PolyVecK::<P>::zero();
+    
+    for i in 0..P::K_DIM {
+        for j in 0..DilithiumParams::N {
+            let r0_signed = lowbits(pv.polys[i].coeffs[j], alpha);
+            // Store as positive representative
+            res.polys[i].coeffs[j] = ((r0_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
         }
     }
+    
     res
 }
 
-/// Applies `MakeHint` element-wise to two `PolyVecK`.
-/// `pv_v0` contains the low-bits components, `pv_v1` contains the high-bits components.
-/// This function constructs the hint vector `h`.
-///
-/// TODO: This simplified version assumes `v0` and `v1` come from the same decomposition.
-/// The actual `MakeHint` in Dilithium is more complex and depends on `(-c*t0)` and `(w - c*s2)`.
-/// The hint `h_k` is 1 if `(w - c*s2 - c*t0)_k` is not recoverable without the hint.
-/// For this skeleton, it acts as a placeholder.
-pub fn make_hint_polyveck<P: DilithiumParams>(
-    pv_v0: &PolyVecK<P>, // Represents the v0 part for hint decision
-    pv_v1: &PolyVecK<P>, // Represents the v1 part for hint decision (not directly used by make_hint_coeff)
-) -> Result<PolyVecK<P>, SignError> {
+/// Applies `MakeHint` to create hint vector h for signature compression.
+/// Takes v = w - cs2 - ct0 and creates hints for UseHint.
+pub fn make_hint_polyveck<P: DilithiumSignParams>(
+    v_polyvec: &PolyVecK<P>, // v = w - cs2 - ct0
+) -> Result<(PolyVecK<P>, usize), SignError> {
     let mut hints_pv = PolyVecK::<P>::zero();
+    let mut hint_count = 0;
+    
     for i in 0..P::K_DIM {
-        for j in 0..DILITHIUM_N {
-            let v0_c_signed = pv_v0.polys[i].coeffs[j] as i32; // Assuming it's already centered or correctly representing v0
-            let v1_c = pv_v1.polys[i].coeffs[j];
-            if make_hint_coeff(v0_c_signed, v1_c, P::GAMMA2_PARAM as u32) {
+        for j in 0..DilithiumParams::N {
+            let v_coeff = v_polyvec.polys[i].coeffs[j];
+            let (v0, v1) = decompose(v_coeff, 2 * P::GAMMA2_PARAM);
+            
+            if make_hint_coeff(v0, v1, P::GAMMA2_PARAM) {
                 hints_pv.polys[i].coeffs[j] = 1;
+                hint_count += 1;
             } else {
                 hints_pv.polys[i].coeffs[j] = 0;
             }
         }
     }
-    Ok(hints_pv)
+    
+    Ok((hints_pv, hint_count))
 }
 
-/// Applies `UseHint` element-wise to a `PolyVecK` based on a hint vector (also `PolyVecK`).
-/// `pv_r` is the vector to be corrected (e.g., `w1_prime = A*z - c*t1`).
-/// `pv_h` is the hint vector (polynomials with 0/1 coefficients).
-///
-/// TODO: The current `unpack_signature` for `h` is a placeholder.
-/// A real implementation would unpack `h` into a structure that can be easily iterated
-/// (e.g., a list of `OMEGA` indices where the hint is 1).
-/// This function assumes `pv_h` is a PolyVecK where `polys[i].coeffs[j] = 1` if hint is set.
-pub fn use_hint_polyveck_from_sig<P: DilithiumParams>(
-    pv_h_from_sig: &PolyVecK<P>, // Hint vector unpacked from signature
-    pv_r: &PolyVecK<P>,          // Polynomial vector to correct
+/// Applies `UseHint` to recover high bits using hint vector.
+pub fn use_hint_polyveck<P: DilithiumSignParams>(
+    h_polyvec: &PolyVecK<P>, // Hint vector (0/1 coefficients)
+    r_polyvec: &PolyVecK<P>, // w' = Az - ct1
 ) -> Result<PolyVecK<P>, SignError> {
     let mut corrected_pv = PolyVecK::<P>::zero();
+    
     for i in 0..P::K_DIM {
-        for j in 0..DILITHIUM_N {
-            let hint_bit = pv_h_from_sig.polys[i].coeffs[j] == 1;
-            let r_coeff = pv_r.polys[i].coeffs[j];
-            corrected_pv.polys[i].coeffs[j] = use_hint_coeff(hint_bit, r_coeff, P::GAMMA2_PARAM as u32);
+        for j in 0..DilithiumParams::N {
+            let hint_bit = h_polyvec.polys[i].coeffs[j] == 1;
+            let r_coeff = r_polyvec.polys[i].coeffs[j];
+            corrected_pv.polys[i].coeffs[j] = use_hint_coeff(hint_bit, r_coeff, P::GAMMA2_PARAM);
         }
     }
+    
     Ok(corrected_pv)
 }
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/encoding.rs b/crates/sign/src/pq/dilithium/encoding.rs
index 4741749..1364977 100644
--- a/crates/sign/src/pq/dilithium/encoding.rs
+++ b/crates/sign/src/pq/dilithium/encoding.rs
@@ -1,348 +1,390 @@
-// File: crates/sign/src/pq/dilithium/encoding.rs
-//! Serialization (packing) and deserialization (unpacking) functions for Dilithium
-//! public keys, secret keys, and signatures, according to FIPS 203 specifications.
+//! Serialization and deserialization functions for Dilithium per FIPS 203.
 
-use super::polyvec::{DilithiumPolyModParams, PolyVec, PolyVecL, PolyVecK};
-use algorithms::poly::polynomial::Polynomial;
-// Assuming DefaultCoefficientSerde is for generic bit packing
+use super::polyvec::{PolyVecL, PolyVecK};
 use algorithms::poly::serialize::{CoefficientPacker, CoefficientUnpacker, DefaultCoefficientSerde};
-use params::pqc::dilithium::{DilithiumParams, DILITHIUM_N, DILITHIUM_Q};
-use crate::error::{Error as SignError, Result as SignResult};
+use params::pqc::dilithium::{DilithiumParams as DilithiumSignParams, DILITHIUM_N, DILITHIUM_Q};
+use crate::error::{Error as SignError};
 
-// Constants for byte lengths of seeds, etc., matching Dilithium specification.
-// These should align with P::SEED_RHO_BYTES, P::SEED_KEY_BYTES etc. from DilithiumParams
-const SEED_RHO_BYTES_CONST: usize = 32;
-const SEED_K_BYTES_CONST: usize = 32; // Seed K for y and PRF in challenge
-const HASH_TR_BYTES_CONST: usize = 32; // Output of H(pk) for tr
-const SEED_C_TILDE_BYTES_CONST: usize = 32;
-
-
-/// Packs the public key `(rho, t1)` into a byte vector.
-/// `rho`: `P::SEED_RHO_BYTES` (typically 32 bytes).
-/// `t1`: `PolyVecK<P>`, each coefficient packed into `P::D_PARAM` bits.
-/// Total size should match `P::PUBLIC_KEY_BYTES`.
-pub fn pack_public_key<P: DilithiumParams>(
-    rho_seed: &[u8; P::SEED_RHO_BYTES],
+/// Packs public key (ρ, t1) according to Algorithm 13.
+pub fn pack_public_key<P: DilithiumSignParams>(
+    rho_seed: &[u8; 32], // SEED_RHO_BYTES is always 32
     t1_vec: &PolyVecK<P>,
 ) -> Result<Vec<u8>, SignError> {
-    // TODO: Implement packing of t1. Each polynomial in t1_vec has its coefficients
-    // (which are in [0, 2^(Q_BITS - D_PARAM) - 1]) packed into P::D_PARAM bits.
-    // The `algorithms::poly::serialize::DefaultCoefficientSerde::pack_coeffs` can be used.
-    // Ensure total output length matches P::PUBLIC_KEY_BYTES.
     let mut pk_bytes = Vec::with_capacity(P::PUBLIC_KEY_BYTES);
+    
+    // Pack ρ
     pk_bytes.extend_from_slice(rho_seed);
-
+    
+    // Pack t1 (each coefficient uses 10 bits for all parameter sets)
     for i in 0..P::K_DIM {
-        let poly_t1_i = &t1_vec.polys[i];
-        // Coefficients of t1 are in [0, 2^(Q_BITS - D_PARAM) - 1], so they inherently fit in D_PARAM bits if D_PARAM is chosen correctly.
-        // No further mapping to a smaller range is needed before packing, just ensure they are < 2^D_PARAM.
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(poly_t1_i, P::D_PARAM as usize)
+        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&t1_vec.polys[i], 10)
             .map_err(SignError::from_algo)?;
         pk_bytes.extend_from_slice(&packed_poly);
     }
-
+    
     if pk_bytes.len() != P::PUBLIC_KEY_BYTES {
-        return Err(SignError::Serialization(format!("Public key packing length mismatch. Expected {}, got {}", P::PUBLIC_KEY_BYTES, pk_bytes.len())));
+        return Err(SignError::Serialization(format!(
+            "Public key size mismatch: expected {}, got {}", 
+            P::PUBLIC_KEY_BYTES, pk_bytes.len()
+        )));
     }
+    
     Ok(pk_bytes)
 }
 
-/// Unpacks a public key from bytes into `(rho, t1)`.
-pub fn unpack_public_key<P: DilithiumParams>(
+/// Unpacks public key from bytes according to Algorithm 14.
+pub fn unpack_public_key<P: DilithiumSignParams>(
     pk_bytes: &[u8],
-) -> Result<([u8; P::SEED_RHO_BYTES], PolyVecK<P>), SignError> {
+) -> Result<([u8; 32], PolyVecK<P>), SignError> {
     if pk_bytes.len() != P::PUBLIC_KEY_BYTES {
-        return Err(SignError::Deserialization(format!("Public key unpacking length mismatch. Expected {}, got {}", P::PUBLIC_KEY_BYTES, pk_bytes.len())));
+        return Err(SignError::Deserialization(format!(
+            "Public key size mismatch: expected {}, got {}", 
+            P::PUBLIC_KEY_BYTES, pk_bytes.len()
+        )));
     }
-    let mut rho_seed = [0u8; P::SEED_RHO_BYTES];
-    rho_seed.copy_from_slice(&pk_bytes[0..P::SEED_RHO_BYTES]);
-
+    
+    // Unpack ρ
+    let mut rho_seed = [0u8; 32];
+    rho_seed.copy_from_slice(&pk_bytes[0..32]);
+    
+    // Unpack t1
     let mut t1_vec = PolyVecK::<P>::zero();
-    let mut current_pos = P::SEED_RHO_BYTES;
-    let bytes_per_poly_t1 = (DILITHIUM_N * P::D_PARAM as usize + 7) / 8;
-
+    let mut offset = P::SEED_RHO_BYTES;
+    let bytes_per_poly = DILITHIUM_N * 10 / 8; // 320 bytes
+    
     for i in 0..P::K_DIM {
-        if current_pos + bytes_per_poly_t1 > pk_bytes.len() {
-            return Err(SignError::Deserialization("Insufficient bytes for t1 unpacking".into()));
-        }
-        let poly_bytes = &pk_bytes[current_pos .. current_pos + bytes_per_poly_t1];
-        t1_vec.polys[i] = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, P::D_PARAM as usize)
+        let poly_bytes = &pk_bytes[offset..offset + bytes_per_poly];
+        t1_vec.polys[i] = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, 10)
             .map_err(SignError::from_algo)?;
-        current_pos += bytes_per_poly_t1;
+        offset += bytes_per_poly;
     }
+    
     Ok((rho_seed, t1_vec))
 }
 
-/// Packs the secret key `(rho, K, tr, s1, s2, t0)` into a byte vector.
-/// `rho`, `K`, `tr` are byte strings.
-/// `s1`, `s2`: `PolyVecL/K`, coefficients packed to `P::ETA_S1S2` bits (signed, so map to positive first).
-/// `t0`: `PolyVecK`, coefficients in `(-2^(D-1), 2^(D-1)]`, packed to `P::D_PARAM` bits.
-/// Total size should match `P::SECRET_KEY_BYTES`.
-pub fn pack_secret_key<P: DilithiumParams>(
-    rho_seed: &[u8; P::SEED_RHO_BYTES],
-    k_seed: &[u8; P::SEED_KEY_BYTES], // SEED_K_ZETA_BYTES previously
-    tr_hash: &[u8; HASH_TR_BYTES_CONST],
+/// Packs secret key (ρ, K, tr, s1, s2, t0) according to Algorithm 15.
+pub fn pack_secret_key<P: DilithiumSignParams>(
+    rho_seed: &[u8; 32],    // SEED_RHO_BYTES is always 32
+    k_seed: &[u8; 32],      // SEED_KEY_BYTES is always 32
+    tr_hash: &[u8; 32],     // HASH_TR_BYTES is always 32
     s1_vec: &PolyVecL<P>,
     s2_vec: &PolyVecK<P>,
-    t0_vec: &PolyVecK<P>, // t0 contains signed coefficients
+    t0_vec: &PolyVecK<P>,
 ) -> Result<Vec<u8>, SignError> {
-    // TODO: Implement packing for s1, s2, t0 based on their specific bit-widths and signedness.
-    // - s1, s2 coefficients are in [-eta, eta]. Map to [0, 2*eta] then pack ETA_S1S2 bits.
-    // - t0 coefficients are in (-2^(D-1), 2^(D-1)]. Map to [0, 2^D-1] then pack D_PARAM bits.
-    // Ensure total output length matches P::SECRET_KEY_BYTES.
     let mut sk_bytes = Vec::with_capacity(P::SECRET_KEY_BYTES);
+    
+    // Pack ρ, K, tr
     sk_bytes.extend_from_slice(rho_seed);
     sk_bytes.extend_from_slice(k_seed);
     sk_bytes.extend_from_slice(tr_hash);
-
-    // Packing s1 (coeffs in [-ETA_S1S2, ETA_S1S2])
-    let eta_s1s2 = P::ETA_S1S2 as i32;
-    let bits_s1s2 = (2 * eta_s1s2 + 1).next_power_of_two().trailing_zeros() as usize; // smallest #bits to hold 2*eta+1 values
-    for poly_s1_i in s1_vec.polys.iter() {
-        let mut temp_poly = poly_s1_i.clone();
+    
+    // Calculate bits needed for s1, s2 encoding
+    let eta_bits = if P::ETA_S1S2 == 2 { 3 } else { 4 }; // η=2 needs 3 bits, η=4 needs 4 bits
+    
+    // Pack s1 (coefficients in [-η, η])
+    for i in 0..P::L_DIM {
+        let mut temp_poly = s1_vec.polys[i].clone();
+        // Map from [-η, η] to [0, 2η]
         for c in temp_poly.coeffs.iter_mut() {
-            let mut centered_c = *c as i32;
-            if centered_c > DILITHIUM_Q as i32 / 2 { centered_c -= DILITHIUM_Q as i32; } // to [-Q/2, Q/2]
-            *c = (centered_c + eta_s1s2) as u32; // map to [0, 2*eta]
+            let centered = (*c as i32).rem_euclid(DILITHIUM_Q as i32);
+            let adjusted = if centered > (DILITHIUM_Q / 2) as i32 {
+                centered - DILITHIUM_Q as i32
+            } else {
+                centered
+            };
+            *c = (adjusted + P::ETA_S1S2 as i32) as u32;
         }
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&temp_poly, bits_s1s2)
+        let packed = DefaultCoefficientSerde::pack_coeffs(&temp_poly, eta_bits)
             .map_err(SignError::from_algo)?;
-        sk_bytes.extend_from_slice(&packed_poly);
+        sk_bytes.extend_from_slice(&packed);
     }
-    // Packing s2 (coeffs in [-ETA_S1S2, ETA_S1S2])
-    for poly_s2_i in s2_vec.polys.iter() {
-        let mut temp_poly = poly_s2_i.clone();
+    
+    // Pack s2 (same as s1)
+    for i in 0..P::K_DIM {
+        let mut temp_poly = s2_vec.polys[i].clone();
         for c in temp_poly.coeffs.iter_mut() {
-            let mut centered_c = *c as i32;
-            if centered_c > DILITHIUM_Q as i32 / 2 { centered_c -= DILITHIUM_Q as i32; }
-            *c = (centered_c + eta_s1s2) as u32;
+            let centered = (*c as i32).rem_euclid(DILITHIUM_Q as i32);
+            let adjusted = if centered > (DILITHIUM_Q / 2) as i32 {
+                centered - DILITHIUM_Q as i32
+            } else {
+                centered
+            };
+            *c = (adjusted + P::ETA_S1S2 as i32) as u32;
         }
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&temp_poly, bits_s1s2)
+        let packed = DefaultCoefficientSerde::pack_coeffs(&temp_poly, eta_bits)
             .map_err(SignError::from_algo)?;
-        sk_bytes.extend_from_slice(&packed_poly);
+        sk_bytes.extend_from_slice(&packed);
     }
     
-    // Packing t0 (coeffs in (-2^(D-1), 2^(D-1)])
-    let d_val = P::D_PARAM as i32;
-    let t0_offset = 1 << (d_val - 1); // 2^(D-1)
-    for poly_t0_i in t0_vec.polys.iter() {
-        let mut temp_poly = poly_t0_i.clone();
+    // Pack t0 (coefficients in (-2^(d-1), 2^(d-1)])
+    let t0_offset = 1 << (P::D_PARAM - 1);
+    for i in 0..P::K_DIM {
+        let mut temp_poly = t0_vec.polys[i].clone();
         for c in temp_poly.coeffs.iter_mut() {
-            let mut centered_c = *c as i32;
-            if centered_c > DILITHIUM_Q as i32 / 2 { centered_c -= DILITHIUM_Q as i32; }
-            // Map coeff from (-2^(D-1), 2^(D-1)] to [0, 2^D-1] approximately for packing
-            // Exact packing scheme for t0 needs to be precise. This is a placeholder.
-            *c = (centered_c + t0_offset) as u32; // Example: map to roughly positive range
+            let centered = (*c as i32).rem_euclid(DILITHIUM_Q as i32);
+            let adjusted = if centered > (DILITHIUM_Q / 2) as i32 {
+                centered - DILITHIUM_Q as i32
+            } else {
+                centered
+            };
+            *c = (adjusted + t0_offset) as u32;
         }
-        // Pack into D_PARAM bits
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&temp_poly, P::D_PARAM as usize)
+        let packed = DefaultCoefficientSerde::pack_coeffs(&temp_poly, P::D_PARAM as usize)
             .map_err(SignError::from_algo)?;
-        sk_bytes.extend_from_slice(&packed_poly);
+        sk_bytes.extend_from_slice(&packed);
     }
-
+    
     if sk_bytes.len() != P::SECRET_KEY_BYTES {
-         return Err(SignError::Serialization(format!("Secret key packing length mismatch. Expected {}, got {}", P::SECRET_KEY_BYTES, sk_bytes.len())));
+        return Err(SignError::Serialization(format!(
+            "Secret key size mismatch: expected {}, got {}", 
+            P::SECRET_KEY_BYTES, sk_bytes.len()
+        )));
     }
+    
     Ok(sk_bytes)
 }
 
-/// Unpacks a secret key from bytes into its components.
-pub fn unpack_secret_key<P: DilithiumParams>(
+/// Unpacks secret key from bytes according to Algorithm 16.
+pub fn unpack_secret_key<P: DilithiumSignParams>(
     sk_bytes: &[u8],
 ) -> Result<(
-    [u8; P::SEED_RHO_BYTES],
-    [u8; P::SEED_KEY_BYTES],
-    [u8; HASH_TR_BYTES_CONST],
+    [u8; 32], // rho
+    [u8; 32], // k
+    [u8; 32], // tr
     PolyVecL<P>,
     PolyVecK<P>,
-    PolyVecK<P>, // t0_vec
+    PolyVecK<P>,
 ), SignError> {
-    // TODO: Implement unpacking. Inverse of pack_secret_key.
-    // Ensure lengths and offsets are precise based on P's parameters for ETA_S1S2 and D_PARAM packing.
     if sk_bytes.len() != P::SECRET_KEY_BYTES {
-        return Err(SignError::Deserialization(format!("Secret key unpacking length mismatch. Expected {}, got {}", P::SECRET_KEY_BYTES, sk_bytes.len())));
+        return Err(SignError::Deserialization(format!(
+            "Secret key size mismatch: expected {}, got {}", 
+            P::SECRET_KEY_BYTES, sk_bytes.len()
+        )));
     }
-    let mut rho_seed = [0u8; P::SEED_RHO_BYTES];
-    let mut k_seed = [0u8; P::SEED_KEY_BYTES];
-    let mut tr_hash = [0u8; HASH_TR_BYTES_CONST];
-    
-    let mut current_pos = 0;
-    rho_seed.copy_from_slice(&sk_bytes[current_pos .. current_pos + P::SEED_RHO_BYTES]);
-    current_pos += P::SEED_RHO_BYTES;
-    k_seed.copy_from_slice(&sk_bytes[current_pos .. current_pos + P::SEED_KEY_BYTES]);
-    current_pos += P::SEED_KEY_BYTES;
-    tr_hash.copy_from_slice(&sk_bytes[current_pos .. current_pos + HASH_TR_BYTES_CONST]);
-    current_pos += HASH_TR_BYTES_CONST;
-
-    let eta_s1s2 = P::ETA_S1S2 as i32;
-    let bits_s1s2 = (2 * eta_s1s2 + 1).next_power_of_two().trailing_zeros() as usize;
-    let bytes_per_poly_s1s2 = (DILITHIUM_N * bits_s1s2 + 7) / 8;
     
+    let mut offset = 0;
+    
+    // Unpack ρ, K, tr
+    let mut rho_seed = [0u8; 32];
+    rho_seed.copy_from_slice(&sk_bytes[offset..offset + 32]);
+    offset += 32;
+    
+    let mut k_seed = [0u8; 32];
+    k_seed.copy_from_slice(&sk_bytes[offset..offset + 32]);
+    offset += 32;
+    
+    let mut tr_hash = [0u8; 32];
+    tr_hash.copy_from_slice(&sk_bytes[offset..offset + 32]);
+    offset += 32;
+    
+    // Calculate sizes
+    let eta_bits = if P::ETA_S1S2 == 2 { 3 } else { 4 };
+    let bytes_per_s_poly = DILITHIUM_N * eta_bits / 8;
+    let bytes_per_t0_poly = DILITHIUM_N * P::D_PARAM as usize / 8;
+    
+    // Unpack s1
     let mut s1_vec = PolyVecL::<P>::zero();
     for i in 0..P::L_DIM {
-        let poly_bytes = &sk_bytes[current_pos .. current_pos + bytes_per_poly_s1s2];
-        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, bits_s1s2)
+        let poly_bytes = &sk_bytes[offset..offset + bytes_per_s_poly];
+        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, eta_bits)
             .map_err(SignError::from_algo)?;
-        for c in temp_poly.coeffs.iter_mut() { *c = (*c as i32 - eta_s1s2) as u32 % (DILITHIUM_Q as u32); } // Map back
+        // Map back from [0, 2η] to [-η, η]
+        for c in temp_poly.coeffs.iter_mut() {
+            let val = (*c as i32) - P::ETA_S1S2 as i32;
+            *c = ((val + DILITHIUM_Q as i32) % DILITHIUM_Q as i32) as u32;
+        }
         s1_vec.polys[i] = temp_poly;
-        current_pos += bytes_per_poly_s1s2;
+        offset += bytes_per_s_poly;
     }
-
+    
+    // Unpack s2
     let mut s2_vec = PolyVecK::<P>::zero();
     for i in 0..P::K_DIM {
-        let poly_bytes = &sk_bytes[current_pos .. current_pos + bytes_per_poly_s1s2];
-        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, bits_s1s2)
+        let poly_bytes = &sk_bytes[offset..offset + bytes_per_s_poly];
+        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, eta_bits)
             .map_err(SignError::from_algo)?;
-        for c in temp_poly.coeffs.iter_mut() { *c = (*c as i32 - eta_s1s2) as u32 % (DILITHIUM_Q as u32); } // Map back
+        for c in temp_poly.coeffs.iter_mut() {
+            let val = (*c as i32) - P::ETA_S1S2 as i32;
+            *c = ((val + DILITHIUM_Q as i32) % DILITHIUM_Q as i32) as u32;
+        }
         s2_vec.polys[i] = temp_poly;
-        current_pos += bytes_per_poly_s1s2;
+        offset += bytes_per_s_poly;
     }
     
+    // Unpack t0
     let mut t0_vec = PolyVecK::<P>::zero();
-    let d_val = P::D_PARAM as i32;
-    let t0_offset = 1 << (d_val - 1);
-    let bytes_per_poly_t0 = (DILITHIUM_N * P::D_PARAM as usize + 7) / 8;
+    let t0_offset = 1 << (P::D_PARAM - 1);
     for i in 0..P::K_DIM {
-        let poly_bytes = &sk_bytes[current_pos .. current_pos + bytes_per_poly_t0];
+        let poly_bytes = &sk_bytes[offset..offset + bytes_per_t0_poly];
         let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, P::D_PARAM as usize)
             .map_err(SignError::from_algo)?;
-        for c in temp_poly.coeffs.iter_mut() { *c = (*c as i32 - t0_offset) as u32 % (DILITHIUM_Q as u32); } // Map back
+        for c in temp_poly.coeffs.iter_mut() {
+            let val = (*c as i32) - t0_offset;
+            *c = ((val + DILITHIUM_Q as i32) % DILITHIUM_Q as i32) as u32;
+        }
         t0_vec.polys[i] = temp_poly;
-        current_pos += bytes_per_poly_t0;
+        offset += bytes_per_t0_poly;
     }
-
+    
     Ok((rho_seed, k_seed, tr_hash, s1_vec, s2_vec, t0_vec))
 }
 
-
-/// Packs the signature `(c_tilde_seed, z_vec, h_packed_indices)` into a byte vector.
-/// `c_tilde_seed`: `SEED_C_TILDE_BYTES_CONST` (32 bytes).
-/// `z_vec`: `PolyVecL<P>`, coefficients packed to `bits_for_z`.
-/// `h_packed_indices`: `PolyVecK<P>` representing hints, packed efficiently.
-/// Total size should match `P::SIGNATURE_SIZE`.
-pub fn pack_signature<P: DilithiumParams>(
-    c_tilde_seed: &[u8; SEED_C_TILDE_BYTES_CONST],
+/// Packs signature (c̃, z, h) according to Algorithm 17.
+pub fn pack_signature<P: DilithiumSignParams>(
+    c_tilde_seed: &[u8; 32], // SEED_C_TILDE_BYTES is always 32
     z_vec: &PolyVecL<P>,
-    h_hint_poly: &PolyVecK<P>, // PolyVecK where each coeff is 0 or 1 (hint bit)
+    h_hint_poly: &PolyVecK<P>,
 ) -> Result<Vec<u8>, SignError> {
-    // TODO: Implement signature packing per FIPS 203 Appendix A.3.
-    // - c_tilde_seed is copied directly.
-    // - z_vec: coefficients are in [-gamma1+beta, gamma1-beta]. Map to [0, 2*(gamma1-beta)] then pack.
-    //   The number of bits `bits_for_z = ceil(log2(2*(gamma1-beta)+1))`.
-    // - h_hint_poly: This needs to be packed as a list of OMEGA indices where hint is 1.
-    //   This is complex. For the skeleton, we'll just pack it as if it's dense for placeholder.
     let mut sig_bytes = Vec::with_capacity(P::SIGNATURE_SIZE);
+    
+    // Pack c̃
     sig_bytes.extend_from_slice(c_tilde_seed);
-
-    let bits_for_z = P::GAMMA1_BITS; // From DilithiumParams: ceil(log2(2*gamma1 - 2*beta + 1))
-    for poly_z_i in z_vec.polys.iter() {
-        let mut temp_poly_z = poly_z_i.clone();
-        for c in temp_poly_z.coeffs.iter_mut() {
-            let mut centered_c = *c as i32;
-            if centered_c > DILITHIUM_Q as i32 / 2 { centered_c -= DILITHIUM_Q as i32; }
-            // Map from [-gamma1+beta, gamma1-beta] to [0, 2*(gamma1-beta)]
-            *c = (centered_c + (P::GAMMA1_PARAM - P::BETA_PARAM) as i32) as u32;
+    
+    // Pack z (coefficients in [-γ1+β, γ1-β])
+    for i in 0..P::L_DIM {
+        let mut temp_poly = z_vec.polys[i].clone();
+        for c in temp_poly.coeffs.iter_mut() {
+            let centered = (*c as i32).rem_euclid(DILITHIUM_Q as i32);
+            let adjusted = if centered > (DILITHIUM_Q / 2) as i32 {
+                centered - DILITHIUM_Q as i32
+            } else {
+                centered
+            };
+            // Map to [0, 2(γ1-β)]
+            *c = (adjusted + (P::GAMMA1_PARAM - P::BETA_PARAM) as i32) as u32;
         }
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&temp_poly_z, bits_for_z as usize)
+        let packed = DefaultCoefficientSerde::pack_coeffs(&temp_poly, P::GAMMA1_BITS)
             .map_err(SignError::from_algo)?;
-        sig_bytes.extend_from_slice(&packed_poly);
+        sig_bytes.extend_from_slice(&packed);
     }
-
-    // Packing h (Placeholder: pack as dense 1-bit coefficients)
-    // Actual Dilithium packs Omega indices.
-    let packed_h_len = P::SIGNATURE_SIZE - sig_bytes.len();
-    let mut temp_h_packed_bits = Vec::new();
-    for poly_h_i in h_hint_poly.polys.iter() {
-        for &coeff_h in poly_h_i.coeffs.iter() {
-            temp_h_packed_bits.push(coeff_h == 1); // Store as bools
+    
+    // Pack h as sparse representation
+    // Collect indices where h=1
+    let mut hint_indices = Vec::new();
+    for i in 0..P::K_DIM {
+        for j in 0..DILITHIUM_N {
+            if h_hint_poly.polys[i].coeffs[j] == 1 {
+                hint_indices.push((i, j));
+            }
         }
     }
-    // Now pack these booleans into bytes
-    let mut packed_h_bytes = vec![0u8; (temp_h_packed_bits.len() + 7) / 8];
-    for (i, &bit) in temp_h_packed_bits.iter().enumerate() {
-        if bit {
-            packed_h_bytes[i/8] |= 1 << (i%8);
+    
+    // Encode indices (simplified encoding - in practice uses more efficient packing)
+    // For each hint: encode poly index (log2(K) bits) and coeff index (8 bits)
+    let poly_bits = (P::K_DIM as f32).log2().ceil() as usize;
+    let total_hint_bits = hint_indices.len() * (poly_bits + 8);
+    let hint_bytes = (total_hint_bits + 7) / 8;
+    
+    let mut hint_packed = vec![0u8; hint_bytes];
+    let mut bit_pos = 0;
+    
+    for (poly_idx, coeff_idx) in hint_indices {
+        // Pack polynomial index
+        for b in 0..poly_bits {
+            if (poly_idx >> b) & 1 == 1 {
+                hint_packed[bit_pos / 8] |= 1 << (bit_pos % 8);
+            }
+            bit_pos += 1;
+        }
+        // Pack coefficient index (8 bits)
+        for b in 0..8 {
+            if (coeff_idx >> b) & 1 == 1 {
+                hint_packed[bit_pos / 8] |= 1 << (bit_pos % 8);
+            }
+            bit_pos += 1;
         }
     }
-    // Ensure packed_h_bytes is exactly packed_h_len, pad or truncate if necessary
-    // This placeholder is not correct for Dilithium's sparse hint packing.
-    if packed_h_bytes.len() >= packed_h_len {
-        sig_bytes.extend_from_slice(&packed_h_bytes[..packed_h_len]);
-    } else {
-        sig_bytes.extend_from_slice(&packed_h_bytes);
-        sig_bytes.resize(P::SIGNATURE_SIZE, 0u8); // Pad if too short
-    }
-
-
-    if sig_bytes.len() != P::SIGNATURE_SIZE {
-        return Err(SignError::Serialization(format!("Signature packing length mismatch. Expected {}, got {}", P::SIGNATURE_SIZE, sig_bytes.len())));
-    }
+    
+    // Pad to signature size
+    sig_bytes.extend_from_slice(&hint_packed);
+    sig_bytes.resize(P::SIGNATURE_SIZE, 0);
+    
     Ok(sig_bytes)
 }
 
-/// Unpacks a signature from bytes into `(c_tilde_seed, z_vec, h_hint_poly)`.
-pub fn unpack_signature<P: DilithiumParams>(
+/// Unpacks signature from bytes according to Algorithm 18.
+pub fn unpack_signature<P: DilithiumSignParams>(
     sig_bytes: &[u8],
-) -> Result<([u8; SEED_C_TILDE_BYTES_CONST], PolyVecL<P>, PolyVecK<P>), SignError> {
-    // TODO: Implement signature unpacking per FIPS 203 Appendix A.3.
-    // Inverse of pack_signature. Unpack c_tilde_seed, z_vec, and the OMEGA hint indices.
+) -> Result<([u8; 32], PolyVecL<P>, PolyVecK<P>), SignError> {
     if sig_bytes.len() != P::SIGNATURE_SIZE {
-        return Err(SignError::Deserialization(format!("Signature unpacking length mismatch. Expected {}, got {}", P::SIGNATURE_SIZE, sig_bytes.len())));
+        return Err(SignError::Deserialization(format!(
+            "Signature size mismatch: expected {}, got {}", 
+            P::SIGNATURE_SIZE, sig_bytes.len()
+        )));
     }
-    let mut c_tilde_seed = [0u8; SEED_C_TILDE_BYTES_CONST];
-    c_tilde_seed.copy_from_slice(&sig_bytes[0..SEED_C_TILDE_BYTES_CONST]);
-    let mut current_pos = SEED_C_TILDE_BYTES_CONST;
-
+    
+    let mut offset = 0;
+    
+    // Unpack c̃
+    let mut c_tilde_seed = [0u8; 32];
+    c_tilde_seed.copy_from_slice(&sig_bytes[offset..offset + 32]);
+    offset += 32;
+    
+    // Unpack z
     let mut z_vec = PolyVecL::<P>::zero();
-    let bits_for_z = P::GAMMA1_BITS;
-    let bytes_per_poly_z = (DILITHIUM_N * bits_for_z as usize + 7) / 8;
+    let bytes_per_z_poly = DILITHIUM_N * P::GAMMA1_BITS / 8;
+    
     for i in 0..P::L_DIM {
-        let poly_bytes = &sig_bytes[current_pos .. current_pos + bytes_per_poly_z];
-        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, bits_for_z as usize)
+        let poly_bytes = &sig_bytes[offset..offset + bytes_per_z_poly];
+        let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, P::GAMMA1_BITS)
             .map_err(SignError::from_algo)?;
+        // Map back from [0, 2(γ1-β)] to [-γ1+β, γ1-β]
         for c in temp_poly.coeffs.iter_mut() {
-            // Map from [0, 2*(gamma1-beta)] back to [-gamma1+beta, gamma1-beta]
-            // Then map to [0, Q-1]
-            let mapped_val = *c as i32 - (P::GAMMA1_PARAM - P::BETA_PARAM) as i32;
-            *c = (mapped_val + DILITHIUM_Q as i32) as u32 % (DILITHIUM_Q as u32);
+            let val = (*c as i32) - (P::GAMMA1_PARAM - P::BETA_PARAM) as i32;
+            *c = ((val + DILITHIUM_Q as i32) % DILITHIUM_Q as i32) as u32;
         }
         z_vec.polys[i] = temp_poly;
-        current_pos += bytes_per_poly_z;
+        offset += bytes_per_z_poly;
     }
-
-    // Unpacking h_hint_poly (Placeholder: unpack as dense 1-bit coefficients)
-    // Actual Dilithium unpacks OMEGA indices and reconstructs h.
+    
+    // Unpack h (simplified - real implementation needs proper sparse unpacking)
     let mut h_hint_poly = PolyVecK::<P>::zero();
-    let packed_h_bytes = &sig_bytes[current_pos..];
-    let mut bit_idx = 0;
-    'outer: for i in 0..P::K_DIM {
-        for j in 0..DILITHIUM_N {
-            if bit_idx / 8 >= packed_h_bytes.len() { break 'outer; }
-            if (packed_h_bytes[bit_idx / 8] >> (bit_idx % 8)) & 1 == 1 {
-                h_hint_poly.polys[i].coeffs[j] = 1;
+    let hint_bytes = &sig_bytes[offset..];
+    
+    // Parse hint indices
+    let poly_bits = (P::K_DIM as f32).log2().ceil() as usize;
+    let mut bit_pos = 0;
+    let mut hints_read = 0;
+    
+    while hints_read < P::OMEGA_PARAM as usize && bit_pos + poly_bits + 8 <= hint_bytes.len() * 8 {
+        // Read polynomial index
+        let mut poly_idx = 0;
+        for b in 0..poly_bits {
+            if (hint_bytes[bit_pos / 8] >> (bit_pos % 8)) & 1 == 1 {
+                poly_idx |= 1 << b;
+            }
+            bit_pos += 1;
+        }
+        
+        // Read coefficient index
+        let mut coeff_idx = 0;
+        for b in 0..8 {
+            if (hint_bytes[bit_pos / 8] >> (bit_pos % 8)) & 1 == 1 {
+                coeff_idx |= 1 << b;
             }
-            bit_idx += 1;
+            bit_pos += 1;
+        }
+        
+        if poly_idx < P::K_DIM && coeff_idx < DILITHIUM_N {
+            h_hint_poly.polys[poly_idx].coeffs[coeff_idx] = 1;
+            hints_read += 1;
         }
     }
     
     Ok((c_tilde_seed, z_vec, h_hint_poly))
 }
 
-/// Packs PolyVecK `w1` into bytes. Coefficients are in `[0, 2*gamma2-1]`.
-/// Each coefficient is packed into `ceil(log2(2*gamma2))` bits.
-pub fn pack_polyveck_w1<P: DilithiumParams>(w1_vec: &PolyVecK<P>) -> Result<Vec<u8>, SignError> {
-    // TODO: Implement packing for w1 for H_chal(mu || pack(w1)).
-    // The size of w1_packed is (k * POLYW1_PACKED_BYTES)
-    // POLYW1_PACKED_BYTES = N * bits_for_w1_coeff / 8
-    // bits_for_w1_coeff = ceil(log2(2*gamma2))
-    // For Dilithium2, gamma2 = (Q-1)/88. 2*gamma2 approx Q/44. log2(Q/44) approx 23-5.4 = 17.6. So 18 bits.
-    // This implies P must define a specific bitwidth for w1 elements.
-    // Let's assume P::W1_BITS.
-    let mut w1_packed_bytes = Vec::new();
-    for poly_w1_i in w1_vec.polys.iter() {
-        let packed_poly = DefaultCoefficientSerde::pack_coeffs(poly_w1_i, P::W1_BITS as usize)
+/// Packs w1 for computing challenge hash.
+pub fn pack_polyveck_w1<P: DilithiumSignParams>(
+    w1_vec: &PolyVecK<P>,
+) -> Result<Vec<u8>, SignError> {
+    let mut packed = Vec::new();
+    
+    for i in 0..P::K_DIM {
+        let packed_poly = DefaultCoefficientSerde::pack_coeffs(&w1_vec.polys[i], P::W1_BITS)
             .map_err(SignError::from_algo)?;
-        w1_packed_bytes.extend_from_slice(&packed_poly);
+        packed.extend_from_slice(&packed_poly);
     }
-    Ok(w1_packed_bytes)
+    
+    Ok(packed)
 }
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/mod.rs b/crates/sign/src/pq/dilithium/mod.rs
index 2cd1867..57523e5 100644
--- a/crates/sign/src/pq/dilithium/mod.rs
+++ b/crates/sign/src/pq/dilithium/mod.rs
@@ -30,11 +30,11 @@ use rand::{CryptoRng, RngCore};
 use core::marker::PhantomData;
 
 // Internal modules for Dilithium logic
-mod polyvec;       pub(crate) use polyvec::*;
-mod arithmetic;    pub(crate) use arithmetic::*;
-mod sampling;      pub(crate) use sampling::*;
-mod encoding;      pub(crate) use encoding::*;
-mod sign;          pub(crate) use sign::*;
+mod polyvec;       
+mod arithmetic;    
+mod sampling;      
+mod encoding;      
+mod sign;          
 
 // Re-export from params crate for easy access to DilithiumNParams structs.
 // These structs from `dcrypt-params` hold the specific numerical parameters (K, L, eta, gamma1, etc.)
@@ -107,7 +107,8 @@ impl<P: DilithiumParams + Send + Sync + 'static> SignatureTrait for Dilithium<P>
     fn name() -> &'static str { P::NAME }
 
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
-        let (pk_bytes, sk_bytes) = sign::keypair_internal::<P, R>(rng)?;
+        let (pk_bytes, sk_bytes) = sign::keypair_internal::<P, R>(rng)
+            .map_err(|e| api::Error::from(e))?;
         Ok((DilithiumPublicKey(pk_bytes), DilithiumSecretKey(sk_bytes)))
     }
 
@@ -124,12 +125,14 @@ impl<P: DilithiumParams + Send + Sync + 'static> SignatureTrait for Dilithium<P>
         // For this API, we'll use a thread_rng for any potential non-spec randomization points
         // or if a future variant required it, but standard Dilithium does not.
         let mut rng = rand::rngs::OsRng;
-        let sig_bytes = sign::sign_internal::<P, _>(message, &secret_key.0, &mut rng)?;
+        let sig_bytes = sign::sign_internal::<P, _>(message, &secret_key.0, &mut rng)
+            .map_err(|e| api::Error::from(e))?;
         Ok(DilithiumSignatureData(sig_bytes))
     }
 
     fn verify(message: &[u8], signature: &Self::SignatureData, public_key: &Self::PublicKey) -> ApiResult<()> {
         sign::verify_internal::<P>(message, &signature.0, &public_key.0)
+            .map_err(|e| api::Error::from(e))
     }
 }
 
@@ -139,15 +142,5 @@ pub type Dilithium2 = Dilithium<Dilithium2Params>;
 pub type Dilithium3 = Dilithium<Dilithium3Params>;
 pub type Dilithium5 = Dilithium<Dilithium5Params>;
 
-// Temporary compatibility re-exports (deprecated)
-#[deprecated(note = "use dilithium::arithmetic")]
-pub use arithmetic as arith_helpers;
-
-#[deprecated(note = "use dilithium::polyvec")]
-pub use polyvec as poly_ops;
-
-#[deprecated(note = "use dilithium::encoding")]
-pub use encoding as packing;
-
-#[deprecated(note = "use dilithium::sign")]
-pub use sign as sign_impl;
\ No newline at end of file
+#[cfg(test)]
+mod tests;
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/polyvec.rs b/crates/sign/src/pq/dilithium/polyvec.rs
index fe27a19..9470855 100644
--- a/crates/sign/src/pq/dilithium/polyvec.rs
+++ b/crates/sign/src/pq/dilithium/polyvec.rs
@@ -1,49 +1,74 @@
-// File: crates/sign/src/pq/dilithium/polyvec.rs
 //! Polynomial vector types and operations specific to Dilithium.
-//! This module defines `PolyVecL` and `PolyVecK` which are vectors of polynomials
-//! of dimension L and K respectively, as specified by the Dilithium parameters.
-//! It also includes functions for expanding the matrix A from a seed.
 
 use algorithms::poly::polynomial::Polynomial;
-use algorithms::poly::ntt::{NttOperator, InverseNttOperator};
-// Assumes DilithiumPolyModParams is now correctly defined in algorithms::poly::params
-// and implements NttModulus with correct constants for Dilithium's Q and N.
-use algorithms::poly::params::DilithiumPolyModParams;
+use algorithms::poly::params::{DilithiumParams, Modulus, NttModulus};
 use algorithms::xof::shake::ShakeXof128;
 use algorithms::xof::ExtendableOutputFunction;
 use algorithms::error::Result as AlgoResult;
-use crate::error::{Error as SignError, Result as SignResult};
-use params::pqc::dilithium::{DilithiumParams, DILITHIUM_N, DILITHIUM_Q};
+use crate::error::{Error as SignError};
+use params::pqc::dilithium::DilithiumParams as DilithiumSignParams;
 use core::marker::PhantomData;
 use zeroize::Zeroize;
 
-/// A vector of `DIM` polynomials, parameterized by `P: DilithiumParams`.
-/// Each polynomial is an element of `R_q = Z_q[X]/(X^N+1)`.
-/// Used to represent `s1`, `y`, `z` (PolyVecL) and `s2`, `t0`, `t1`, `w0`, `w1`, `h` (PolyVecK).
-#[derive(Clone, Debug, Zeroize)]
-pub struct PolyVec<P: DilithiumParams, const DIM: usize> {
-    /// Array of polynomials.
-    pub(crate) polys: [Polynomial<DilithiumPolyModParams>; DIM],
+/// A vector of polynomials for dimension L (columns in matrix A)
+#[derive(Debug)]
+pub struct PolyVecL<P: DilithiumSignParams> {
+    pub(crate) polys: Vec<Polynomial<DilithiumParams>>,
     _params: PhantomData<P>,
 }
 
-// Type aliases for PolyVecL (dimension L) and PolyVecK (dimension K).
-// These rely on `L_DIM` and `K_DIM` being consts in the `DilithiumParams` trait.
-pub type PolyVecL<P> = PolyVec<P, {<P as DilithiumParams>::L_DIM}>;
-pub type PolyVecK<P> = PolyVec<P, {<P as DilithiumParams>::K_DIM}>;
+/// A vector of polynomials for dimension K (rows in matrix A)
+#[derive(Debug)]
+pub struct PolyVecK<P: DilithiumSignParams> {
+    pub(crate) polys: Vec<Polynomial<DilithiumParams>>,
+    _params: PhantomData<P>,
+}
+
+// Implement Clone manually to avoid trait bound issues
+impl<P: DilithiumSignParams> Clone for PolyVecL<P> {
+    fn clone(&self) -> Self {
+        Self {
+            polys: self.polys.clone(),
+            _params: PhantomData,
+        }
+    }
+}
+
+impl<P: DilithiumSignParams> Clone for PolyVecK<P> {
+    fn clone(&self) -> Self {
+        Self {
+            polys: self.polys.clone(),
+            _params: PhantomData,
+        }
+    }
+}
+
+impl<P: DilithiumSignParams> Zeroize for PolyVecL<P> {
+    fn zeroize(&mut self) {
+        for poly in self.polys.iter_mut() {
+            poly.coeffs.zeroize();
+        }
+    }
+}
 
+impl<P: DilithiumSignParams> Zeroize for PolyVecK<P> {
+    fn zeroize(&mut self) {
+        for poly in self.polys.iter_mut() {
+            poly.coeffs.zeroize();
+        }
+    }
+}
 
-impl<P: DilithiumParams, const DIM: usize> PolyVec<P, DIM> {
-    /// Creates a new PolyVec with all polynomial coefficients set to zero.
+impl<P: DilithiumSignParams> PolyVecL<P> {
+    /// Creates a new PolyVecL with all polynomial coefficients set to zero.
     pub fn zero() -> Self {
         Self {
-            polys: [(); DIM].map(|_| Polynomial::<DilithiumPolyModParams>::zero()),
+            polys: vec![Polynomial::<DilithiumParams>::zero(); P::L_DIM],
             _params: PhantomData,
         }
     }
 
     /// Applies Number Theoretic Transform (NTT) to each polynomial in the vector in-place.
-    /// Coefficients are transformed from standard to NTT representation (Montgomery form).
     pub fn ntt_inplace(&mut self) -> AlgoResult<()> {
         for p in self.polys.iter_mut() {
             p.ntt_inplace()?;
@@ -52,7 +77,6 @@ impl<P: DilithiumParams, const DIM: usize> PolyVec<P, DIM> {
     }
 
     /// Applies Inverse NTT to each polynomial in the vector in-place.
-    /// Coefficients are transformed from NTT representation (Montgomery form) to standard.
     pub fn inv_ntt_inplace(&mut self) -> AlgoResult<()> {
         for p in self.polys.iter_mut() {
             p.from_ntt_inplace()?;
@@ -61,104 +85,157 @@ impl<P: DilithiumParams, const DIM: usize> PolyVec<P, DIM> {
     }
 
     /// Adds two PolyVecs element-wise: `self + other`.
-    /// Assumes polynomials are in the same domain (either both standard or both NTT).
     pub fn add(&self, other: &Self) -> Self {
         let mut res = Self::zero();
-        for i in 0..DIM {
+        for i in 0..P::L_DIM {
             res.polys[i] = self.polys[i].add(&other.polys[i]);
         }
         res
     }
     
     /// Subtracts another PolyVec from this one element-wise: `self - other`.
-    /// Assumes polynomials are in the same domain.
     pub fn sub(&self, other: &Self) -> Self {
         let mut res = Self::zero();
-        for i in 0..DIM {
+        for i in 0..P::L_DIM {
             res.polys[i] = self.polys[i].sub(&other.polys[i]);
         }
         res
     }
 
-    /// Computes the pointwise product of two PolyVecs (typically in NTT domain)
-    /// and accumulates the results into a single polynomial (dot product).
-    /// Result = sum_{i=0}^{DIM-1} (self.polys[i] * other.polys[i]),
-    /// where `*` is coefficient-wise polynomial multiplication in the NTT domain.
-    /// The resulting polynomial is also in NTT domain.
-    pub fn pointwise_dot_product(&self, other: &PolyVec<P, DIM>) -> Polynomial<DilithiumPolyModParams> {
-        let mut acc = Polynomial::<DilithiumPolyModParams>::zero();
-        for i in 0..DIM {
+    /// Computes the pointwise product of two PolyVecs and accumulates into a single polynomial.
+    /// Result = sum_{i=0}^{L_DIM-1} (self.polys[i] * other.polys[i]).
+    /// Both inputs must be in NTT domain; result is also in NTT domain.
+    pub fn pointwise_dot_product(&self, other: &PolyVecL<P>) -> Polynomial<DilithiumParams> {
+        let mut acc = Polynomial::<DilithiumParams>::zero();
+        for i in 0..P::L_DIM {
             let prod = self.polys[i].ntt_mul(&other.polys[i]);
-            acc = acc.add(&prod); // Polynomial addition in NTT domain
+            acc = acc.add(&prod);
         }
         acc
     }
     
-    /// Multiplies each polynomial in this PolyVec by a single polynomial `poly_scalar_ntt`.
-    /// Assumes `self.polys[i]` and `poly_scalar_ntt` are in NTT domain.
-    /// Used for operations like `c_hat * s1_hat` or `c_hat * t1_hat`.
-    pub fn poly_mul_elementwise(&self, poly_scalar_ntt: &Polynomial<DilithiumPolyModParams>) -> Self {
+    /// Multiplies each polynomial in this PolyVec by a single polynomial.
+    /// Assumes both are in NTT domain.
+    pub fn poly_mul_elementwise(&self, poly_scalar_ntt: &Polynomial<DilithiumParams>) -> Self {
         let mut res = Self::zero();
-        for i in 0..DIM {
+        for i in 0..P::L_DIM {
             res.polys[i] = self.polys[i].ntt_mul(poly_scalar_ntt);
         }
         res
     }
 }
 
+impl<P: DilithiumSignParams> PolyVecK<P> {
+    /// Creates a new PolyVecK with all polynomial coefficients set to zero.
+    pub fn zero() -> Self {
+        Self {
+            polys: vec![Polynomial::<DilithiumParams>::zero(); P::K_DIM],
+            _params: PhantomData,
+        }
+    }
+
+    /// Applies Number Theoretic Transform (NTT) to each polynomial in the vector in-place.
+    pub fn ntt_inplace(&mut self) -> AlgoResult<()> {
+        for p in self.polys.iter_mut() {
+            p.ntt_inplace()?;
+        }
+        Ok(())
+    }
+
+    /// Applies Inverse NTT to each polynomial in the vector in-place.
+    pub fn inv_ntt_inplace(&mut self) -> AlgoResult<()> {
+        for p in self.polys.iter_mut() {
+            p.from_ntt_inplace()?;
+        }
+        Ok(())
+    }
+
+    /// Adds two PolyVecs element-wise: `self + other`.
+    pub fn add(&self, other: &Self) -> Self {
+        let mut res = Self::zero();
+        for i in 0..P::K_DIM {
+            res.polys[i] = self.polys[i].add(&other.polys[i]);
+        }
+        res
+    }
+    
+    /// Subtracts another PolyVec from this one element-wise: `self - other`.
+    pub fn sub(&self, other: &Self) -> Self {
+        let mut res = Self::zero();
+        for i in 0..P::K_DIM {
+            res.polys[i] = self.polys[i].sub(&other.polys[i]);
+        }
+        res
+    }
+}
+
+/// Matrix-vector multiplication: A_hat * vec_l
+/// where A_hat is a K×L matrix of polynomials in NTT domain
+/// and vec_l is an L-vector of polynomials in NTT domain.
+/// Result is a K-vector of polynomials in NTT domain.
+pub fn matrix_polyvecl_mul<P: DilithiumSignParams>(
+    matrix_a_hat: &[PolyVecL<P>], // K rows, each row has L polynomials
+    vector_l_hat: &PolyVecL<P>     // L polynomials
+) -> PolyVecK<P> {
+    let mut result_veck = PolyVecK::<P>::zero();
+    
+    // For each row i of the matrix (output element i)
+    for (i, row) in matrix_a_hat.iter().enumerate() {
+        // Compute dot product of row i with the vector
+        result_veck.polys[i] = row.pointwise_dot_product(vector_l_hat);
+    }
+    
+    result_veck
+}
+
 /// Expands a seed `rho_seed` into matrix A (K_DIM rows, L_DIM columns of polynomials).
-/// Each polynomial A_ij is returned in its standard coefficient representation.
-/// The caller is responsible for transforming them to NTT domain if needed.
-///
-/// # Arguments
-/// * `rho_seed`: A 32-byte seed used to generate the matrix pseudo-randomly.
-///
-/// # Returns
-/// A `Result` containing the matrix `A` represented as `[PolyVecL<P>; P::K_DIM]`,
-/// or a `SignError` on failure.
-///
-/// # Implementation Notes (FIPS 203, Algorithm 12: ExpandA)
-/// - Uses SHAKE128 as the XOF: `SHAKE128(rho || j || i)` for `A_ij` (note `j` then `i` for domain separation).
-/// - Coefficients are sampled uniformly modulo Q. Dilithium uses rejection sampling:
-///   sample 3 bytes from SHAKE, interpret as two 12-bit integers `d1, d2`.
-///   If `d1 < Q`, it's a coefficient. If `d2 < Q`, it's a coefficient. Repeat until N coefficients are generated.
-pub fn expand_matrix_a<P: DilithiumParams>(
-    rho_seed: &[u8; P::SEED_RHO_BYTES]
-) -> Result<[PolyVecL<P>; P::K_DIM], SignError> {
-    let mut matrix_a = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
-
-    for i in 0..P::K_DIM { // Row index (0 to k-1)
+/// Each polynomial A[i][j] is generated using SHAKE128(rho || j || i).
+/// Returns polynomials in standard domain.
+pub fn expand_matrix_a<P: DilithiumSignParams>(
+    rho_seed: &[u8; 32] // SEED_RHO_BYTES is always 32
+) -> Result<Vec<PolyVecL<P>>, SignError> {
+    let mut matrix_a = Vec::with_capacity(P::K_DIM);
+
+    for i in 0..P::K_DIM {    // Row index (0 to k-1)
+        let mut row = PolyVecL::<P>::zero();
+        
         for j in 0..P::L_DIM { // Column index (0 to l-1)
             let mut xof = ShakeXof128::new();
-            // Domain separation for A_ij is SHAKE128(rho || byte(j) || byte(i))
-            // Note the order: j then i for standard A_ij indexing.
+            // Domain separation: SHAKE128(rho || j || i)
             xof.update(rho_seed).map_err(SignError::from_algo)?;
-            xof.update(&[j as u8, i as u8]).map_err(SignError::from_algo)?;
+            xof.update(&[j as u8]).map_err(SignError::from_algo)?;
+            xof.update(&[i as u8]).map_err(SignError::from_algo)?;
             
-            let mut poly = Polynomial::<DilithiumPolyModParams>::zero();
-            let mut ctr = 0; // Coefficient counter for current polynomial
-            let mut temp_buf = [0u8; 3]; // Buffer for 3 bytes from SHAKE output
+            let mut poly = Polynomial::<DilithiumParams>::zero();
+            let mut ctr = 0;
+            let mut temp_buf = [0u8; 3];
 
-            while ctr < DILITHIUM_N {
+            // Sample coefficients using rejection sampling
+            while ctr < DilithiumParams::N {
                 xof.squeeze(&mut temp_buf).map_err(SignError::from_algo)?;
                 
-                // Extract two 12-bit values d1, d2 from 3 bytes
+                // Extract two 12-bit values from 3 bytes
                 // d1 = buf[0] + 2^8 * (buf[1] mod 16)
-                let val1 = (temp_buf[0] as u32) | ((temp_buf[1] as u32 & 0x0F) << 8);
+                let d1 = (temp_buf[0] as u32) | ((temp_buf[1] as u32 & 0x0F) << 8);
                 // d2 = floor(buf[1] / 16) + 2^4 * buf[2]
-                let val2 = ((temp_buf[1] >> 4) as u32) | ((temp_buf[2] as u32) << 4);
+                let d2 = ((temp_buf[1] >> 4) as u32) | ((temp_buf[2] as u32) << 4);
 
-                if val1 < (DILITHIUM_Q as u32) {
-                    poly.coeffs[ctr] = val1;
+                // Accept if less than Q
+                if d1 < DilithiumParams::Q {
+                    poly.coeffs[ctr] = d1;
                     ctr += 1;
                 }
-                if ctr < DILITHIUM_N && val2 < (DILITHIUM_Q as u32) {
-                    poly.coeffs[ctr] = val2;
+                if ctr < DilithiumParams::N && d2 < DilithiumParams::Q {
+                    poly.coeffs[ctr] = d2;
                     ctr += 1;
                 }
             }
-            matrix_a[i].polys[j] = poly;
+            
+            row.polys[j] = poly;
         }
+        
+        matrix_a.push(row);
     }
+    
     Ok(matrix_a)
 }
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/sampling.rs b/crates/sign/src/pq/dilithium/sampling.rs
index 683749f..b3fb545 100644
--- a/crates/sign/src/pq/dilithium/sampling.rs
+++ b/crates/sign/src/pq/dilithium/sampling.rs
@@ -1,33 +1,21 @@
-// File: crates/sign/src/pq/dilithium/sampling.rs
-//! Sampling functions for Dilithium, including CBD for secrets/errors,
-//! uniform bounded sampling for `y`, and sparse ternary sampling for challenge `c`.
+//! Sampling functions for Dilithium implementing FIPS 203 algorithms.
 
 use algorithms::poly::polynomial::Polynomial;
-use super::polyvec::{DilithiumPolyModParams, PolyVec, PolyVecL, PolyVecK};
-use params::pqc::dilithium::{DilithiumParams, DILITHIUM_N, DILITHIUM_Q};
-// SHAKE128 for matrix A (in polyvec), SHAKE256 for errors, y, and challenge c sampling
+use algorithms::poly::params::{DilithiumParams, Modulus};
+use super::polyvec::{PolyVecL, PolyVecK};
+use params::pqc::dilithium::DilithiumParams as DilithiumSignParams;
 use algorithms::xof::shake::ShakeXof256;
 use algorithms::xof::ExtendableOutputFunction;
-use algorithms::error::Result as AlgoResult;
-use crate::error::{Error as SignError, Result as SignResult};
+use crate::error::{Error as SignError};
 
-/// Samples a polynomial with coefficients from Centered Binomial Distribution CBD_eta.
-/// Uses SHAKE256(seed || nonce) as the randomness source.
-/// Each coefficient is $a-b$ where $a, b \leftarrow \sum_{i=0}^{\eta-1} \text{bit}_i$.
-///
-/// # Arguments
-/// * `seed`: A 32-byte seed (typically `key_seed_for_s` from `keypair_internal`).
-/// * `nonce`: A u8 nonce for domain separation (e.g., 0 for first poly in s1, 1 for second, etc.).
-/// * `eta`: The CBD parameter (e.g., `P::ETA_S1S2`).
-///
-/// # Returns
-/// A polynomial with coefficients in `[-eta, eta]`, represented in `[0, Q-1]`.
-pub fn sample_poly_cbd_eta<P: DilithiumParams>(
-    seed: &[u8; P::SEED_KEY_BYTES],
+/// Samples a polynomial with coefficients from CBD_eta (Algorithm 22).
+/// Uses SHAKE256(seed || nonce) as randomness source.
+pub fn sample_poly_cbd_eta<P: DilithiumSignParams>(
+    seed: &[u8; 32], // SEED_KEY_BYTES is always 32
     nonce: u8,
     eta: u32,
-) -> Result<Polynomial<DilithiumPolyModParams>, SignError> {
-    if eta == 0 || eta > 4 { // Dilithium eta is typically 2 or 4
+) -> Result<Polynomial<DilithiumParams>, SignError> {
+    if eta == 0 || eta > 8 {
         return Err(SignError::Sampling(format!("Invalid eta for CBD: {}", eta)));
     }
 
@@ -35,177 +23,216 @@ pub fn sample_poly_cbd_eta<P: DilithiumParams>(
     xof.update(seed).map_err(SignError::from_algo)?;
     xof.update(&[nonce]).map_err(SignError::from_algo)?;
 
-    // Each coefficient requires 2*eta bits.
-    // For eta=2, 4 bits per coeff. For eta=4, 8 bits (1 byte) per coeff.
-    // Dilithium reference implementation samples 64*eta bits at a time for N/4 coefficients.
-    // Let's sample bytes needed for all N coefficients.
-    let bytes_needed = (DILITHIUM_N * 2 * eta as usize + 7) / 8;
+    // Each coefficient requires 2*eta bits
+    let bytes_needed = if eta == 2 {
+        136 // For eta=2: 256 coeffs * 4 bits / 8 = 128 bytes, but SHAKE blocks are 136
+    } else if eta == 4 {
+        256 // For eta=4: 256 coeffs * 8 bits / 8 = 256 bytes
+    } else {
+        (DilithiumParams::N * 2 * eta as usize + 7) / 8
+    };
+    
     let mut buf = vec![0u8; bytes_needed];
     xof.squeeze(&mut buf).map_err(SignError::from_algo)?;
 
-    let mut poly = Polynomial::<DilithiumPolyModParams>::zero();
-    let mut bit_offset_in_buf = 0;
-
-    for i in 0..DILITHIUM_N {
-        let mut sum1 = 0i32;
-        let mut sum2 = 0i32;
-        for _ in 0..eta {
-            sum1 += ((buf[bit_offset_in_buf / 8] >> (bit_offset_in_buf % 8)) & 1) as i32;
-            bit_offset_in_buf += 1;
+    let mut poly = Polynomial::<DilithiumParams>::zero();
+    
+    if eta == 2 {
+        // Optimized for eta=2
+        for i in 0..DilithiumParams::N / 2 {
+            let t = buf[i] as u32;
+            let d = t & 0x0F;
+            let e = t >> 4;
+            
+            let a = d.count_ones();
+            let b = e.count_ones();
+            poly.coeffs[2 * i] = ((a as i32 - b as i32 + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
+            
+            let a = (d >> 2).count_ones();
+            let b = (e >> 2).count_ones();
+            poly.coeffs[2 * i + 1] = ((a as i32 - b as i32 + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
         }
-        for _ in 0..eta {
-            sum2 += ((buf[bit_offset_in_buf / 8] >> (bit_offset_in_buf % 8)) & 1) as i32;
-            bit_offset_in_buf += 1;
+    } else if eta == 4 {
+        // Optimized for eta=4
+        for i in 0..DilithiumParams::N {
+            let t = buf[i] as u32;
+            let a = (t & 0x0F).count_ones();
+            let b = (t >> 4).count_ones();
+            poly.coeffs[i] = ((a as i32 - b as i32 + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
+        }
+    } else {
+        // General case
+        let mut bit_offset = 0;
+        for i in 0..DilithiumParams::N {
+            let mut sum1 = 0i32;
+            let mut sum2 = 0i32;
+            
+            for _ in 0..eta {
+                sum1 += ((buf[bit_offset / 8] >> (bit_offset % 8)) & 1) as i32;
+                bit_offset += 1;
+            }
+            for _ in 0..eta {
+                sum2 += ((buf[bit_offset / 8] >> (bit_offset % 8)) & 1) as i32;
+                bit_offset += 1;
+            }
+            
+            let val_signed = sum1 - sum2;
+            poly.coeffs[i] = ((val_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
         }
-        let val_signed = sum1 - sum2; // In [-eta, eta]
-        poly.coeffs[i] = (val_signed + DILITHIUM_Q as i32) as u32 % (DILITHIUM_Q as u32);
     }
+    
     Ok(poly)
 }
 
-/// Samples a PolyVecL from CBD_eta, using incrementing nonces for each polynomial.
-pub fn sample_polyvecl_cbd_eta<P: DilithiumParams>(
-    seed: &[u8; P::SEED_KEY_BYTES],
+/// Samples a PolyVecL from CBD_eta.
+pub fn sample_polyvecl_cbd_eta<P: DilithiumSignParams>(
+    seed: &[u8; 32], // SEED_KEY_BYTES is always 32
     initial_nonce: u8,
     eta: u32,
 ) -> Result<PolyVecL<P>, SignError> {
     let mut pv = PolyVecL::<P>::zero();
     let mut current_nonce = initial_nonce;
+    
     for i in 0..P::L_DIM {
         pv.polys[i] = sample_poly_cbd_eta::<P>(seed, current_nonce, eta)?;
         current_nonce = current_nonce.wrapping_add(1);
     }
+    
     Ok(pv)
 }
 
-/// Samples a PolyVecK from CBD_eta, using incrementing nonces for each polynomial.
-pub fn sample_polyveck_cbd_eta<P: DilithiumParams>(
-    seed: &[u8; P::SEED_KEY_BYTES],
+/// Samples a PolyVecK from CBD_eta.
+pub fn sample_polyveck_cbd_eta<P: DilithiumSignParams>(
+    seed: &[u8; 32], // SEED_KEY_BYTES is always 32
     initial_nonce: u8,
     eta: u32,
 ) -> Result<PolyVecK<P>, SignError> {
     let mut pv = PolyVecK::<P>::zero();
     let mut current_nonce = initial_nonce;
+    
     for i in 0..P::K_DIM {
         pv.polys[i] = sample_poly_cbd_eta::<P>(seed, current_nonce, eta)?;
         current_nonce = current_nonce.wrapping_add(1);
     }
+    
     Ok(pv)
 }
 
-/// Samples a PolyVecL (vector `y`) with coefficients uniformly in `[-gamma1+1, gamma1-1]`.
-/// Uses SHAKE256(key_seed_for_y || kappa_nonce) as randomness source.
-///
-/// # Arguments
-/// * `key_seed_for_y`: 32-byte seed (Dilithium's `K`).
-/// * `kappa_nonce`: A 16-bit nonce (the `kappa` counter from Fiat-Shamir with Aborts).
-/// * `gamma1`: The `gamma1` parameter (e.g., `P::GAMMA1_PARAM`).
-///
-/// # Returns
-/// A `PolyVecL<P>` with coefficients in `[-gamma1+1, gamma1-1]`, represented in `[0, Q-1]`.
-///
-/// # Implementation Notes (FIPS 203, Algorithm 10, line 4 / Algorithm 23 `ExpandMask`)
-/// - For each coefficient, sample bits from SHAKE256 until a value `z` is obtained.
-/// - Reduce `z` modulo `2*gamma1 - 1`. Result is `val_in_range`.
-/// - The coefficient is `gamma1 - 1 - val_in_range`. This maps to `[-(gamma1-1), gamma1-1]`.
-/// - Store as `(coeff + Q) mod Q`.
-pub fn sample_polyvecl_uniform_gamma1<P: DilithiumParams>(
-    key_seed_for_y: &[u8; P::SEED_KEY_BYTES],
+/// Samples PolyVecL with coefficients uniformly in [-γ1+1, γ1-1] (Algorithm 23).
+/// Uses SHAKE256(K || κ || i) for polynomial i.
+pub fn sample_polyvecl_uniform_gamma1<P: DilithiumSignParams>(
+    key_seed_for_y: &[u8; 32], // SEED_KEY_BYTES is always 32
     kappa_nonce: u16,
     gamma1: u32,
 ) -> Result<PolyVecL<P>, SignError> {
-    // TODO: Implement uniform sampling in `[-gamma1+1, gamma1-1]` using SHAKE256.
-    // This is FIPS 203 Algorithm 23: ExpandMask.
-    // Needs to determine how many bits to sample from SHAKE per coefficient based on gamma1.
-    // E.g., if gamma1 = 2^17, range is approx 2^18 wide. Sample 18 bits.
-    // For gamma1 = (Q-1)/88, the range is large.
-    // The algorithm samples z from {0, ..., 2*gamma1 - 2}, then coeff = gamma1 - 1 - z.
     let mut pv = PolyVecL::<P>::zero();
-    let mod_val = 2 * gamma1 -1; // Values will be in [0, 2*gamma1-2]
-    let bits_per_z = (mod_val as f64).log2().ceil() as usize; // Number of bits needed for z
-    let bytes_per_z_sample = (bits_per_z + 7) / 8;
-
+    
+    // Determine number of bytes needed per coefficient
+    let gamma1_bits = if gamma1 == (1 << 17) {
+        18 // For γ1 = 2^17
+    } else if gamma1 == (1 << 19) {
+        20 // For γ1 = 2^19
+    } else {
+        return Err(SignError::Sampling("Unsupported gamma1 value".into()));
+    };
+    
     for i in 0..P::L_DIM {
         let mut xof = ShakeXof256::new();
         xof.update(key_seed_for_y).map_err(SignError::from_algo)?;
-        xof.update(&kappa_nonce.to_le_bytes()).map_err(SignError::from_algo)?; // kappa (nonce for y)
-        xof.update(&[i as u8]).map_err(SignError::from_algo)?; // Domain sep for poly in vec
-
-        for j in 0..DILITHIUM_N {
-            let mut z_val: u32;
-            loop {
-                let mut sample_bytes = vec![0u8; bytes_per_z_sample];
-                xof.squeeze(&mut sample_bytes).map_err(SignError::from_algo)?;
+        xof.update(&kappa_nonce.to_le_bytes()).map_err(SignError::from_algo)?;
+        xof.update(&[i as u8]).map_err(SignError::from_algo)?;
+        
+        if gamma1_bits == 18 {
+            // Sample 18-bit values for γ1 = 2^17
+            let mut buf = [0u8; 576]; // 256 * 18 / 8 = 576
+            xof.squeeze(&mut buf).map_err(SignError::from_algo)?;
+            
+            for j in 0..DilithiumParams::N / 4 {
+                let base = j * 9; // 4 coeffs * 18 bits = 72 bits = 9 bytes
                 
-                // Interpret bytes as u32 (little-endian, up to bits_per_z)
-                z_val = 0;
-                for k in 0..bytes_per_z_sample {
-                    z_val |= (sample_bytes[k] as u32) << (8*k);
-                }
-                z_val &= (1 << bits_per_z) - 1; // Mask to required bits
-
-                if z_val < mod_val { // Rejection sampling
-                    break;
+                // Unpack 4 18-bit values from 9 bytes
+                let mut z = [0u32; 4];
+                z[0] = buf[base] as u32 | ((buf[base + 1] as u32) << 8) | ((buf[base + 2] as u32 & 0x03) << 16);
+                z[1] = ((buf[base + 2] as u32) >> 2) | ((buf[base + 3] as u32) << 6) | ((buf[base + 4] as u32 & 0x0F) << 14);
+                z[2] = ((buf[base + 4] as u32) >> 4) | ((buf[base + 5] as u32) << 4) | ((buf[base + 6] as u32 & 0x3F) << 12);
+                z[3] = ((buf[base + 6] as u32) >> 6) | ((buf[base + 7] as u32) << 2) | ((buf[base + 8] as u32) << 10);
+                
+                for k in 0..4 {
+                    let coeff_signed = (gamma1 - 1) as i32 - z[k] as i32;
+                    pv.polys[i].coeffs[4 * j + k] = ((coeff_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
                 }
             }
-            let coeff_signed = (gamma1 - 1) as i32 - (z_val as i32);
-            pv.polys[i].coeffs[j] = (coeff_signed + DILITHIUM_Q as i32) as u32 % (DILITHIUM_Q as u32);
+        } else {
+            // Sample 20-bit values for γ1 = 2^19
+            let mut buf = [0u8; 640]; // 256 * 20 / 8 = 640
+            xof.squeeze(&mut buf).map_err(SignError::from_algo)?;
+            
+            for j in 0..DilithiumParams::N / 2 {
+                let base = j * 5; // 2 coeffs * 20 bits = 40 bits = 5 bytes
+                
+                // Unpack 2 20-bit values from 5 bytes
+                let z0 = buf[base] as u32 | ((buf[base + 1] as u32) << 8) | ((buf[base + 2] as u32 & 0x0F) << 16);
+                let z1 = ((buf[base + 2] as u32) >> 4) | ((buf[base + 3] as u32) << 4) | ((buf[base + 4] as u32) << 12);
+                
+                let coeff0_signed = (gamma1 - 1) as i32 - z0 as i32;
+                let coeff1_signed = (gamma1 - 1) as i32 - z1 as i32;
+                
+                pv.polys[i].coeffs[2 * j] = ((coeff0_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
+                pv.polys[i].coeffs[2 * j + 1] = ((coeff1_signed + DilithiumParams::Q as i32) % DilithiumParams::Q as i32) as u32;
+            }
         }
     }
+    
     Ok(pv)
 }
 
-/// Samples the challenge polynomial `c` from a 32-byte seed `c_tilde_seed`.
-/// `c` has `tau` coefficients equal to +1 or -1, others are 0.
-/// Uses SHAKE256(c_tilde_seed) to determine positions and signs.
-///
-/// # Arguments
-/// * `c_tilde_seed`: A 32-byte seed.
-/// * `tau`: The number of non-zero coefficients in `c` (e.g., `P::TAU_PARAM`).
-///
-/// # Returns
-/// The challenge polynomial `c`.
-///
-/// # Implementation Notes (FIPS 203, Algorithm 8: SampleInBall)
-/// - Sample 8 bits from SHAKE256 for each of the `tau` positions `p_i`.
-/// - If a position `p_i` is already taken by a previous `p_j`, try `p_i+1`, `p_i+2`, etc. (modulo N).
-/// - Sample `tau` sign bits from SHAKE256. The `i`-th sign bit determines sign of `c_{p_i}`.
-pub fn sample_challenge_c<P: DilithiumParams>(
-    c_tilde_seed: &[u8; 32], // DILITHIUM_SYMBYTES
+/// Samples challenge polynomial c with τ nonzero coefficients (Algorithm 8).
+/// Uses SHAKE256(c_tilde_seed) as randomness source.
+pub fn sample_challenge_c<P: DilithiumSignParams>(
+    c_tilde_seed: &[u8; 32], // SEED_C_TILDE_BYTES is always 32
     tau: u32,
-) -> Result<Polynomial<DilithiumPolyModParams>, SignError> {
-    // TODO: Implement Algorithm 8: SampleInBall from FIPS 203.
-    let mut c_poly = Polynomial::<DilithiumPolyModParams>::zero();
+) -> Result<Polynomial<DilithiumParams>, SignError> {
+    let mut c_poly = Polynomial::<DilithiumParams>::zero();
+    
     let mut xof = ShakeXof256::new();
     xof.update(c_tilde_seed).map_err(SignError::from_algo)?;
-
-    // Buffer for signs (tau bits needed)
-    let mut signs_buf = vec![0u8; (tau as usize + 7) / 8];
-    xof.squeeze(&mut signs_buf).map_err(SignError::from_algo)?;
     
-    let mut positions_taken = [false; DILITHIUM_N];
-    let mut count = 0;
-    let mut shake_byte_buf = [0u8; 1];
-
-    for k in 0..tau {
-        let mut pos: usize;
+    // First, squeeze sign bits (τ bits packed into bytes)
+    let sign_bytes = (tau + 7) / 8;
+    let mut signs = vec![0u8; sign_bytes as usize];
+    xof.squeeze(&mut signs).map_err(SignError::from_algo)?;
+    
+    // Track which positions have been set
+    let mut positions_used = [false; DilithiumParams::N];
+    
+    // Place τ non-zero coefficients
+    for i in 0..tau {
+        let mut pos: u8;
         loop {
-            xof.squeeze(&mut shake_byte_buf).map_err(SignError::from_algo)?;
-            pos = shake_byte_buf[0] as usize; // pos in [0, 255]
-            if !positions_taken[pos] {
+            let mut byte = [0u8; 1];
+            xof.squeeze(&mut byte).map_err(SignError::from_algo)?;
+            pos = byte[0];
+            
+            // Find next available position
+            let mut j = pos as usize;
+            while j < DilithiumParams::N && positions_used[j] {
+                j += 1;
+            }
+            
+            if j < DilithiumParams::N {
+                positions_used[j] = true;
+                
+                // Set coefficient with appropriate sign
+                let sign_bit = (signs[i as usize / 8] >> (i % 8)) & 1;
+                if sign_bit == 0 {
+                    c_poly.coeffs[j] = 1;
+                } else {
+                    c_poly.coeffs[j] = DilithiumParams::Q - 1; // -1 mod Q
+                }
                 break;
             }
         }
-        positions_taken[pos] = true;
-
-        let sign_bit = (signs_buf[k as usize / 8] >> (k as usize % 8)) & 1;
-        if sign_bit == 0 {
-            c_poly.coeffs[pos] = 1;
-        } else {
-            c_poly.coeffs[pos] = DILITHIUM_Q as u32 - 1; // -1 mod Q
-        }
-        count += 1;
     }
-    // All other coefficients remain 0.
+    
     Ok(c_poly)
 }
\ No newline at end of file
diff --git a/crates/sign/src/pq/dilithium/sign.rs b/crates/sign/src/pq/dilithium/sign.rs
index ab06160..d6aef67 100644
--- a/crates/sign/src/pq/dilithium/sign.rs
+++ b/crates/sign/src/pq/dilithium/sign.rs
@@ -1,293 +1,358 @@
-// File: crates/sign/src/pq/dilithium/sign.rs
-//! Core implementation logic for Dilithium key generation, signing, and verification.
-//! This file orchestrates the use of polynomial operations, arithmetic helpers,
-//! sampling, and encoding routines to implement the Dilithium signature scheme.
+//! Core implementation of Dilithium key generation, signing, and verification per FIPS 203.
+//!
+//! Implements lattice-based signatures using Fiat-Shamir with Aborts.
+//! Security based on Module-LWE and Module-SIS problems.
+//!
+//! Critical invariants (DO NOT MODIFY):
+//! - `||z||∞ ≤ γ1 - β` (prevents key recovery)
+//! - `||LowBits(w - cs2)||∞ ≤ γ2 - β` (ensures uniformity)
+//! - Rejection sampling protects against side-channel leakage
+//!
+//! Implementation notes:
+//! - Signing is deterministic (randomness from key + counter)
+//! - Track polynomial domains carefully (standard vs NTT)
+//! - Expected signing iterations: 4-7 (varies by parameter set)
+//!
+//! Internal module - use public `Dilithium2/3/5` types instead.
 
-use super::polyvec::{PolyVecL, PolyVecK, expand_matrix_a};
-// Assuming DilithiumPolyModParams is correctly defined in algorithms::poly::params
-use algorithms::poly::params::DilithiumPolyModParams;
-use super::arithmetic::{power2round_polyvec, highbits_polyvec, lowbits_polyvec, check_norm_polyvec, make_hint_polyveck, use_hint_polyveck_from_sig};
-use super::sampling::{sample_polyvecl_cbd_eta, sample_polyveck_cbd_eta, sample_polyvecl_uniform_gamma1, sample_challenge_c};
-use super::encoding::{pack_public_key, unpack_public_key, pack_secret_key, unpack_secret_key, pack_signature, unpack_signature, pack_polyveck_w1};
+use super::polyvec::{PolyVecK, expand_matrix_a, matrix_polyvecl_mul};
+use algorithms::poly::params::NttModulus;  // FIXED: Import NttModulus from params
+use super::arithmetic::{
+    power2round_polyvec, highbits_polyvec, lowbits_polyvec, 
+    check_norm_polyvec_l, check_norm_polyvec_k,
+    make_hint_polyveck, use_hint_polyveck
+};
+use super::sampling::{
+    sample_polyvecl_cbd_eta, sample_polyveck_cbd_eta, 
+    sample_polyvecl_uniform_gamma1, sample_challenge_c
+};
+use super::encoding::{
+    pack_public_key, unpack_public_key, pack_secret_key, 
+    unpack_secret_key, pack_signature, unpack_signature, pack_polyveck_w1
+};
 
-use algorithms::hash::sha3::{Sha3_256, Sha3_512};
+use algorithms::hash::sha3::Sha3_256;
+use algorithms::xof::shake::ShakeXof256;
 use algorithms::hash::HashFunction;
-use algorithms::error::Result as AlgoResult;
-use crate::error::{Error as SignError, Result as SignResult};
-use params::pqc::dilithium::{DilithiumParams, DILITHIUM_N, DILITHIUM_Q};
+use algorithms::xof::ExtendableOutputFunction;
+use crate::error::{Error as SignError};
+use params::pqc::dilithium::{DilithiumParams as DilithiumSignParams, DILITHIUM_N};
 use rand::{CryptoRng, RngCore};
-use zeroize::Zeroize;
 use subtle::ConstantTimeEq;
 
-
-/// Internal Key Generation for Dilithium (Algorithm 9 from FIPS 203).
-pub(crate) fn keypair_internal<P, R>(rng: &mut R) -> SignResult<(Vec<u8>, Vec<u8>)>
+/// Key Generation (Algorithm 9 from FIPS 203)
+/// 
+/// Generates (pk, sk) where pk = (ρ, t1) and sk = (ρ, K, tr, s1, s2, t0).
+/// Matrix A expanded from ρ, secrets s1,s2 from CBD(η).
+pub(crate) fn keypair_internal<P, R>(rng: &mut R) -> Result<(Vec<u8>, Vec<u8>), SignError>
 where
-    P: DilithiumParams,
+    P: DilithiumSignParams,
     R: RngCore + CryptoRng,
 {
-    let mut zeta_seed = [0u8; P::SEED_ZETA_BYTES]; // Seed for K, s1, s2, (e in PKE)
-    let mut rho_seed = [0u8; P::SEED_RHO_BYTES];
+    // Step 1: Sample ζ
+    let mut zeta_seed = vec![0u8; P::SEED_ZETA_BYTES];
     rng.fill_bytes(&mut zeta_seed);
-    rng.fill_bytes(&mut rho_seed);
-
-    // Split zeta into seed for s1/s2 (sigma_seed) and seed for y (K_seed)
-    // FIPS 203: G(zeta) -> (rho, sigma_seed, K_seed)
-    // For simplicity here, we use zeta directly for sigma_seed and K_seed.
-    // A real implementation would use SHAKE256(zeta) to derive these.
-    let sigma_seed = zeta_seed; // Placeholder
-    let k_seed_for_signing = zeta_seed; // Placeholder
-
-    // 1. Expand A from rho (standard domain)
+    
+    // Step 2: Expand seeds using G = SHAKE256
+    let mut xof = ShakeXof256::new();
+    xof.update(&zeta_seed).map_err(SignError::from_algo)?;
+    
+    let mut seeds = vec![0u8; P::SEED_RHO_BYTES + P::SEED_KEY_BYTES + P::SEED_KEY_BYTES];
+    xof.squeeze(&mut seeds).map_err(SignError::from_algo)?;
+    
+    let mut rho_seed = [0u8; 32];
+    let mut sigma_seed = [0u8; 32];
+    let mut k_seed = [0u8; 32];
+    
+    rho_seed.copy_from_slice(&seeds[0..P::SEED_RHO_BYTES]);
+    sigma_seed.copy_from_slice(&seeds[P::SEED_RHO_BYTES..P::SEED_RHO_BYTES + P::SEED_KEY_BYTES]);
+    k_seed.copy_from_slice(&seeds[P::SEED_RHO_BYTES + P::SEED_KEY_BYTES..]);
+    
+    // Step 3: Expand A from ρ
     let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
-    // Convert matrix_a to NTT form (A_hat)
-    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
-    for i in 0..P::K_DIM {
-        for j in 0..P::L_DIM {
-            let mut poly = matrix_a[i].polys[j].clone();
-            poly.ntt_inplace().map_err(SignError::from_algo)?;
-            matrix_a_hat[i].polys[j] = poly;
-        }
-    }
-
-    // 2. Sample s1, s2 from CBD_eta using sigma_seed
-    let s1_vec = sample_polyvecl_cbd_eta::<P>(&sigma_seed, 0, P::ETA_S1S2 as u32)?;
-    let s2_vec = sample_polyveck_cbd_eta::<P>(&sigma_seed, P::L_DIM as u8, P::ETA_S1S2 as u32)?;
     
-    let mut s1_hat_vec = s1_vec.clone(); s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-    let mut s2_hat_vec = s2_vec.clone(); s2_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-
-    // 3. t_hat_vec = A_hat * s1_hat_vec + s2_hat_vec
-    let mut t_hat_vec = PolyVecK::<P>::zero();
+    // Convert A to NTT domain (Â)
+    let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
     for i in 0..P::K_DIM {
-        let row_a_hat = &matrix_a_hat[i];
-        let dot_product_poly = row_a_hat.pointwise_dot_product(&s1_hat_vec);
-        t_hat_vec.polys[i] = dot_product_poly.add(&s2_hat_vec.polys[i]);
+        let mut row = matrix_a[i].clone();
+        row.ntt_inplace().map_err(SignError::from_algo)?; // Keep A in NTT for efficiency
+        matrix_a_hat.push(row);
     }
     
+    // Step 4: Sample s1, s2
+    let s1_vec = sample_polyvecl_cbd_eta::<P>(&sigma_seed, 0, P::ETA_S1S2)?;
+    let s2_vec = sample_polyveck_cbd_eta::<P>(&sigma_seed, P::L_DIM as u8, P::ETA_S1S2)?;
+    
+    // Convert to NTT domain
+    let mut s1_hat_vec = s1_vec.clone();
+    s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    let mut s2_hat_vec = s2_vec.clone();
+    s2_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    // Step 5: t̂ = Â·ŝ1 + ŝ2
+    let mut t_hat_vec = matrix_polyvecl_mul(&matrix_a_hat, &s1_hat_vec);
+    t_hat_vec = t_hat_vec.add(&s2_hat_vec);
+    
+    // Convert back to standard domain
     let mut t_vec = t_hat_vec.clone();
     t_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
-
-    // 5. (t0_vec, t1_vec) = Power2Round(t_vec, D_PARAM)
-    let (t0_vec, t1_vec) = power2round_polyvec(&t_vec, P::D_PARAM as u32);
-
-    // 6. pk = (rho_seed, pack(t1_vec))
+    
+    // Step 6: (t0, t1) = Power2Round(t)
+    let (t0_vec, t1_vec) = power2round_polyvec(&t_vec, P::D_PARAM);
+    
+    // Step 7: Pack public key
     let pk_bytes = pack_public_key::<P>(&rho_seed, &t1_vec)?;
-
-    // 7. tr = H(pk_bytes) (SHA3-256)
-    let mut hasher_tr = Sha3_256::new();
-    hasher_tr.update(&pk_bytes).map_err(SignError::from_algo)?;
-    let tr_digest = hasher_tr.finalize().map_err(SignError::from_algo)?;
-    let mut tr = [0u8; P::HASH_TR_BYTES]; // Use const from P
-    tr.copy_from_slice(tr_digest.as_ref());
-
-    // 8. sk = (rho_seed, k_seed_for_signing, tr, pack(s1_vec), pack(s2_vec), pack(t0_vec))
-    let sk_bytes = pack_secret_key::<P>(&rho_seed, &k_seed_for_signing, &tr, &s1_vec, &s2_vec, &t0_vec)?;
+    
+    // Step 8: tr = H(pk)
+    let mut hasher = Sha3_256::new();
+    hasher.update(&pk_bytes).map_err(SignError::from_algo)?;
+    let tr_digest = hasher.finalize().map_err(SignError::from_algo)?;
+    let mut tr = [0u8; 32];
+    tr.copy_from_slice(&tr_digest);
+    
+    // Step 9: Pack secret key
+    let sk_bytes = pack_secret_key::<P>(&rho_seed, &k_seed, &tr, &s1_vec, &s2_vec, &t0_vec)?;
     
     Ok((pk_bytes, sk_bytes))
 }
 
-
-/// Internal Signing logic for Dilithium (Algorithm 10 from FIPS 203).
+/// Signing (Algorithm 10 from FIPS 203)
+/// 
+/// Produces signature (c̃, z, h) using rejection sampling.
+/// Aborts and retries if z or w-cs2 exceed bounds (side-channel protection).
+/// Deterministic: y derived from K and counter κ.
 pub(crate) fn sign_internal<P, R>(
     message: &[u8],
     sk_bytes: &[u8],
-    _rng_for_hedging_if_any: &mut R, // Standard Dilithium is deterministic given SK and message.
-) -> SignResult<Vec<u8>>
+    _rng: &mut R, // Dilithium is deterministic
+) -> Result<Vec<u8>, SignError>
 where
-    P: DilithiumParams,
+    P: DilithiumSignParams,
     R: RngCore + CryptoRng,
 {
+    // Step 1: Unpack secret key
     let (rho_seed, k_seed, tr_hash, s1_vec, s2_vec, t0_vec) = unpack_secret_key::<P>(sk_bytes)?;
     
-    let mut s1_hat_vec = s1_vec.clone(); s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-    // s2 is used in standard domain for w - c*s2
-    // t0 is used in standard domain for w1_prime - c*t0 (UseHint part)
-
-    let matrix_a_orig = expand_matrix_a::<P>(&rho_seed)?;
-    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
+    // Convert s1 to NTT domain
+    let mut s1_hat_vec = s1_vec.clone();
+    s1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    // Step 2: Expand A
+    let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
+    let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
     for i in 0..P::K_DIM {
-        for j in 0..P::L_DIM {
-            let mut poly = matrix_a_orig[i].polys[j].clone();
-            poly.ntt_inplace().map_err(SignError::from_algo)?;
-            matrix_a_hat[i].polys[j] = poly;
-        }
+        let mut row = matrix_a[i].clone();
+        row.ntt_inplace().map_err(SignError::from_algo)?;
+        matrix_a_hat.push(row);
     }
-
-    // mu = H_msg(tr_hash || message) (SHA3-512)
-    let mut hasher_mu = Sha3_512::new();
-    hasher_mu.update(&tr_hash).map_err(SignError::from_algo)?;
-    hasher_mu.update(message).map_err(SignError::from_algo)?;
-    let mu_digest = hasher_mu.finalize().map_err(SignError::from_algo)?;
-    let mu = mu_digest.as_ref();
-
+    
+    // Step 3: μ = H(tr || M)
+    let mut xof_mu = ShakeXof256::new();
+    xof_mu.update(&tr_hash).map_err(SignError::from_algo)?;
+    xof_mu.update(message).map_err(SignError::from_algo)?;
+    let mut mu = vec![0u8; 64];
+    xof_mu.squeeze(&mut mu).map_err(SignError::from_algo)?;
+    
+    // Step 4: κ = 0
     let mut kappa: u16 = 0;
-    loop { // Fiat-Shamir with Aborts
-        if kappa > P::MAX_SIGN_ABORTS { // Add MAX_SIGN_ABORTS to DilithiumParams
-            return Err(SignError::SignatureGeneration("Exceeded max signature attempts".into()));
-        }
-
-        let y_vec = sample_polyvecl_uniform_gamma1::<P>(&k_seed, kappa, P::GAMMA1_PARAM as u32)?;
-        let mut y_hat_vec = y_vec.clone(); y_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-
-        // w_hat = A_hat * y_hat
-        let mut w_hat_vec = PolyVecK::<P>::zero();
-        for i in 0..P::K_DIM {
-            w_hat_vec.polys[i] = matrix_a_hat[i].pointwise_dot_product(&y_hat_vec);
+    
+    loop {
+        // Check abort condition
+        if kappa >= P::MAX_SIGN_ABORTS {
+            return Err(SignError::SignatureGeneration {
+                algorithm: P::NAME,
+                details: "Exceeded max attempts".into(),
+            });
         }
         
-        let mut w_vec = w_hat_vec.clone(); w_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+        // Step 5: y = ExpandMask(K, κ)
+        let y_vec = sample_polyvecl_uniform_gamma1::<P>(&k_seed, kappa, P::GAMMA1_PARAM)?;
         
-        // w1 = HighBits(w_vec, 2*gamma2)
-        let w1_vec = highbits_polyvec(&w_vec, 2 * P::GAMMA2_PARAM as u32);
+        // Convert to NTT domain
+        let mut y_hat_vec = y_vec.clone();
+        y_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+        
+        // Step 6: ŵ = Â·ŷ
+        let w_hat_vec = matrix_polyvecl_mul(&matrix_a_hat, &y_hat_vec);
+        
+        // Convert to standard domain
+        let mut w_vec = w_hat_vec.clone();
+        w_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+        
+        // Step 7: w1 = HighBits(w)
+        let w1_vec = highbits_polyvec(&w_vec, 2 * P::GAMMA2_PARAM);
+        
+        // Step 8: c̃ = H(μ || w1)
         let w1_packed = pack_polyveck_w1::<P>(&w1_vec)?;
-
-        // c_tilde_seed = H_chal(mu || w1_packed) (SHA3-256)
-        let mut hasher_ctilde_seed = Sha3_256::new();
-        hasher_ctilde_seed.update(mu).map_err(SignError::from_algo)?;
-        hasher_ctilde_seed.update(&w1_packed).map_err(SignError::from_algo)?;
-        let c_tilde_seed_digest = hasher_ctilde_seed.finalize().map_err(SignError::from_algo)?;
-        let mut c_tilde_seed = [0u8; P::SEED_C_TILDE_BYTES];
-        c_tilde_seed.copy_from_slice(c_tilde_seed_digest.as_ref());
+        let mut xof_c = ShakeXof256::new();
+        xof_c.update(&mu).map_err(SignError::from_algo)?;
+        xof_c.update(&w1_packed).map_err(SignError::from_algo)?;
+        let mut c_tilde_seed = [0u8; 32];
+        xof_c.squeeze(&mut c_tilde_seed).map_err(SignError::from_algo)?;
         
+        // Step 9: c = SampleInBall(c̃)
         let c_poly = sample_challenge_c::<P>(&c_tilde_seed, P::TAU_PARAM as u32)?;
         
-        // z_vec = y_vec + c_poly * s1_vec (standard domain)
+        // Step 10: z = y + c·s1
         let mut z_vec = y_vec.clone();
         for i in 0..P::L_DIM {
             let cs1_i = c_poly.schoolbook_mul(&s1_vec.polys[i]);
             z_vec.polys[i] = z_vec.polys[i].add(&cs1_i);
         }
         
-        if !check_norm_polyvec(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
-            kappa = kappa.wrapping_add(1); continue;
+        // Step 11: Check ||z||∞
+        if !check_norm_polyvec_l::<P>(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
+            kappa = kappa.wrapping_add(1);
+            continue; // Rejection sampling - critical for security
         }
         
-        // LowBits(w_vec - c_poly * s2_vec)
+        // Step 12-13: Check low bits of w - c·s2
         let mut cs2_vec = PolyVecK::<P>::zero();
         for i in 0..P::K_DIM {
             cs2_vec.polys[i] = c_poly.schoolbook_mul(&s2_vec.polys[i]);
         }
-        let w_minus_cs2_vec = w_vec.sub(&cs2_vec);
-        let lowbits_w_cs2_vec = lowbits_polyvec(&w_minus_cs2_vec, 2 * P::GAMMA2_PARAM as u32);
+        let w_minus_cs2 = w_vec.sub(&cs2_vec);
+        let r0_vec = lowbits_polyvec(&w_minus_cs2, 2 * P::GAMMA2_PARAM);
         
-        if !check_norm_polyvec(&lowbits_w_cs2_vec, P::GAMMA2_PARAM - P::BETA_PARAM) {
-            kappa = kappa.wrapping_add(1); continue;
+        if !check_norm_polyvec_k::<P>(&r0_vec, P::GAMMA2_PARAM - P::BETA_PARAM) {
+            kappa = kappa.wrapping_add(1);
+            continue;
         }
-
-        // MakeHint for h_vec. v = w - c*s2. Check uses v - c*t0.
-        // Hint = MakeHint(-c*t0, v - c*t0) = MakeHint(-c*t0, w - c*s2 - c*t0)
-        // FIPS 203 Algorithm 10 line 17: h = MakeHint(-c*t0, w1 + c*t0) is incorrect.
-        // It should be related to w0 - c*t0 (the part removed by HighBits).
-        // Correctly, h is MakeHint(v0_prime, v1_prime) where (v0_prime, v1_prime) = Decompose(w-c*s2-c*t0).
-        // Let's assume `make_hint_polyveck` is correctly implemented based on `v_for_hint = w_vec - cs2_vec - ct0_vec`.
+        
+        // Step 14-15: Make hint
         let mut ct0_vec = PolyVecK::<P>::zero();
         for i in 0..P::K_DIM {
             ct0_vec.polys[i] = c_poly.schoolbook_mul(&t0_vec.polys[i]);
         }
-        let v_for_hint_poly = w_minus_cs2_vec.sub(&ct0_vec); // w - c*s2 - c*t0
-        // Decompose v_for_hint_poly to get its v0 and v1 parts for MakeHint
-        let (v0_for_hint, v1_for_hint) = power2round_polyvec(&v_for_hint_poly, P::D_PARAM as u32); // This is not correct, MakeHint uses Decompose with 2*gamma2
-        // Placeholder for actual hint generation based on spec (is complex)
-        let h_hint_poly = make_hint_polyveck::<P>(&v0_for_hint, &v1_for_hint)?;
+        let v_for_hint = w_minus_cs2.sub(&ct0_vec);
+        let (h_hint_poly, hint_count) = make_hint_polyveck::<P>(&v_for_hint)?;
         
-        let mut hint_count = 0;
-        for poly_h in h_hint_poly.polys.iter() {
-            for &coeff_h in poly_h.coeffs.iter() { if coeff_h == 1 { hint_count += 1; }}
-        }
+        // Step 16: Check hint count
         if hint_count > P::OMEGA_PARAM as usize {
-            kappa = kappa.wrapping_add(1); continue;
+            kappa = kappa.wrapping_add(1);
+            continue; // Too many hints would allow forgeries
         }
-
+        
+        // Step 17: Return signature
         return pack_signature::<P>(&c_tilde_seed, &z_vec, &h_hint_poly);
     }
 }
 
-/// Internal Verification logic for Dilithium (Algorithm 11 from FIPS 203).
+/// Verification (Algorithm 11 from FIPS 203)
+/// 
+/// Accepts if: c̃ = H(μ || UseHint(h, Az - ct1·2^d)) and ||z||∞ ≤ γ1 - β.
+/// Strong unforgeability: signatures cannot be forged even with oracle access.
 pub(crate) fn verify_internal<P>(
     message: &[u8],
     sig_bytes: &[u8],
     pk_bytes: &[u8],
-) -> SignResult<()>
+) -> Result<(), SignError>
 where
-    P: DilithiumParams,
+    P: DilithiumSignParams,
 {
+    // Step 1: Unpack public key
     let (rho_seed, t1_vec) = unpack_public_key::<P>(pk_bytes)?;
-    // h_packed_indices is really the packed form of h, not yet a PolyVecK of 0/1s.
-    // Needs proper unpacking based on FIPS 203 Appendix A.3
-    let (c_tilde_seed_sig, z_vec, h_packed_poly) = unpack_signature::<P>(sig_bytes)?;
-
-    if !check_norm_polyvec(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
-        return Err(SignError::Verification("Signature norm check for z failed".into()));
+    
+    // Step 2: Unpack signature
+    let (c_tilde_seed_sig, z_vec, h_hint_poly) = unpack_signature::<P>(sig_bytes)?;
+    
+    // Step 3: Check ||z||∞
+    if !check_norm_polyvec_l::<P>(&z_vec, P::GAMMA1_PARAM - P::BETA_PARAM) {
+        return Err(SignError::Verification {
+            algorithm: P::NAME,
+            details: "z norm check failed".into(),
+        });
     }
     
-    let matrix_a_orig = expand_matrix_a::<P>(&rho_seed)?;
-    let mut matrix_a_hat = [(); P::K_DIM].map(|_| PolyVecL::<P>::zero());
+    // Step 4: Expand A
+    let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
+    let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
     for i in 0..P::K_DIM {
-        for j in 0..P::L_DIM {
-            let mut poly = matrix_a_orig[i].polys[j].clone();
-            poly.ntt_inplace().map_err(SignError::from_algo)?;
-            matrix_a_hat[i].polys[j] = poly;
-        }
+        let mut row = matrix_a[i].clone();
+        row.ntt_inplace().map_err(SignError::from_algo)?;
+        matrix_a_hat.push(row);
     }
-
+    
+    // Step 5: tr = H(pk)
+    let mut hasher = Sha3_256::new();
+    hasher.update(pk_bytes).map_err(SignError::from_algo)?;
+    let tr_digest = hasher.finalize().map_err(SignError::from_algo)?;
+    let mut tr = [0u8; 32];
+    tr.copy_from_slice(&tr_digest);
+    
+    // Step 6: μ = H(tr || M)
+    let mut xof_mu = ShakeXof256::new();
+    xof_mu.update(&tr).map_err(SignError::from_algo)?;
+    xof_mu.update(message).map_err(SignError::from_algo)?;
+    let mut mu = vec![0u8; 64];
+    xof_mu.squeeze(&mut mu).map_err(SignError::from_algo)?;
+    
+    // Step 7: c = SampleInBall(c̃)
     let c_poly = sample_challenge_c::<P>(&c_tilde_seed_sig, P::TAU_PARAM as u32)?;
-    let mut c_hat_poly = c_poly.clone(); c_hat_poly.ntt_inplace().map_err(SignError::from_algo)?;
     
-    let mut z_hat_vec = z_vec.clone(); z_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-    let mut t1_hat_vec = t1_vec.clone(); t1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
-
-    // w1_prime_hat = A_hat * z_hat - c_hat * t1_hat
-    // (A_hat * z_hat)_i = sum_j (A_hat_ij * z_hat_j)
-    // (c_hat * t1_hat)_i = c_hat * t1_hat_i
-    let mut w1_prime_hat_vec = PolyVecK::<P>::zero();
-    for i in 0..P::K_DIM { // For each of K polynomials in the result vector
-        let az_i = matrix_a_hat[i].pointwise_dot_product(&z_hat_vec);
-        let ct1_i = t1_hat_vec.polys[i].ntt_mul(&c_hat_poly);
-        w1_prime_hat_vec.polys[i] = az_i.sub(&ct1_i);
+    // Convert to NTT domain
+    let mut c_hat_poly = c_poly.clone();
+    c_hat_poly.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    let mut z_hat_vec = z_vec.clone();
+    z_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    let mut t1_hat_vec = t1_vec.clone();
+    t1_hat_vec.ntt_inplace().map_err(SignError::from_algo)?;
+    
+    // Step 8: ŵ' = Â·ẑ - ĉ·t̂₁·2^d
+    let az_hat = matrix_polyvecl_mul(&matrix_a_hat, &z_hat_vec);
+    
+    // Scale t1 by 2^d and multiply by c
+    let two_d = 1 << P::D_PARAM;
+    let mut ct1_scaled_hat = PolyVecK::<P>::zero();
+    for i in 0..P::K_DIM {
+        let t1_scaled = t1_hat_vec.polys[i].scalar_mul(two_d);
+        ct1_scaled_hat.polys[i] = c_hat_poly.ntt_mul(&t1_scaled);
     }
     
-    let mut w1_prime_vec = w1_prime_hat_vec.clone();
-    w1_prime_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
-
-    // Apply UseHint. The spec is w1'' = UseHint(h, A*z - c*t1) where (A*z - c*t1) is w1_prime_vec.
-    // h_packed_poly needs to be correctly interpreted as hint indices.
-    let w1_double_prime_vec = use_hint_polyveck_from_sig::<P>(&h_packed_poly, &w1_prime_vec)?;
+    let w_prime_hat_vec = az_hat.sub(&ct1_scaled_hat);
+    
+    // Convert to standard domain
+    let mut w_prime_vec = w_prime_hat_vec.clone();
+    w_prime_vec.inv_ntt_inplace().map_err(SignError::from_algo)?;
+    
+    // Step 9: w₁'' = UseHint(h, w')
+    let w1_double_prime_vec = use_hint_polyveck::<P>(&h_hint_poly, &w_prime_vec)?;
+    
+    // Step 10: c̃' = H(μ || w₁'')
     let w1_double_prime_packed = pack_polyveck_w1::<P>(&w1_double_prime_vec)?;
-
-    // tr = H(pk_bytes)
-    let mut hasher_tr = Sha3_256::new();
-    hasher_tr.update(pk_bytes).map_err(SignError::from_algo)?;
-    let tr_digest = hasher_tr.finalize().map_err(SignError::from_algo)?;
-    let mut tr = [0u8; P::HASH_TR_BYTES];
-    tr.copy_from_slice(tr_digest.as_ref());
-
-    // mu = H_msg(tr || message)
-    let mut hasher_mu = Sha3_512::new();
-    hasher_mu.update(&tr).map_err(SignError::from_algo)?;
-    hasher_mu.update(message).map_err(SignError::from_algo)?;
-    let mu_digest = hasher_mu.finalize().map_err(SignError::from_algo)?;
-    let mu = mu_digest.as_ref();
-
-    // c_tilde_seed_recomputed = H_chal(mu || w1_double_prime_packed)
-    let mut hasher_ctilde_seed_recomputed = Sha3_256::new();
-    hasher_ctilde_seed_recomputed.update(mu).map_err(SignError::from_algo)?;
-    hasher_ctilde_seed_recomputed.update(&w1_double_prime_packed).map_err(SignError::from_algo)?;
-    let c_tilde_seed_recomputed_digest = hasher_ctilde_seed_recomputed.finalize().map_err(SignError::from_algo)?;
-    
-    // Constant time comparison for c_tilde_seed
-    if !c_tilde_seed_sig.ct_eq(c_tilde_seed_recomputed_digest.as_ref()).into_bool() {
-         return Err(SignError::Verification("Challenge c_tilde mismatch".into()));
+    let mut xof_c_recompute = ShakeXof256::new();
+    xof_c_recompute.update(&mu).map_err(SignError::from_algo)?;
+    xof_c_recompute.update(&w1_double_prime_packed).map_err(SignError::from_algo)?;
+    let mut c_tilde_seed_recomputed = [0u8; 32];
+    xof_c_recompute.squeeze(&mut c_tilde_seed_recomputed).map_err(SignError::from_algo)?;
+    
+    // Step 11: Verify c̃ = c̃'
+    if !bool::from(c_tilde_seed_sig.ct_eq(&c_tilde_seed_recomputed)) {
+        return Err(SignError::Verification {
+            algorithm: P::NAME,
+            details: "Challenge mismatch".into(),
+        });
     }
     
-    // Verify hint count (omega check from h_packed_poly)
+    // Step 12: Verify hint count
     let mut hint_count = 0;
-    for poly_h in h_packed_poly.polys.iter() {
-        for &coeff_h in poly_h.coeffs.iter() { if coeff_h == 1 { hint_count += 1; }}
+    for i in 0..P::K_DIM {
+        for j in 0..DILITHIUM_N {
+            if h_hint_poly.polys[i].coeffs[j] == 1 {
+                hint_count += 1;
+            }
+        }
     }
+    
     if hint_count > P::OMEGA_PARAM as usize {
-        return Err(SignError::Verification("Too many hints indicated in signature".into()));
+        return Err(SignError::Verification {
+            algorithm: P::NAME,
+            details: "Too many hints".into(),
+        });
     }
-
+    
     Ok(())
 }
\ No newline at end of file
