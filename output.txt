diff --git a/crates/algorithms/src/aead/chacha20poly1305/tests.rs b/crates/algorithms/src/aead/chacha20poly1305/tests.rs
index 9747512..9bbe6c7 100644
--- a/crates/algorithms/src/aead/chacha20poly1305/tests.rs
+++ b/crates/algorithms/src/aead/chacha20poly1305/tests.rs
@@ -69,7 +69,7 @@ fn test_chacha20poly1305_encrypt_decrypt() {
     
     // Verify that tampering with ciphertext results in authentication failure
     let mut tampered = ciphertext.clone();
-    if tampered.len() > 0 {
+    if !tampered.is_empty() {
         tampered[0] ^= 1; // Flip a bit
     }
     
diff --git a/crates/algorithms/src/block/modes/cbc/tests.rs b/crates/algorithms/src/block/modes/cbc/tests.rs
index 354c47c..9fb513a 100644
--- a/crates/algorithms/src/block/modes/cbc/tests.rs
+++ b/crates/algorithms/src/block/modes/cbc/tests.rs
@@ -87,14 +87,14 @@ fn parse_aes_cbc_test_file(filepath: &str) -> Vec<AesCbcTestVector> {
             continue;
         }
         
-        if line.starts_with("COUNT = ") {
+        if let Some(count_str) = line.strip_prefix("COUNT = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract count
-            let count = line[8..].parse::<usize>().unwrap();
+            let count = count_str.parse::<usize>().unwrap();
             
             current_vector = Some(AesCbcTestVector {
                 count,
@@ -105,14 +105,14 @@ fn parse_aes_cbc_test_file(filepath: &str) -> Vec<AesCbcTestVector> {
             });
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("KEY = ") {
-                vector.key = line[6..].to_string();
-            } else if line.starts_with("IV = ") {
-                vector.iv = line[5..].to_string();
-            } else if line.starts_with("PLAINTEXT = ") {
-                vector.plaintext = line[12..].to_string();
-            } else if line.starts_with("CIPHERTEXT = ") {
-                vector.ciphertext = line[13..].to_string();
+            if let Some(key_str) = line.strip_prefix("KEY = ") {
+                vector.key = key_str.to_string();
+            } else if let Some(iv_str) = line.strip_prefix("IV = ") {
+                vector.iv = iv_str.to_string();
+            } else if let Some(plaintext_str) = line.strip_prefix("PLAINTEXT = ") {
+                vector.plaintext = plaintext_str.to_string();
+            } else if let Some(ciphertext_str) = line.strip_prefix("CIPHERTEXT = ") {
+                vector.ciphertext = ciphertext_str.to_string();
             }
         }
     }
@@ -144,8 +144,8 @@ fn run_aes128_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         
         // Ensure key has the expected size for AES-128
         assert_eq!(key.len(), 16, 
-            "Key size mismatch for {} test case {}. Expected: 16, Got: {}",
-            name, i, key.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 16, Got: {}",
+            name, i, test.count, key.len());
         
         // Create AES-128 cipher and CBC mode
         let secret_key = SecretBytes::<16>::from_slice(&key)
@@ -156,29 +156,29 @@ fn run_aes128_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = cbc.encrypt(&plaintext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = cbc.decrypt(&ciphertext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
@@ -202,8 +202,8 @@ fn run_aes192_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         
         // Ensure key has the expected size for AES-192
         assert_eq!(key.len(), 24, 
-            "Key size mismatch for {} test case {}. Expected: 24, Got: {}",
-            name, i, key.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 24, Got: {}",
+            name, i, test.count, key.len());
         
         // Create AES-192 cipher and CBC mode
         let secret_key = SecretBytes::<24>::from_slice(&key)
@@ -214,29 +214,29 @@ fn run_aes192_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = cbc.encrypt(&plaintext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = cbc.decrypt(&ciphertext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
@@ -260,8 +260,8 @@ fn run_aes256_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         
         // Ensure key has the expected size for AES-256
         assert_eq!(key.len(), 32, 
-            "Key size mismatch for {} test case {}. Expected: 32, Got: {}",
-            name, i, key.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 32, Got: {}",
+            name, i, test.count, key.len());
         
         // Create AES-256 cipher and CBC mode
         let secret_key = SecretBytes::<32>::from_slice(&key)
@@ -272,29 +272,29 @@ fn run_aes256_cbc_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = cbc.encrypt(&plaintext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = cbc.decrypt(&ciphertext).unwrap();
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
diff --git a/crates/algorithms/src/block/modes/ctr/tests.rs b/crates/algorithms/src/block/modes/ctr/tests.rs
index 47e4a58..fbf75bb 100644
--- a/crates/algorithms/src/block/modes/ctr/tests.rs
+++ b/crates/algorithms/src/block/modes/ctr/tests.rs
@@ -89,14 +89,14 @@ fn parse_aes_ctr_test_file(filepath: &str) -> Vec<AesCtrTestVector> {
             continue;
         }
         
-        if line.starts_with("COUNT = ") {
+        if let Some(count_str) = line.strip_prefix("COUNT = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract count
-            let count = line[8..].parse::<usize>().unwrap();
+            let count = count_str.parse::<usize>().unwrap();
             
             current_vector = Some(AesCtrTestVector {
                 count,
@@ -107,14 +107,14 @@ fn parse_aes_ctr_test_file(filepath: &str) -> Vec<AesCtrTestVector> {
             });
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("KEY = ") {
-                vector.key = line[6..].to_string();
-            } else if line.starts_with("CTR = ") {
-                vector.ctr = line[6..].to_string();
-            } else if line.starts_with("PLAINTEXT = ") {
-                vector.plaintext = line[12..].to_string();
-            } else if line.starts_with("CIPHERTEXT = ") {
-                vector.ciphertext = line[13..].to_string();
+            if let Some(key_str) = line.strip_prefix("KEY = ") {
+                vector.key = key_str.to_string();
+            } else if let Some(ctr_str) = line.strip_prefix("CTR = ") {
+                vector.ctr = ctr_str.to_string();
+            } else if let Some(plaintext_str) = line.strip_prefix("PLAINTEXT = ") {
+                vector.plaintext = plaintext_str.to_string();
+            } else if let Some(ciphertext_str) = line.strip_prefix("CIPHERTEXT = ") {
+                vector.ciphertext = ciphertext_str.to_string();
             }
         }
     }
@@ -240,15 +240,15 @@ fn run_aes128_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
     for (i, test) in test_vectors.iter().enumerate() {
         // Convert hex strings to bytes
         let key_bytes = hex::decode(&test.key).unwrap_or_else(|_| 
-            panic!("Invalid hex key in test vector {}: {}", i, test.key));
+            panic!("Invalid hex key in test vector {} (COUNT={}): {}", i, test.count, test.key));
         
         let ctr = hex::decode(&test.ctr).unwrap_or_else(|_| 
-            panic!("Invalid hex CTR in test vector {}: {}", i, test.ctr));
+            panic!("Invalid hex CTR in test vector {} (COUNT={}): {}", i, test.count, test.ctr));
         
         // Ensure key has the expected size for AES-128
         assert_eq!(key_bytes.len(), 16, 
-            "Key size mismatch for {} test case {}. Expected: 16, Got: {}",
-            name, i, key_bytes.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 16, Got: {}",
+            name, i, test.count, key_bytes.len());
         
         // Create AES-128 cipher with SecretBytes wrapper
         let key = SecretBytes::<16>::new(key_bytes.try_into().unwrap());
@@ -257,29 +257,29 @@ fn run_aes128_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = process_nist_ctr_aes128(&cipher, &ctr, &plaintext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption (in CTR mode, decryption is the same as encryption)
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = process_nist_ctr_aes128(&cipher, &ctr, &ciphertext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
@@ -291,15 +291,15 @@ fn run_aes192_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
     for (i, test) in test_vectors.iter().enumerate() {
         // Convert hex strings to bytes
         let key_bytes = hex::decode(&test.key).unwrap_or_else(|_| 
-            panic!("Invalid hex key in test vector {}: {}", i, test.key));
+            panic!("Invalid hex key in test vector {} (COUNT={}): {}", i, test.count, test.key));
         
         let ctr = hex::decode(&test.ctr).unwrap_or_else(|_| 
-            panic!("Invalid hex CTR in test vector {}: {}", i, test.ctr));
+            panic!("Invalid hex CTR in test vector {} (COUNT={}): {}", i, test.count, test.ctr));
         
         // Ensure key has the expected size for AES-192
         assert_eq!(key_bytes.len(), 24, 
-            "Key size mismatch for {} test case {}. Expected: 24, Got: {}",
-            name, i, key_bytes.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 24, Got: {}",
+            name, i, test.count, key_bytes.len());
         
         // Create AES-192 cipher with SecretBytes wrapper
         let key = SecretBytes::<24>::new(key_bytes.try_into().unwrap());
@@ -308,29 +308,29 @@ fn run_aes192_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = process_nist_ctr_aes192(&cipher, &ctr, &plaintext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption (in CTR mode, decryption is the same as encryption)
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = process_nist_ctr_aes192(&cipher, &ctr, &ciphertext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
@@ -342,15 +342,15 @@ fn run_aes256_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
     for (i, test) in test_vectors.iter().enumerate() {
         // Convert hex strings to bytes
         let key_bytes = hex::decode(&test.key).unwrap_or_else(|_| 
-            panic!("Invalid hex key in test vector {}: {}", i, test.key));
+            panic!("Invalid hex key in test vector {} (COUNT={}): {}", i, test.count, test.key));
         
         let ctr = hex::decode(&test.ctr).unwrap_or_else(|_| 
-            panic!("Invalid hex CTR in test vector {}: {}", i, test.ctr));
+            panic!("Invalid hex CTR in test vector {} (COUNT={}): {}", i, test.count, test.ctr));
         
         // Ensure key has the expected size for AES-256
         assert_eq!(key_bytes.len(), 32, 
-            "Key size mismatch for {} test case {}. Expected: 32, Got: {}",
-            name, i, key_bytes.len());
+            "Key size mismatch for {} test case {} (COUNT={}). Expected: 32, Got: {}",
+            name, i, test.count, key_bytes.len());
         
         // Create AES-256 cipher with SecretBytes wrapper
         let key = SecretBytes::<32>::new(key_bytes.try_into().unwrap());
@@ -359,29 +359,29 @@ fn run_aes256_ctr_tests(filepath: &str, name: &str, is_encrypt: bool) {
         if is_encrypt {
             // Test encryption
             let plaintext = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let expected = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let result = process_nist_ctr_aes256(&cipher, &ctr, &plaintext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.plaintext, test.ciphertext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.plaintext, test.ciphertext, hex::encode(&result));
         } else {
             // Test decryption (in CTR mode, decryption is the same as encryption)
             let ciphertext = hex::decode(&test.ciphertext).unwrap_or_else(|_| 
-                panic!("Invalid hex ciphertext in test vector {}: {}", i, test.ciphertext));
+                panic!("Invalid hex ciphertext in test vector {} (COUNT={}): {}", i, test.count, test.ciphertext));
             
             let expected = hex::decode(&test.plaintext).unwrap_or_else(|_| 
-                panic!("Invalid hex plaintext in test vector {}: {}", i, test.plaintext));
+                panic!("Invalid hex plaintext in test vector {} (COUNT={}): {}", i, test.count, test.plaintext));
             
             let result = process_nist_ctr_aes256(&cipher, &ctr, &ciphertext);
             
             assert_eq!(result, expected, 
-                "{} test case {} failed.\nInput: {}\nExpected: {}\nGot: {}", 
-                name, i, test.ciphertext, test.plaintext, hex::encode(&result));
+                "{} test case {} (COUNT={}) failed.\nInput: {}\nExpected: {}\nGot: {}", 
+                name, i, test.count, test.ciphertext, test.plaintext, hex::encode(&result));
         }
     }
 }
diff --git a/crates/algorithms/src/ec/p192/tests.rs b/crates/algorithms/src/ec/p192/tests.rs
index b2df9e4..11b2523 100644
--- a/crates/algorithms/src/ec/p192/tests.rs
+++ b/crates/algorithms/src/ec/p192/tests.rs
@@ -621,7 +621,7 @@ mod property_tests {
                         // Then compute both sides of the equation
                         if let (Ok(left), Ok(right)) = (
                             scalar_mult_base_g(&product),
-                            scalar_mult(&a, &b_times_g)
+                            scalar_mult(a, &b_times_g)
                         ) {
                             assert_eq!(left, right);
                         }
diff --git a/crates/algorithms/src/ec/p256/tests.rs b/crates/algorithms/src/ec/p256/tests.rs
index 9d02258..dae49e0 100644
--- a/crates/algorithms/src/ec/p256/tests.rs
+++ b/crates/algorithms/src/ec/p256/tests.rs
@@ -54,8 +54,8 @@ fn test_compression_non_residue() {
     let mut invalid_x = [0u8; P256_POINT_COMPRESSED_SIZE];
     invalid_x[0] = 0x02;
     // Fill with a pattern that's unlikely to be on curve
-    for i in 1..P256_POINT_COMPRESSED_SIZE {
-        invalid_x[i] = 0xFF;
+    for byte in invalid_x.iter_mut().skip(1) {
+        *byte = 0xFF;
     }
     
     let result = Point::deserialize_compressed(&invalid_x);
@@ -491,7 +491,7 @@ fn test_subtraction_edge_cases() {
     let one = FieldElement::one();
     let zero_minus_one = FieldElement::zero().sub(&one);
     // p − 1 in big‐endian bytes:
-    let mut p_minus_one = NIST_P256.p.clone();
+    let mut p_minus_one = NIST_P256.p;
     // subtract 1 from the last byte:
     let last = p_minus_one[31];
     p_minus_one[31] = last.wrapping_sub(1);
@@ -833,7 +833,7 @@ fn step_2_verify_p256_field_one() -> Result<()> {
     
     let one = FieldElement::one();
     let one_bytes = one.to_bytes();
-    println!("P-256 FieldElement::one(): {}", hex::encode(&one_bytes));
+    println!("P-256 FieldElement::one(): {}", hex::encode(one_bytes));
     
     // Should be 0x00...01 (big-endian)
     let mut expected = [0u8; 32];
diff --git a/crates/algorithms/src/ec/p384/tests.rs b/crates/algorithms/src/ec/p384/tests.rs
index 57da729..ef7bca2 100644
--- a/crates/algorithms/src/ec/p384/tests.rs
+++ b/crates/algorithms/src/ec/p384/tests.rs
@@ -104,8 +104,8 @@ fn test_compression_non_residue() {
     let mut invalid_x = [0u8; P384_POINT_COMPRESSED_SIZE];
     invalid_x[0] = 0x02;
     // Fill with a pattern that's unlikely to be on curve
-    for i in 1..P384_POINT_COMPRESSED_SIZE {
-        invalid_x[i] = 0xFF;
+    for byte in invalid_x.iter_mut().skip(1) {
+        *byte = 0xFF;
     }
     
     let result = Point::deserialize_compressed(&invalid_x);
@@ -877,7 +877,7 @@ fn step_2_verify_p384_field_one() -> Result<()> {
     
     let one = FieldElement::one();
     let one_bytes = one.to_bytes();
-    println!("P-384 FieldElement::one(): {}", hex::encode(&one_bytes));
+    println!("P-384 FieldElement::one(): {}", hex::encode(one_bytes));
     
     // Should be 0x00...01 (big-endian)
     let mut expected = [0u8; 48];
diff --git a/crates/algorithms/src/hash/sha2/tests.rs b/crates/algorithms/src/hash/sha2/tests.rs
index e202f7e..120d151 100644
--- a/crates/algorithms/src/hash/sha2/tests.rs
+++ b/crates/algorithms/src/hash/sha2/tests.rs
@@ -146,14 +146,14 @@ fn parse_sha2_test_file(filepath: &str) -> Vec<Sha2TestVector> {
             continue;
         }
         
-        if line.starts_with("Len = ") {
+        if let Some(len_str) = line.strip_prefix("Len = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract bit length
-            let len = line[6..].parse::<usize>().unwrap();
+            let len = len_str.parse::<usize>().unwrap();
             
             current_vector = Some(Sha2TestVector {
                 len,
@@ -162,10 +162,10 @@ fn parse_sha2_test_file(filepath: &str) -> Vec<Sha2TestVector> {
             });
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("Msg = ") {
-                vector.msg = line[6..].to_string();
-            } else if line.starts_with("MD = ") {
-                vector.md = line[5..].to_string();
+            if let Some(msg) = line.strip_prefix("Msg = ") {
+                vector.msg = msg.to_string();
+            } else if let Some(md) = line.strip_prefix("MD = ") {
+                vector.md = md.to_string();
             }
         }
     }
@@ -304,7 +304,7 @@ fn parse_sha2_monte_test_file(filepath: &str) -> Vec<Sha2MonteTestVector> {
             continue;
         }
         
-        if line.starts_with("Seed = ") {
+        if let Some(seed) = line.strip_prefix("Seed = ") {
             // Start of a new test case
             if !current_seed.is_empty() && !current_expected.is_empty() {
                 test_vectors.push(Sha2MonteTestVector {
@@ -314,14 +314,13 @@ fn parse_sha2_monte_test_file(filepath: &str) -> Vec<Sha2MonteTestVector> {
                 });
             }
             
-            current_seed = line[7..].to_string();
+            current_seed = seed.to_string();
             current_expected = String::new();
             count = 0;
-        } else if line.starts_with("COUNT = ") {
-            let count_str = line[8..].trim();
-            count = count_str.parse::<usize>().unwrap_or(0);
+        } else if let Some(count_str) = line.strip_prefix("COUNT = ") {
+            count = count_str.trim().parse::<usize>().unwrap_or(0);
         } else if line.starts_with("MD = ") && count == 1000 { // SHA-2 uses 1000 iterations
-            current_expected = line[5..].to_string();
+            current_expected = line.strip_prefix("MD = ").unwrap().to_string();
         }
     }
     
diff --git a/crates/algorithms/src/hash/sha3/tests.rs b/crates/algorithms/src/hash/sha3/tests.rs
index b3112b6..971b86e 100644
--- a/crates/algorithms/src/hash/sha3/tests.rs
+++ b/crates/algorithms/src/hash/sha3/tests.rs
@@ -75,14 +75,14 @@ fn parse_sha3_test_file(filepath: &str) -> Vec<Sha3TestVector> {
             continue;
         }
         
-        if line.starts_with("Len = ") {
+        if let Some(len_str) = line.strip_prefix("Len = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract bit length
-            let len = line[6..].parse::<usize>().unwrap();
+            let len = len_str.parse::<usize>().unwrap();
             
             current_vector = Some(Sha3TestVector {
                 len,
@@ -91,10 +91,10 @@ fn parse_sha3_test_file(filepath: &str) -> Vec<Sha3TestVector> {
             });
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("Msg = ") {
-                vector.msg = line[6..].to_string();
-            } else if line.starts_with("MD = ") {
-                vector.md = line[5..].to_string();
+            if let Some(msg) = line.strip_prefix("Msg = ") {
+                vector.msg = msg.to_string();
+            } else if let Some(md) = line.strip_prefix("MD = ") {
+                vector.md = md.to_string();
             }
         }
     }
@@ -265,7 +265,7 @@ fn parse_sha3_monte_test_file(filepath: &str) -> Vec<Sha3MonteTestVector> {
             continue;
         }
         
-        if line.starts_with("Seed = ") {
+        if let Some(seed) = line.strip_prefix("Seed = ") {
             // Start of a new test case
             if !current_seed.is_empty() && !current_expected.is_empty() {
                 test_vectors.push(Sha3MonteTestVector {
@@ -275,14 +275,13 @@ fn parse_sha3_monte_test_file(filepath: &str) -> Vec<Sha3MonteTestVector> {
                 });
             }
             
-            current_seed = line[7..].to_string();
+            current_seed = seed.to_string();
             current_expected = String::new();
             count = 0;
-        } else if line.starts_with("COUNT = ") {
-            let count_str = line[8..].trim();
-            count = count_str.parse::<usize>().unwrap_or(0);
+        } else if let Some(count_str) = line.strip_prefix("COUNT = ") {
+            count = count_str.trim().parse::<usize>().unwrap_or(0);
         } else if line.starts_with("MD = ") && count == 100 { // Last iteration
-            current_expected = line[5..].to_string();
+            current_expected = line.strip_prefix("MD = ").unwrap().to_string();
         }
     }
     
diff --git a/crates/algorithms/src/hash/shake/tests.rs b/crates/algorithms/src/hash/shake/tests.rs
index 8f4cf32..140a32d 100644
--- a/crates/algorithms/src/hash/shake/tests.rs
+++ b/crates/algorithms/src/hash/shake/tests.rs
@@ -83,14 +83,14 @@ where
             continue;
         }
         
-        if line.starts_with("Len = ") {
+        if let Some(len_str) = line.strip_prefix("Len = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract bit length
-            let len = line[6..].parse::<usize>().unwrap();
+            let len = len_str.parse::<usize>().unwrap();
             
             current_vector = Some(ShakeTestVector {
                 len,
@@ -98,17 +98,17 @@ where
                 output_len: 0,
                 output: String::new(),
             });
-        } else if line.starts_with("OutLen = ") {
+        } else if let Some(outlen_str) = line.strip_prefix("OutLen = ") {
             // Extract output length in bits
             if let Some(ref mut vector) = current_vector {
-                vector.output_len = line[9..].parse::<usize>().unwrap();
+                vector.output_len = outlen_str.parse::<usize>().unwrap();
             }
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("Msg = ") {
-                vector.msg = line[6..].to_string();
-            } else if line.starts_with("Output = ") {
-                vector.output = line[9..].to_string();
+            if let Some(msg) = line.strip_prefix("Msg = ") {
+                vector.msg = msg.to_string();
+            } else if let Some(output) = line.strip_prefix("Output = ") {
+                vector.output = output.to_string();
                 
                 // If OutLen wasn't specified, derive it from the output hex length
                 if vector.output_len == 0 && !vector.output.is_empty() {
diff --git a/crates/algorithms/src/kdf/argon2/tests.rs b/crates/algorithms/src/kdf/argon2/tests.rs
index 0bc5498..460dd7c 100644
--- a/crates/algorithms/src/kdf/argon2/tests.rs
+++ b/crates/algorithms/src/kdf/argon2/tests.rs
@@ -352,8 +352,8 @@ fn h_prime_final_32_matches_rfc_a1_tag() -> Result<()> {
     // Create a sample 1KB block
     let mut final_block_xor = vec![0u8; ARGON2_BLOCK_SIZE];
     // Fill with a pattern
-    for i in 0..ARGON2_BLOCK_SIZE {
-        final_block_xor[i] = (i % 256) as u8;
+    for (i, byte) in final_block_xor.iter_mut().enumerate() {
+        *byte = (i % 256) as u8;
     }
     
     // Apply h_prime_variable_output
diff --git a/crates/algorithms/src/kdf/hkdf/tests.rs b/crates/algorithms/src/kdf/hkdf/tests.rs
index d99ec71..9c7db75 100644
--- a/crates/algorithms/src/kdf/hkdf/tests.rs
+++ b/crates/algorithms/src/kdf/hkdf/tests.rs
@@ -1,142 +1,139 @@
-#[cfg(test)]
-mod tests {
-    use crate::hash::{HashFunction, Sha256, Sha512};
-    use crate::kdf::Hkdf;
-    use hex;
-    
-    /// Test HKDF implementation against RFC 5869 Test Case 1
-    /// 
-    /// This test verifies the extract and expand functionality separately
-    /// and then together using the first official test vector.
-    #[test]
-    fn test_hkdf_sha256_rfc5869_1() {
-        // Test Case 1 from RFC 5869
-        let ikm = hex::decode("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b").unwrap();
-        let salt = hex::decode("000102030405060708090a0b0c").unwrap();
-        let info = hex::decode("f0f1f2f3f4f5f6f7f8f9").unwrap();
-        let length = 42;
-        
-        // Expected values from the RFC
-        let expected_prk = hex::decode("077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5").unwrap();
-        let expected_okm = hex::decode("3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865").unwrap();
-        
-        // Test extract function
-        let prk = Hkdf::<Sha256>::extract(Some(&salt), &ikm).unwrap();
-        // Compare the underlying bytes
-        assert_eq!(prk.as_slice(), expected_prk.as_slice());
-        
-        // Test expand function
-        let okm = Hkdf::<Sha256>::expand(&prk, Some(&info), length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-        
-        // Test combined derive function
-        let okm = Hkdf::<Sha256>::derive(Some(&salt), &ikm, Some(&info), length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-    }
-    
-    /// Test HKDF implementation against RFC 5869 Test Case 2
-    /// 
-    /// This test verifies the implementation with longer inputs.
-    #[test]
-    fn test_hkdf_sha256_rfc5869_2() {
-        // Test Case 2 from RFC 5869 - uses much longer inputs
-        let ikm = hex::decode("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f").unwrap();
-        let salt = hex::decode("606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf").unwrap();
-        let info = hex::decode("b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff").unwrap();
-        let length = 82;
-        
-        // Expected values from the RFC
-        let expected_prk = hex::decode("06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244").unwrap();
-        let expected_okm = hex::decode("b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71cc30c58179ec3e87c14c01d5c1f3434f1d87").unwrap();
-        
-        // Test extract function
-        let prk = Hkdf::<Sha256>::extract(Some(&salt), &ikm).unwrap();
-        assert_eq!(prk.as_slice(), expected_prk.as_slice());
-        
-        // Test expand function
-        let okm = Hkdf::<Sha256>::expand(&prk, Some(&info), length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-        
-        // Test combined derive function
-        let okm = Hkdf::<Sha256>::derive(Some(&salt), &ikm, Some(&info), length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-    }
-    
-    /// Test HKDF implementation against RFC 5869 Test Case 3
-    /// 
-    /// This test verifies functionality with null salt and info parameters
-    #[test]
-    fn test_hkdf_sha256_rfc5869_3() {
-        // Test Case 3 from RFC 5869 - tests with no salt and no info
-        let ikm = hex::decode("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b").unwrap();
-        let salt = None;   // No salt
-        let info = None;   // No info
-        let length = 42;
-        
-        // Expected values from the RFC
-        let expected_prk = hex::decode("19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04").unwrap();
-        let expected_okm = hex::decode("8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d9d201395faa4b61a96c8").unwrap();
-        
-        // Test extract function
-        let prk = Hkdf::<Sha256>::extract(salt, &ikm).unwrap();
-        assert_eq!(prk.as_slice(), expected_prk.as_slice());
-        
-        // Test expand function
-        let okm = Hkdf::<Sha256>::expand(&prk, info, length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-        
-        // Test combined derive function
-        let okm = Hkdf::<Sha256>::derive(salt, &ikm, info, length).unwrap();
-        assert_eq!(okm.as_slice(), expected_okm.as_slice());
-    }
-    
-    /// Test HKDF with SHA-512 hash function
-    /// 
-    /// This test verifies the implementation works with a different hash function.
-    #[test]
-    fn test_hkdf_sha512() {
-        // Simple test case with SHA-512
-        let ikm = b"input key material";
-        let salt = b"salt";
-        let info = b"context info";
-        let length = 64;
-        
-        // The PRK should be the size of the hash function output
-        let prk = Hkdf::<Sha512>::extract(Some(salt), ikm).unwrap();
-        assert_eq!(prk.len(), Sha512::output_size());
-        
-        // The OKM should be the requested length
-        let okm = Hkdf::<Sha512>::expand(&prk, Some(info), length).unwrap();
-        assert_eq!(okm.len(), length);
-        
-        // Test combined derive function
-        let okm2 = Hkdf::<Sha512>::derive(Some(salt), ikm, Some(info), length).unwrap();
-        assert_eq!(okm.as_slice(), okm2.as_slice());
-    }
-    
-    /// Test HKDF with invalid parameters
-    /// 
-    /// This test verifies error handling for invalid input parameters:
-    /// 1. PRK too short
-    /// 2. Output length too large
-    #[test]
-    fn test_hkdf_invalid_parameters() {
-        use zeroize::Zeroizing;
-        
-        // Test with PRK too short (should be at least HashLen)
-        let short_prk = Zeroizing::new(vec![0; 16]); // Sha256::output_size is 32
-        let info = b"info";
-        let length = 32;
-        
-        let result = Hkdf::<Sha256>::expand(&short_prk, Some(info), length);
-        assert!(result.is_err());
-        
-        // Test with output length too large (should be ≤ 255*HashLen)
-        let prk = Zeroizing::new(vec![0; 32]);
-        let max_length = 255 * Sha256::output_size();
-        let too_large = max_length + 1;
-        
-        let result = Hkdf::<Sha256>::expand(&prk, Some(info), too_large);
-        assert!(result.is_err());
-    }
+use crate::hash::{HashFunction, Sha256, Sha512};
+use crate::kdf::Hkdf;
+use hex;
+
+/// Test HKDF implementation against RFC 5869 Test Case 1
+/// 
+/// This test verifies the extract and expand functionality separately
+/// and then together using the first official test vector.
+#[test]
+fn test_hkdf_sha256_rfc5869_1() {
+    // Test Case 1 from RFC 5869
+    let ikm = hex::decode("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b").unwrap();
+    let salt = hex::decode("000102030405060708090a0b0c").unwrap();
+    let info = hex::decode("f0f1f2f3f4f5f6f7f8f9").unwrap();
+    let length = 42;
+    
+    // Expected values from the RFC
+    let expected_prk = hex::decode("077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5").unwrap();
+    let expected_okm = hex::decode("3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865").unwrap();
+    
+    // Test extract function
+    let prk = Hkdf::<Sha256>::extract(Some(&salt), &ikm).unwrap();
+    // Compare the underlying bytes
+    assert_eq!(prk.as_slice(), expected_prk.as_slice());
+    
+    // Test expand function
+    let okm = Hkdf::<Sha256>::expand(&prk, Some(&info), length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+    
+    // Test combined derive function
+    let okm = Hkdf::<Sha256>::derive(Some(&salt), &ikm, Some(&info), length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+}
+
+/// Test HKDF implementation against RFC 5869 Test Case 2
+/// 
+/// This test verifies the implementation with longer inputs.
+#[test]
+fn test_hkdf_sha256_rfc5869_2() {
+    // Test Case 2 from RFC 5869 - uses much longer inputs
+    let ikm = hex::decode("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f").unwrap();
+    let salt = hex::decode("606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf").unwrap();
+    let info = hex::decode("b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff").unwrap();
+    let length = 82;
+    
+    // Expected values from the RFC
+    let expected_prk = hex::decode("06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244").unwrap();
+    let expected_okm = hex::decode("b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71cc30c58179ec3e87c14c01d5c1f3434f1d87").unwrap();
+    
+    // Test extract function
+    let prk = Hkdf::<Sha256>::extract(Some(&salt), &ikm).unwrap();
+    assert_eq!(prk.as_slice(), expected_prk.as_slice());
+    
+    // Test expand function
+    let okm = Hkdf::<Sha256>::expand(&prk, Some(&info), length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+    
+    // Test combined derive function
+    let okm = Hkdf::<Sha256>::derive(Some(&salt), &ikm, Some(&info), length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+}
+
+/// Test HKDF implementation against RFC 5869 Test Case 3
+/// 
+/// This test verifies functionality with null salt and info parameters
+#[test]
+fn test_hkdf_sha256_rfc5869_3() {
+    // Test Case 3 from RFC 5869 - tests with no salt and no info
+    let ikm = hex::decode("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b").unwrap();
+    let salt = None;   // No salt
+    let info = None;   // No info
+    let length = 42;
+    
+    // Expected values from the RFC
+    let expected_prk = hex::decode("19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04").unwrap();
+    let expected_okm = hex::decode("8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d9d201395faa4b61a96c8").unwrap();
+    
+    // Test extract function
+    let prk = Hkdf::<Sha256>::extract(salt, &ikm).unwrap();
+    assert_eq!(prk.as_slice(), expected_prk.as_slice());
+    
+    // Test expand function
+    let okm = Hkdf::<Sha256>::expand(&prk, info, length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+    
+    // Test combined derive function
+    let okm = Hkdf::<Sha256>::derive(salt, &ikm, info, length).unwrap();
+    assert_eq!(okm.as_slice(), expected_okm.as_slice());
+}
+
+/// Test HKDF with SHA-512 hash function
+/// 
+/// This test verifies the implementation works with a different hash function.
+#[test]
+fn test_hkdf_sha512() {
+    // Simple test case with SHA-512
+    let ikm = b"input key material";
+    let salt = b"salt";
+    let info = b"context info";
+    let length = 64;
+    
+    // The PRK should be the size of the hash function output
+    let prk = Hkdf::<Sha512>::extract(Some(salt), ikm).unwrap();
+    assert_eq!(prk.len(), Sha512::output_size());
+    
+    // The OKM should be the requested length
+    let okm = Hkdf::<Sha512>::expand(&prk, Some(info), length).unwrap();
+    assert_eq!(okm.len(), length);
+    
+    // Test combined derive function
+    let okm2 = Hkdf::<Sha512>::derive(Some(salt), ikm, Some(info), length).unwrap();
+    assert_eq!(okm.as_slice(), okm2.as_slice());
+}
+
+/// Test HKDF with invalid parameters
+/// 
+/// This test verifies error handling for invalid input parameters:
+/// 1. PRK too short
+/// 2. Output length too large
+#[test]
+fn test_hkdf_invalid_parameters() {
+    use zeroize::Zeroizing;
+    
+    // Test with PRK too short (should be at least HashLen)
+    let short_prk = Zeroizing::new(vec![0; 16]); // Sha256::output_size is 32
+    let info = b"info";
+    let length = 32;
+    
+    let result = Hkdf::<Sha256>::expand(&short_prk, Some(info), length);
+    assert!(result.is_err());
+    
+    // Test with output length too large (should be ≤ 255*HashLen)
+    let prk = Zeroizing::new(vec![0; 32]);
+    let max_length = 255 * Sha256::output_size();
+    let too_large = max_length + 1;
+    
+    let result = Hkdf::<Sha256>::expand(&prk, Some(info), too_large);
+    assert!(result.is_err());
 }
\ No newline at end of file
diff --git a/crates/algorithms/src/poly/polynomial.rs b/crates/algorithms/src/poly/polynomial.rs
index 774db2b..66fa635 100644
--- a/crates/algorithms/src/poly/polynomial.rs
+++ b/crates/algorithms/src/poly/polynomial.rs
@@ -316,7 +316,8 @@ mod tests {
     fn test_polynomial_addition() {
         let a = Polynomial::<TestModulus>::from_coeffs(&[1, 2, 3, 4]).unwrap();
         let b = Polynomial::<TestModulus>::from_coeffs(&[5, 6, 7, 8]).unwrap();
-        let c = (&a).add(&b);
+        // Use the + operator directly to avoid explicit borrows
+        let c = a + b;
         assert_eq!(c.as_coeffs_slice(), &[6, 8, 10, 12]);
     }
     
@@ -324,14 +325,16 @@ mod tests {
     fn test_polynomial_subtraction() {
         let a = Polynomial::<TestModulus>::from_coeffs(&[10, 20, 30, 40]).unwrap();
         let b = Polynomial::<TestModulus>::from_coeffs(&[5, 6, 7, 8]).unwrap();
-        let c = (&a).sub(&b);
+        // Use the - operator directly to avoid explicit borrows
+        let c = a - b;
         assert_eq!(c.as_coeffs_slice(), &[5, 14, 23, 32]);
     }
     
     #[test]
     fn test_polynomial_negation() {
         let a = Polynomial::<TestModulus>::from_coeffs(&[1, 2, 0, 4]).unwrap();
-        let neg_a = (&a).neg();
+        // Use the - operator directly to avoid explicit borrows
+        let neg_a = -a;
         assert_eq!(neg_a.as_coeffs_slice(), &[3328, 3327, 0, 3325]);
     }
     
@@ -436,7 +439,7 @@ mod tests {
         sparse.coeffs[0] = 1; // +1
         sparse.coeffs[2] = DilithiumTestModulus::Q - 1; // -1
         
-        let mut dense = Polynomial::<DilithiumTestModulus>::from_coeffs(&[100, 200, 300, 400]).unwrap();
+        let dense = Polynomial::<DilithiumTestModulus>::from_coeffs(&[100, 200, 300, 400]).unwrap();
         let result = sparse.schoolbook_mul(&dense);
         
         // (1 - x^2) * (100 + 200x + 300x^2 + 400x^3)
diff --git a/crates/algorithms/src/xof/blake3/tests.rs b/crates/algorithms/src/xof/blake3/tests.rs
index eec303e..77e0a33 100644
--- a/crates/algorithms/src/xof/blake3/tests.rs
+++ b/crates/algorithms/src/xof/blake3/tests.rs
@@ -61,6 +61,9 @@ fn test_official_test_vectors() {
     let vectors: TestVectors = serde_json::from_str(&contents)
         .expect("Failed to parse test vectors JSON");
     
+    // Print the comment for debugging purposes
+    println!("Test vectors: {}", vectors.comment);
+    
     // Get key and context string as bytes
     let key = vectors.key.as_bytes();
     let context = vectors.context_string.as_bytes();
@@ -74,7 +77,7 @@ fn test_official_test_vectors() {
         let default_len = 32;
         let result = Blake3Xof::generate(&input, default_len).unwrap();
         assert_eq!(
-            hex::encode(&result), 
+            hex::encode(result), 
             &case.hash[..default_len*2], 
             "Default length hash failed for input_len {}", 
             case.input_len
@@ -84,7 +87,7 @@ fn test_official_test_vectors() {
         let extended_len = case.hash.len() / 2;  // Convert hex chars to bytes
         let extended_result = Blake3Xof::generate(&input, extended_len).unwrap();
         assert_eq!(
-            hex::encode(&extended_result), 
+            hex::encode(extended_result), 
             case.hash, 
             "Extended length hash failed for input_len {}", 
             case.input_len
@@ -93,7 +96,7 @@ fn test_official_test_vectors() {
         // Test keyed hash with default and extended lengths
         let keyed_result = Blake3Xof::keyed_generate(key, &input, default_len).unwrap();
         assert_eq!(
-            hex::encode(&keyed_result), 
+            hex::encode(keyed_result), 
             &case.keyed_hash[..default_len*2], 
             "Default length keyed hash failed for input_len {}", 
             case.input_len
@@ -101,7 +104,7 @@ fn test_official_test_vectors() {
         
         let extended_keyed_result = Blake3Xof::keyed_generate(key, &input, extended_len).unwrap();
         assert_eq!(
-            hex::encode(&extended_keyed_result), 
+            hex::encode(extended_keyed_result), 
             case.keyed_hash, 
             "Extended length keyed hash failed for input_len {}", 
             case.input_len
@@ -110,7 +113,7 @@ fn test_official_test_vectors() {
         // Test derive key with default and extended lengths
         let derive_key_result = Blake3Xof::derive_key(context, &input, default_len).unwrap();
         assert_eq!(
-            hex::encode(&derive_key_result), 
+            hex::encode(derive_key_result), 
             &case.derive_key[..default_len*2], 
             "Default length derive key failed for input_len {}", 
             case.input_len
@@ -118,7 +121,7 @@ fn test_official_test_vectors() {
         
         let extended_derive_key_result = Blake3Xof::derive_key(context, &input, extended_len).unwrap();
         assert_eq!(
-            hex::encode(&extended_derive_key_result), 
+            hex::encode(extended_derive_key_result), 
             case.derive_key, 
             "Extended length derive key failed for input_len {}", 
             case.input_len
@@ -131,7 +134,7 @@ fn test_blake3_empty() {
     let expected = "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262";
     
     let result = Blake3Xof::generate(&[], 32).unwrap();
-    assert_eq!(hex::encode(&result), expected);
+    assert_eq!(hex::encode(result), expected);
 }
 
 #[test]
@@ -139,7 +142,7 @@ fn test_blake3_abc() {
     let expected = "6437b3ac38465133ffb63b75273a8db548c558465d79db03fd359c6cd5bd9d85";
     
     let result = Blake3Xof::generate(b"abc", 32).unwrap();
-    assert_eq!(hex::encode(&result), expected);
+    assert_eq!(hex::encode(result), expected);
 }
     
 #[test]
@@ -152,7 +155,7 @@ fn test_blake3_incremental() {
     xof.update(b"c").unwrap();
     
     let result = xof.squeeze_into_vec(32).unwrap();
-    assert_eq!(hex::encode(&result), expected);
+    assert_eq!(hex::encode(result), expected);
 }
 
 #[test]
@@ -163,7 +166,7 @@ fn test_blake3_keyed() {
     let expected = "92b2b75604ed3c761f9d6f62392c8a9227ad0ea3f09573e783f1498a4ed60d26";
     
     let keyed_result = Blake3Xof::keyed_generate(key, input, 32).unwrap();
-    assert_eq!(hex::encode(&keyed_result), expected);
+    assert_eq!(hex::encode(keyed_result), expected);
 }
 
 #[test]
@@ -174,7 +177,7 @@ fn test_blake3_derive_key() {
     let expected = "2cc39783c223154fea8dfb7c1b1660f2ac2dcbd1c1de8277b0b0dd39b7e50d7d";
     
     let derive_key_result = Blake3Xof::derive_key(context, input, 32).unwrap();
-    assert_eq!(hex::encode(&derive_key_result), expected);
+    assert_eq!(hex::encode(derive_key_result), expected);
 }
 
 #[test]
@@ -214,5 +217,5 @@ fn debug_blake3_abc_step_by_step() {
     
     // Step 7: Verify against expected hash
     let expected = "6437b3ac38465133ffb63b75273a8db548c558465d79db03fd359c6cd5bd9d85";
-    assert_eq!(hex::encode(&result), expected);
+    assert_eq!(hex::encode(result), expected);
 }
\ No newline at end of file
diff --git a/crates/algorithms/src/xof/shake/tests.rs b/crates/algorithms/src/xof/shake/tests.rs
index d229cad..1dee94c 100644
--- a/crates/algorithms/src/xof/shake/tests.rs
+++ b/crates/algorithms/src/xof/shake/tests.rs
@@ -50,6 +50,7 @@ fn test_shake_reset() {
     assert!(!xof.squeezing);
 }
 
+#[test]
 fn test_shake128_xof_variable_length() {
     // NIST test vectors for SHAKE-128
     let empty_32_expected = "7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef26";
@@ -237,7 +238,7 @@ fn run_shake_xof_tests<X: ExtendableOutputFunction>(filepath: &str, name: &str)
 
     for (i, test) in test_vectors.iter().enumerate() {
         let bit_len = test.output_len;
-        let output_bytes = (bit_len + 7) / 8;
+        let output_bytes = bit_len.div_ceil(8);
 
         // Skip zero-length outputs
         if bit_len == 0 || test.output.is_empty() {
@@ -378,14 +379,14 @@ fn parse_shake_test_file(filepath: &str) -> Vec<ShakeTestVector> {
         }
         
         // Only parse lines that start with specific keys
-        if line.starts_with("Len = ") {
+        if let Some(stripped) = line.strip_prefix("Len = ") {
             // Start of a new test case
             if let Some(vector) = current_vector.take() {
                 test_vectors.push(vector);
             }
             
             // Extract bit length
-            let len = match line[6..].trim().parse::<usize>() {
+            let len = match stripped.trim().parse::<usize>() {
                 Ok(val) => val,
                 Err(_) => {
                     println!("Warning: Invalid length format in line: {}", line);
@@ -399,10 +400,10 @@ fn parse_shake_test_file(filepath: &str) -> Vec<ShakeTestVector> {
                 output_len: 0,  // Will be set later
                 output: String::new(),
             });
-        } else if line.starts_with("OutLen = ") {
+        } else if let Some(stripped) = line.strip_prefix("OutLen = ") {
             // Extract output length in bits
             if let Some(ref mut vector) = current_vector {
-                vector.output_len = match line[9..].trim().parse::<usize>() {
+                vector.output_len = match stripped.trim().parse::<usize>() {
                     Ok(val) => val,
                     Err(_) => {
                         println!("Warning: Invalid output length format in line: {}", line);
@@ -412,10 +413,10 @@ fn parse_shake_test_file(filepath: &str) -> Vec<ShakeTestVector> {
             }
         } else if let Some(ref mut vector) = current_vector {
             // Parse test vector data
-            if line.starts_with("Msg = ") {
-                vector.msg = line[6..].trim().to_string();
-            } else if line.starts_with("Output = ") {
-                vector.output = line[9..].trim().to_string();
+            if let Some(stripped) = line.strip_prefix("Msg = ") {
+                vector.msg = stripped.trim().to_string();
+            } else if let Some(stripped) = line.strip_prefix("Output = ") {
+                vector.output = stripped.trim().to_string();
                 
                 // If OutLen wasn't specified, derive it from the output hex length
                 if vector.output_len == 0 && !vector.output.is_empty() {
diff --git a/crates/kem/src/ecdh/p256/tests.rs b/crates/kem/src/ecdh/p256/tests.rs
index a93e50a..9cf3a20 100644
--- a/crates/kem/src/ecdh/p256/tests.rs
+++ b/crates/kem/src/ecdh/p256/tests.rs
@@ -4,37 +4,6 @@ use api::Kem;
 use algorithms::ec::p256 as ec_p256;
 use rand::rngs::OsRng;
 
-// Simple hex encoding/decoding utilities
-fn hex_decode(hex: &str) -> Result<Vec<u8>, &'static str> {
-    if hex.len() % 2 != 0 {
-        return Err("Hex string must have even length");
-    }
-    
-    hex.as_bytes()
-        .chunks(2)
-        .map(|chunk| {
-            let high = hex_char_to_nibble(chunk[0])?;
-            let low = hex_char_to_nibble(chunk[1])?;
-            Ok((high << 4) | low)
-        })
-        .collect()
-}
-
-fn hex_char_to_nibble(c: u8) -> Result<u8, &'static str> {
-    match c {
-        b'0'..=b'9' => Ok(c - b'0'),
-        b'a'..=b'f' => Ok(c - b'a' + 10),
-        b'A'..=b'F' => Ok(c - b'A' + 10),
-        _ => Err("Invalid hex character"),
-    }
-}
-
-fn hex_encode(bytes: &[u8]) -> String {
-    bytes.iter()
-        .map(|b| format!("{:02x}", b))
-        .collect()
-}
-
 #[test]
 fn test_p256_kem_basic_flow() {
     let mut rng = OsRng;
diff --git a/crates/kem/src/ecdh/p384/tests.rs b/crates/kem/src/ecdh/p384/tests.rs
index 7ba15eb..db83090 100644
--- a/crates/kem/src/ecdh/p384/tests.rs
+++ b/crates/kem/src/ecdh/p384/tests.rs
@@ -4,37 +4,6 @@ use api::Kem;
 use algorithms::ec::p384;
 use rand::rngs::OsRng;
 
-// Simple hex encoding/decoding utilities
-fn hex_decode(hex: &str) -> Result<Vec<u8>, &'static str> {
-    if hex.len() % 2 != 0 {
-        return Err("Hex string must have even length");
-    }
-    
-    hex.as_bytes()
-        .chunks(2)
-        .map(|chunk| {
-            let high = hex_char_to_nibble(chunk[0])?;
-            let low = hex_char_to_nibble(chunk[1])?;
-            Ok((high << 4) | low)
-        })
-        .collect()
-}
-
-fn hex_char_to_nibble(c: u8) -> Result<u8, &'static str> {
-    match c {
-        b'0'..=b'9' => Ok(c - b'0'),
-        b'a'..=b'f' => Ok(c - b'a' + 10),
-        b'A'..=b'F' => Ok(c - b'A' + 10),
-        _ => Err("Invalid hex character"),
-    }
-}
-
-fn hex_encode(bytes: &[u8]) -> String {
-    bytes.iter()
-        .map(|b| format!("{:02x}", b))
-        .collect()
-}
-
 #[test]
 fn test_p384_kem_basic_flow() {
     let mut rng = OsRng;
diff --git a/crates/kem/src/ecdh/p521/tests.rs b/crates/kem/src/ecdh/p521/tests.rs
index c755bb3..d19a53f 100644
--- a/crates/kem/src/ecdh/p521/tests.rs
+++ b/crates/kem/src/ecdh/p521/tests.rs
@@ -4,37 +4,6 @@ use api::Kem;
 use algorithms::ec::p521;
 use rand::rngs::OsRng;
 
-// Simple hex encoding/decoding utilities
-fn hex_decode(hex: &str) -> Result<Vec<u8>, &'static str> {
-    if hex.len() % 2 != 0 {
-        return Err("Hex string must have even length");
-    }
-    
-    hex.as_bytes()
-        .chunks(2)
-        .map(|chunk| {
-            let high = hex_char_to_nibble(chunk[0])?;
-            let low = hex_char_to_nibble(chunk[1])?;
-            Ok((high << 4) | low)
-        })
-        .collect()
-}
-
-fn hex_char_to_nibble(c: u8) -> Result<u8, &'static str> {
-    match c {
-        b'0'..=b'9' => Ok(c - b'0'),
-        b'a'..=b'f' => Ok(c - b'a' + 10),
-        b'A'..=b'F' => Ok(c - b'A' + 10),
-        _ => Err("Invalid hex character"),
-    }
-}
-
-fn hex_encode(bytes: &[u8]) -> String {
-    bytes.iter()
-        .map(|b| format!("{:02x}", b))
-        .collect()
-}
-
 #[test]
 fn test_p521_kem_basic_flow() {
     let mut rng = OsRng;
diff --git a/crates/kem/src/kyber/ind_cca.rs b/crates/kem/src/kyber/ind_cca.rs
index 9d19539..428adda 100644
--- a/crates/kem/src/kyber/ind_cca.rs
+++ b/crates/kem/src/kyber/ind_cca.rs
@@ -28,7 +28,7 @@ pub(crate) type SharedSecretBytes = Zeroizing<[u8; KYBER_SS_BYTES]>;
 
 // H: SHA3-256
 // Output is 32 bytes (KYBER_SS_BYTES).
-fn H_func(data: &[u8]) -> AlgoResult<[u8; KYBER_SS_BYTES]> {
+fn h_func(data: &[u8]) -> AlgoResult<[u8; KYBER_SS_BYTES]> {
     let mut hasher = Sha3_256::new();
     hasher.update(data)?;
     let digest = hasher.finalize()?;
@@ -39,7 +39,7 @@ fn H_func(data: &[u8]) -> AlgoResult<[u8; KYBER_SS_BYTES]> {
 
 // G: SHA3-512
 // Output is 64 bytes, split into two 32-byte values (K, r).
-fn G_func(data: &[u8]) -> AlgoResult<([u8; KYBER_SS_BYTES], [u8; KYBER_SS_BYTES])> {
+fn g_func(data: &[u8]) -> AlgoResult<([u8; KYBER_SS_BYTES], [u8; KYBER_SS_BYTES])> {
     let mut hasher = Sha3_512::new();
     hasher.update(data)?;
     let digest = hasher.finalize()?;
@@ -68,7 +68,7 @@ pub(crate) fn kem_keygen<P: KyberParams, R: RngCore + CryptoRng>(
     rng.fill_bytes(&mut s_fo);
     
     // 5. H(pk)
-    let h_pk = H_func(&pk_cca_bytes)?;
+    let h_pk = h_func(&pk_cca_bytes)?;
     
     // 6. Construct CCA secret key: sk_cpa || pk || H(pk) || s_fo
     let mut sk_cca_bytes = Vec::with_capacity(P::SECRET_KEY_BYTES);
@@ -93,13 +93,13 @@ pub(crate) fn kem_encaps<P: KyberParams, R: RngCore + CryptoRng>(
     rng.fill_bytes(&mut m_bytes);
     
     // 2. H(pk)
-    let h_pk = H_func(pk_cca_bytes)?;
+    let h_pk = h_func(pk_cca_bytes)?;
     
     // 3. (K_bar, r) = G(m || H(pk))
     let mut g_input = Vec::with_capacity(KYBER_SYMKEY_SEED_BYTES + KYBER_SS_BYTES);
     g_input.extend_from_slice(&m_bytes);
     g_input.extend_from_slice(&h_pk);
-    let (k_bar, r_coins) = G_func(&g_input)?;
+    let (k_bar, r_coins) = g_func(&g_input)?;
     
     // 4. Unpack public key
     let pk_cpa = unpack_pk::<P>(pk_cca_bytes)?;
@@ -111,11 +111,11 @@ pub(crate) fn kem_encaps<P: KyberParams, R: RngCore + CryptoRng>(
     let ct_cca_bytes = pack_ciphertext::<P>(&ct_cpa)?;
     
     // 7. K = H(K_bar || H(ct))
-    let h_ct = H_func(&ct_cca_bytes)?;
+    let h_ct = h_func(&ct_cca_bytes)?;
     let mut k_input = Vec::with_capacity(2 * KYBER_SS_BYTES);
     k_input.extend_from_slice(&k_bar);
     k_input.extend_from_slice(&h_ct);
-    let k = H_func(&k_input)?;
+    let k = h_func(&k_input)?;
     
     // 8. Zeroize sensitive data
     m_bytes.zeroize();
@@ -164,7 +164,7 @@ pub(crate) fn kem_decaps<P: KyberParams>(
     let mut g_input = Vec::with_capacity(KYBER_SYMKEY_SEED_BYTES + KYBER_SS_BYTES);
     g_input.extend_from_slice(m_prime.as_ref());
     g_input.extend_from_slice(h_pk);
-    let (k_bar_prime, r_prime) = G_func(&g_input)?;
+    let (k_bar_prime, r_prime) = g_func(&g_input)?;
     
     // 5. Re-encrypt m' to get ct'
     let pk_cpa = unpack_pk::<P>(pk_bytes)?;
@@ -180,7 +180,7 @@ pub(crate) fn kem_decaps<P: KyberParams>(
     let ct_eq = ct_prime_bytes.ct_eq(ct_cca_bytes);
     
     // 7. H(ct)
-    let h_ct = H_func(ct_cca_bytes)?;
+    let h_ct = h_func(ct_cca_bytes)?;
     
     // 8. Constant-time selection of K_bar' or s_fo
     let mut k_input = Vec::with_capacity(2 * KYBER_SS_BYTES);
@@ -193,7 +193,7 @@ pub(crate) fn kem_decaps<P: KyberParams>(
     k_input.extend_from_slice(&h_ct);
     
     // 9. K = H(selected || H(ct))
-    let k = H_func(&k_input)?;
+    let k = h_func(&k_input)?;
     
     // 10. Zeroize sensitive data
     g_input.zeroize();
diff --git a/crates/kem/src/kyber/tests.rs b/crates/kem/src/kyber/tests.rs
index 97f0e4d..58d8185 100644
--- a/crates/kem/src/kyber/tests.rs
+++ b/crates/kem/src/kyber/tests.rs
@@ -1,163 +1,150 @@
 // kem/src/kyber/tests.rs
 
 #[cfg(test)]
-mod tests {
-    use crate::kyber::{Kyber512, Kyber768, Kyber1024};
-    use crate::kyber::params::KYBER_SS_BYTES;
-    use api::Kem;
-    use rand::SeedableRng;
-    use rand_chacha::ChaChaRng;
-
-    #[test]
-    fn test_kyber512_keygen() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        let result = Kyber512::keypair(&mut rng);
-        assert!(result.is_ok());
-        
-        let (pk, sk) = result.unwrap();
-        assert_eq!(pk.as_ref().len(), 800);  // Kyber512 public key size
-        assert_eq!(sk.as_ref().len(), 1632); // Kyber512 secret key size
-    }
+use crate::kyber::{Kyber512, Kyber768, Kyber1024};
+#[cfg(test)]
+use crate::kyber::params::KYBER_SS_BYTES;
+#[cfg(test)]
+use api::Kem;
+#[cfg(test)]
+use rand::SeedableRng;
+#[cfg(test)]
+use rand_chacha::ChaChaRng;
 
-    #[test]
-    fn test_kyber768_keygen() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        let result = Kyber768::keypair(&mut rng);
-        assert!(result.is_ok());
-        
-        let (pk, sk) = result.unwrap();
-        assert_eq!(pk.as_ref().len(), 1184); // Kyber768 public key size
-        assert_eq!(sk.as_ref().len(), 2400); // Kyber768 secret key size
-    }
+#[test]
+fn test_kyber512_keygen() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    let result = Kyber512::keypair(&mut rng);
+    assert!(result.is_ok());
+    
+    let (pk, sk) = result.unwrap();
+    assert_eq!(pk.as_ref().len(), 800);  // Kyber512 public key size
+    assert_eq!(sk.as_ref().len(), 1632); // Kyber512 secret key size
+}
 
-    #[test]
-    fn test_kyber1024_keygen() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        let result = Kyber1024::keypair(&mut rng);
-        assert!(result.is_ok());
-        
-        let (pk, sk) = result.unwrap();
-        assert_eq!(pk.as_ref().len(), 1568); // Kyber1024 public key size
-        assert_eq!(sk.as_ref().len(), 3168); // Kyber1024 secret key size
-    }
+#[test]
+fn test_kyber768_keygen() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    let result = Kyber768::keypair(&mut rng);
+    assert!(result.is_ok());
+    
+    let (pk, sk) = result.unwrap();
+    assert_eq!(pk.as_ref().len(), 1184); // Kyber768 public key size
+    assert_eq!(sk.as_ref().len(), 2400); // Kyber768 secret key size
+}
 
-    #[test]
-    fn test_kyber512_encaps_decaps() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        
-        // Generate keypair
-        let (pk, sk) = Kyber512::keypair(&mut rng).unwrap();
-        
-        // Encapsulate
-        let (ct, ss1) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
-        assert_eq!(ct.as_ref().len(), 768); // Kyber512 ciphertext size
-        assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);  // Shared secret size
-        
-        // Decapsulate
-        let ss2 = Kyber512::decapsulate(&sk, &ct).unwrap();
-        assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
-        
-        // Shared secrets should match
-        assert_eq!(ss1.as_ref(), ss2.as_ref());
-    }
+#[test]
+fn test_kyber1024_keygen() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    let result = Kyber1024::keypair(&mut rng);
+    assert!(result.is_ok());
+    
+    let (pk, sk) = result.unwrap();
+    assert_eq!(pk.as_ref().len(), 1568); // Kyber1024 public key size
+    assert_eq!(sk.as_ref().len(), 3168); // Kyber1024 secret key size
+}
 
-    #[test]
-    fn test_kyber768_encaps_decaps() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        
-        // Generate keypair
-        let (pk, sk) = Kyber768::keypair(&mut rng).unwrap();
-        
-        // Encapsulate
-        let (ct, ss1) = Kyber768::encapsulate(&mut rng, &pk).unwrap();
-        assert_eq!(ct.as_ref().len(), 1088); // Kyber768 ciphertext size
-        assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);   // Shared secret size
-        
-        // Decapsulate
-        let ss2 = Kyber768::decapsulate(&sk, &ct).unwrap();
-        assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
-        
-        // Shared secrets should match
-        assert_eq!(ss1.as_ref(), ss2.as_ref());
-    }
+#[test]
+fn test_kyber512_encaps_decaps() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    
+    // Generate keypair
+    let (pk, sk) = Kyber512::keypair(&mut rng).unwrap();
+    
+    // Encapsulate
+    let (ct, ss1) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
+    assert_eq!(ct.as_ref().len(), 768); // Kyber512 ciphertext size
+    assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);  // Shared secret size
+    
+    // Decapsulate
+    let ss2 = Kyber512::decapsulate(&sk, &ct).unwrap();
+    assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
+    
+    // Shared secrets should match
+    assert_eq!(ss1.as_ref(), ss2.as_ref());
+}
 
-    #[test]
-    fn test_kyber1024_encaps_decaps() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        
-        // Generate keypair
-        let (pk, sk) = Kyber1024::keypair(&mut rng).unwrap();
-        
-        // Encapsulate
-        let (ct, ss1) = Kyber1024::encapsulate(&mut rng, &pk).unwrap();
-        assert_eq!(ct.as_ref().len(), 1568); // Kyber1024 ciphertext size
-        assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);   // Shared secret size
-        
-        // Decapsulate
-        let ss2 = Kyber1024::decapsulate(&sk, &ct).unwrap();
-        assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
-        
-        // Shared secrets should match
-        assert_eq!(ss1.as_ref(), ss2.as_ref());
-    }
+#[test]
+fn test_kyber768_encaps_decaps() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    
+    // Generate keypair
+    let (pk, sk) = Kyber768::keypair(&mut rng).unwrap();
+    
+    // Encapsulate
+    let (ct, ss1) = Kyber768::encapsulate(&mut rng, &pk).unwrap();
+    assert_eq!(ct.as_ref().len(), 1088); // Kyber768 ciphertext size
+    assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);   // Shared secret size
+    
+    // Decapsulate
+    let ss2 = Kyber768::decapsulate(&sk, &ct).unwrap();
+    assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
+    
+    // Shared secrets should match
+    assert_eq!(ss1.as_ref(), ss2.as_ref());
+}
 
-    #[test]
-    fn test_invalid_ciphertext() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        
-        // Generate keypair
-        let (pk, sk) = Kyber512::keypair(&mut rng).unwrap();
-        
-        // Create valid ciphertext
-        let (mut ct, _) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
-        
-        // Corrupt the ciphertext
-        ct.as_mut()[0] ^= 0xFF;
-        
-        // Decapsulation should still succeed (IND-CCA2)
-        let result = Kyber512::decapsulate(&sk, &ct);
-        assert!(result.is_ok());
-        
-        // But the shared secret will be different (implicitly)
-    }
+#[test]
+fn test_kyber1024_encaps_decaps() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    
+    // Generate keypair
+    let (pk, sk) = Kyber1024::keypair(&mut rng).unwrap();
+    
+    // Encapsulate
+    let (ct, ss1) = Kyber1024::encapsulate(&mut rng, &pk).unwrap();
+    assert_eq!(ct.as_ref().len(), 1568); // Kyber1024 ciphertext size
+    assert_eq!(ss1.as_ref().len(), KYBER_SS_BYTES);   // Shared secret size
+    
+    // Decapsulate
+    let ss2 = Kyber1024::decapsulate(&sk, &ct).unwrap();
+    assert_eq!(ss2.as_ref().len(), KYBER_SS_BYTES);
+    
+    // Shared secrets should match
+    assert_eq!(ss1.as_ref(), ss2.as_ref());
+}
 
-    #[test]
-    fn test_wrong_key_sizes() {
-        let mut rng = ChaChaRng::seed_from_u64(42);
-        
-        // Create keys with wrong sizes using the public new methods
-        let bad_pk = crate::kyber::KyberPublicKey::new(vec![0u8; 100]); // Wrong size
-        let bad_sk = crate::kyber::KyberSecretKey::new(vec![0u8; 100]); // Wrong size
-        let bad_ct = crate::kyber::KyberCiphertext::new(vec![0u8; 100]); // Wrong size
-        
-        // Encapsulation with wrong-sized public key should fail
-        let result = Kyber512::encapsulate(&mut rng, &bad_pk);
-        assert!(result.is_err());
-        
-        // Decapsulation with wrong-sized secret key should fail
-        let (pk, _) = Kyber512::keypair(&mut rng).unwrap();
-        let (ct, _) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
-        let result = Kyber512::decapsulate(&bad_sk, &ct);
-        assert!(result.is_err());
-        
-        // Decapsulation with wrong-sized ciphertext should fail
-        let (_, sk) = Kyber512::keypair(&mut rng).unwrap();
-        let result = Kyber512::decapsulate(&sk, &bad_ct);
-        assert!(result.is_err());
-    }
+#[test]
+fn test_invalid_ciphertext() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    
+    // Generate keypair
+    let (pk, sk) = Kyber512::keypair(&mut rng).unwrap();
+    
+    // Create valid ciphertext
+    let (mut ct, _) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
+    
+    // Corrupt the ciphertext
+    ct.as_mut()[0] ^= 0xFF;
+    
+    // Decapsulation should still succeed (IND-CCA2)
+    let result = Kyber512::decapsulate(&sk, &ct);
+    assert!(result.is_ok());
+    
+    // But the shared secret will be different (implicitly)
+}
 
-    // Test vectors from NIST (simplified - in production use full KAT vectors)
-    #[test]
-    fn test_kyber512_kat_simple() {
-        // This is a simplified test - in production, use full NIST KAT vectors
-        let seed = [0u8; 48]; // d || z from KAT
-        let mut rng = ChaChaRng::from_seed([0u8; 32]);
-        
-        // Generate deterministic keypair
-        let (pk, sk) = Kyber512::keypair(&mut rng).unwrap();
-        
-        // Verify key sizes
-        assert_eq!(pk.as_ref().len(), 800);
-        assert_eq!(sk.as_ref().len(), 1632);
-    }
+#[test]
+fn test_wrong_key_sizes() {
+    let mut rng = ChaChaRng::seed_from_u64(42);
+    
+    // Create keys with wrong sizes using the public new methods
+    let bad_pk = crate::kyber::KyberPublicKey::new(vec![0u8; 100]); // Wrong size
+    let bad_sk = crate::kyber::KyberSecretKey::new(vec![0u8; 100]); // Wrong size
+    let bad_ct = crate::kyber::KyberCiphertext::new(vec![0u8; 100]); // Wrong size
+    
+    // Encapsulation with wrong-sized public key should fail
+    let result = Kyber512::encapsulate(&mut rng, &bad_pk);
+    assert!(result.is_err());
+    
+    // Decapsulation with wrong-sized secret key should fail
+    let (pk, _) = Kyber512::keypair(&mut rng).unwrap();
+    let (ct, _) = Kyber512::encapsulate(&mut rng, &pk).unwrap();
+    let result = Kyber512::decapsulate(&bad_sk, &ct);
+    assert!(result.is_err());
+    
+    // Decapsulation with wrong-sized ciphertext should fail
+    let (_, sk) = Kyber512::keypair(&mut rng).unwrap();
+    let result = Kyber512::decapsulate(&sk, &bad_ct);
+    assert!(result.is_err());
 }
\ No newline at end of file
diff --git a/crates/sign/src/error.rs b/crates/sign/src/error.rs
index ae2bb00..e5c616f 100644
--- a/crates/sign/src/error.rs
+++ b/crates/sign/src/error.rs
@@ -119,71 +119,71 @@ impl From<Error> for api::Error {
         match err {
             // Map Algorithm error to InvalidParameter with context
             Error::Algorithm(alg) => api::Error::InvalidParameter {
-                context: "algorithm".into(),
+                context: "algorithm",
                 message: format!("Unsupported algorithm: {}", alg),
             },
             Error::InvalidKeySize { expected, actual } => api::Error::InvalidKey {
-                context: "sign".into(),
+                context: "sign",
                 message: format!("Invalid key size: expected {}, got {}", expected, actual),
             },
             Error::InvalidSignatureSize { expected, actual } => api::Error::InvalidSignature {
-                context: "sign".into(),
+                context: "sign",
                 message: format!("Invalid signature size: expected {}, got {}", expected, actual),
             },
             Error::InvalidParameter(msg) => api::Error::InvalidParameter {
-                context: "sign".into(),
+                context: "sign",
                 message: msg,
             },
             Error::InvalidKey(msg) => api::Error::InvalidKey {
-                context: "sign".into(),
+                context: "sign",
                 message: msg,
             },
             // Map KeyGeneration to InvalidKey (key generation failures produce invalid keys)
             Error::KeyGeneration { algorithm, details } => api::Error::InvalidKey {
-                context: algorithm.into(),
+                context: algorithm,
                 message: format!("Key generation failed: {}", details),
             },
             // Map SignatureGeneration to InvalidSignature
             Error::SignatureGeneration { algorithm, details } => api::Error::InvalidSignature {
-                context: algorithm.into(),
+                context: algorithm,
                 message: format!("Signature generation failed: {}", details),
             },
             Error::Verification { algorithm, details } => api::Error::InvalidSignature {
-                context: algorithm.into(),
+                context: algorithm,
                 message: details,
             },
             Error::Encoding(s) => api::Error::InvalidParameter {
-                context: "encoding".into(),
+                context: "encoding",
                 message: s,
             },
             Error::Deserialization(s) => api::Error::InvalidParameter {
-                context: "deserialization".into(),
+                context: "deserialization",
                 message: s,
             },
             Error::Serialization(s) => api::Error::InvalidParameter {
-                context: "serialization".into(),
+                context: "serialization",
                 message: s,
             },
             Error::Nonce(s) => api::Error::InvalidParameter {
-                context: "nonce".into(),
+                context: "nonce",
                 message: s,
             },
             // Map internal errors (Hashing, Rng, Sampling, Internal) to InvalidParameter
             // This isn't ideal but without an Internal variant in api::Error, this is the best mapping
             Error::Hashing(s) => api::Error::InvalidParameter {
-                context: "hashing".into(),
+                context: "hashing",
                 message: s,
             },
             Error::Rng(s) => api::Error::InvalidParameter {
-                context: "rng".into(),
+                context: "rng",
                 message: s,
             },
             Error::Sampling(s) => api::Error::InvalidParameter {
-                context: "sampling".into(),
+                context: "sampling",
                 message: s,
             },
             Error::Internal(s) => api::Error::InvalidParameter {
-                context: "internal".into(),
+                context: "internal",
                 message: s,
             },
         }
diff --git a/crates/sign/src/pq/dilithium/arithmetic.rs b/crates/sign/src/pq/dilithium/arithmetic.rs
index 5c8fed2..6378dd4 100644
--- a/crates/sign/src/pq/dilithium/arithmetic.rs
+++ b/crates/sign/src/pq/dilithium/arithmetic.rs
@@ -133,7 +133,7 @@ pub fn power2round(r: u32, d: u32) -> (i32, u32) {
     let half = 1 << (d - 1);
 
     // round-to-nearest, **ties to negative**
-    let mut r1 = ((r_plus + half) >> d) as u32;
+    let mut r1 = (r_plus + half) >> d;
     let mut r0 = r_plus as i32 - (r1 as i32) * (1 << d);
 
     // canonical representation of q-1
@@ -201,7 +201,7 @@ pub fn lowbits(r_coeff: u32, alpha: u32) -> i32 {
 /// Note: Earlier drafts truncated/shifted these values, but FIPS 204 final
 /// specifies that w1 encoding returns r1 directly (identity function).
 #[inline]
-pub fn w1_encode_gamma<P: DilithiumSchemeParams>(r1_gamma: u32) -> u32 {
+pub fn w1_encode_gamma(r1_gamma: u32) -> u32 {
     // FIPS 204 final: return the full r1 value
     r1_gamma
 }
@@ -233,8 +233,8 @@ pub fn w1_bits_needed<P: DilithiumSchemeParams>() -> u32 {
 pub fn use_hint_coeff<P: DilithiumSchemeParams>(
     hint_bit: bool,
     r_coeff: u32,
-    gamma2: u32,
 ) -> u32 {
+    let gamma2 = P::GAMMA2_PARAM;
     let alpha = 2 * gamma2;
     let m = buckets(alpha, gamma2);
     
@@ -260,7 +260,7 @@ pub fn use_hint_coeff<P: DilithiumSchemeParams>(
 
 /// Checks if the infinity norm of a polynomial is at most `bound`.
 /// Coefficients are centered in (-Q/2, Q/2]
-pub fn check_norm_poly<P: DilithiumSchemeParams>(
+pub fn check_norm_poly(
     poly: &Polynomial<DilithiumParams>, 
     bound: u32
 ) -> bool {
@@ -285,7 +285,7 @@ pub fn check_norm_polyvec_l<P: DilithiumSchemeParams>(
     pv: &PolyVecL<P>, 
     bound: u32
 ) -> bool {
-    pv.polys.iter().all(|p| check_norm_poly::<P>(p, bound))
+    pv.polys.iter().all(|p| check_norm_poly(p, bound))
 }
 
 /// Checks if the infinity norm of all polynomials in a PolyVecK is at most `bound`.
@@ -293,7 +293,7 @@ pub fn check_norm_polyvec_k<P: DilithiumSchemeParams>(
     pv: &PolyVecK<P>, 
     bound: u32
 ) -> bool {
-    pv.polys.iter().all(|p| check_norm_poly::<P>(p, bound))
+    pv.polys.iter().all(|p| check_norm_poly(p, bound))
 }
 
 /// Applies `Power2Round` element-wise to a PolyVecK.
@@ -430,10 +430,10 @@ pub fn use_hint_polyveck<P: DilithiumSchemeParams>(
             let w_prime_coeff = w_prime_polyvec.polys[i].coeffs[j];
             
             // Apply UseHint to get the corrected γ-bucket index
-            let r1_prime = use_hint_coeff::<P>(hint_bit, w_prime_coeff, P::GAMMA2_PARAM);
+            let r1_prime = use_hint_coeff::<P>(hint_bit, w_prime_coeff);
             
             // FIPS 204 final: store the full gamma-bucket index
-            corrected_pv.polys[i].coeffs[j] = w1_encode_gamma::<P>(r1_prime);
+            corrected_pv.polys[i].coeffs[j] = w1_encode_gamma(r1_prime);
         }
     }
     
diff --git a/crates/sign/src/pq/dilithium/encoding.rs b/crates/sign/src/pq/dilithium/encoding.rs
index 96ad534..ea7122d 100644
--- a/crates/sign/src/pq/dilithium/encoding.rs
+++ b/crates/sign/src/pq/dilithium/encoding.rs
@@ -23,8 +23,8 @@ use crate::error::{Error as SignError};
 /// Packs the hint vector *h* using the final FIPS‑204 "HintBitPack" layout:
 ///   * first ω bytes  — coefficient indices (0‑255), padded with zeros to exactly ω bytes
 ///   * then   K bytes — per‑polynomial counters (number of indices that belong
-///                      to each row).  The total number of 1‑bits MUST equal
-///                      the sum of the counters and be ≤ ω.
+///     to each row).  The total number of 1‑bits MUST equal
+///     the sum of the counters and be ≤ ω.
 /// 
 /// FIPS 204 §4.2 requires the output to be EXACTLY ω + K bytes, hence the padding.
 /// 
@@ -259,18 +259,21 @@ pub fn pack_secret_key<P: DilithiumSchemeParams>(
     Ok(sk_bytes)
 }
 
-/// Unpacks secret key from bytes according to Algorithm 16.
-/// NIST Round 3 includes 32 bytes of padding at the end.
-pub fn unpack_secret_key<P: DilithiumSchemeParams>(
-    sk_bytes: &[u8],
-) -> Result<(
+/// Type alias for the complex return type of unpack_secret_key
+pub type UnpackedSecretKey<P> = (
     [u8; 32], // rho
     [u8; 32], // k
     [u8; 32], // tr
     PolyVecL<P>,
     PolyVecK<P>,
     PolyVecK<P>,
-), SignError> {
+);
+
+/// Unpacks secret key from bytes according to Algorithm 16.
+/// NIST Round 3 includes 32 bytes of padding at the end.
+pub fn unpack_secret_key<P: DilithiumSchemeParams>(
+    sk_bytes: &[u8],
+) -> Result<UnpackedSecretKey<P>, SignError> {
     if sk_bytes.len() != P::SECRET_KEY_BYTES {
         return Err(SignError::Deserialization(format!(
             "Secret key size mismatch: expected {}, got {}", 
@@ -343,7 +346,7 @@ pub fn unpack_secret_key<P: DilithiumSchemeParams>(
         let mut temp_poly = DefaultCoefficientSerde::unpack_coeffs(poly_bytes, P::D_PARAM as usize)
             .map_err(SignError::from_algo)?;
         for c in temp_poly.coeffs.iter_mut() {
-            let signed = (*c as i32) - (t0_offset as i32);
+            let signed = (*c as i32) - t0_offset;
             // Keep t₀ centered using proper modular arithmetic
             *c = ((signed + DILITHIUM_Q as i32) % DILITHIUM_Q as i32) as u32;
         }
@@ -434,8 +437,8 @@ pub fn pack_polyveck_w1<P: DilithiumSchemeParams>(
     // - Dilithium2: 6 bits for r1 ∈ [0,44]
     // - Dilithium3/5: 5 bits for r1 ∈ [0,16]
     let bits_per_coeff = w1_bits_needed::<P>();
-    let total_bits = P::K_DIM as usize * DILITHIUM_N * bits_per_coeff as usize;
-    let total_bytes = (total_bits + 7) / 8;  // Round up to nearest byte
+    let total_bits = P::K_DIM * DILITHIUM_N * bits_per_coeff as usize;
+    let total_bytes = total_bits.div_ceil(8);
     let mut packed = vec![0u8; total_bytes];
     
     // Pack coefficients MSB-first as per FIPS 204 Algorithm 28
@@ -456,11 +459,14 @@ pub fn pack_polyveck_w1<P: DilithiumSchemeParams>(
     Ok(packed)
 }
 
+/// Type alias for the complex return type of unpack_signature
+pub type UnpackedSignature<P> = (Vec<u8>, PolyVecL<P>, PolyVecK<P>);
+
 /// Unpacks signature from bytes according to FIPS 204 Algorithm 18 with variable challenge size
 /// Uses Z_BITS instead of GAMMA1_BITS for unpacking z coefficients
 pub fn unpack_signature<P: DilithiumSchemeParams>(
     sig_bytes: &[u8],
-) -> Result<(Vec<u8>, PolyVecL<P>, PolyVecK<P>), SignError> {
+) -> Result<UnpackedSignature<P>, SignError> {
     if sig_bytes.len() != P::SIGNATURE_SIZE {
         return Err(SignError::Deserialization(format!(
             "Signature size mismatch: expected {}, got {}", 
diff --git a/crates/sign/src/pq/dilithium/mod.rs b/crates/sign/src/pq/dilithium/mod.rs
index c56cbed..c9caae9 100644
--- a/crates/sign/src/pq/dilithium/mod.rs
+++ b/crates/sign/src/pq/dilithium/mod.rs
@@ -50,7 +50,7 @@ use params::pqc::dilithium::{Dilithium2Params, Dilithium3Params, Dilithium5Param
 /// Stores the packed representation of `(rho, t1)`.
 /// - `rho`: A 32-byte seed used to deterministically generate the matrix A.
 /// - `t1`: A vector of K polynomials, where each coefficient is the high-order bits
-///         of `t_i = (A*s1)_i + (s2)_i`. Packed according to `P::D_PARAM` bits.
+///   of `t_i = (A*s1)_i + (s2)_i`. Packed according to `P::D_PARAM` bits.
 #[derive(Clone, Debug, Zeroize)]
 pub struct DilithiumPublicKey(pub(crate) Vec<u8>);
 
@@ -59,12 +59,12 @@ pub struct DilithiumPublicKey(pub(crate) Vec<u8>);
 /// Stores the packed representation of `(rho, K, tr, s1, s2, t0)`.
 /// - `rho`: Seed for matrix A (same as in public key).
 /// - `K`: A 32-byte seed used for sampling the masking vector `y` and as part of the
-///        PRF input for generating the challenge `c`.
+///   PRF input for generating the challenge `c`.
 /// - `tr`: A 32-byte hash of the packed public key, used for domain separation in challenge generation.
 /// - `s1`, `s2`: Secret polynomial vectors with small coefficients (norm bounded by `eta`).
-///               Packed according to `P::ETA_S1S2` bits.
+///   Packed according to `P::ETA_S1S2` bits.
 /// - `t0`: A vector of K polynomials representing the low-order bits of `t = A*s1 + s2`.
-///         Coefficients are in `(-2^(d-1), 2^(d-1)]` and packed accordingly.
+///   Coefficients are in `(-2^(d-1), 2^(d-1)]` and packed accordingly.
 #[derive(Clone, Debug, Zeroize, ZeroizeOnDrop)]
 pub struct DilithiumSecretKey(pub(crate) Vec<u8>);
 
@@ -72,11 +72,11 @@ pub struct DilithiumSecretKey(pub(crate) Vec<u8>);
 ///
 /// Stores the packed representation of `(c_tilde, z, h)`.
 /// - `c_tilde`: A short (32-byte) seed from which the challenge polynomial `c` (with `tau` non-zero
-///              coefficients) is derived.
+///   coefficients) is derived.
 /// - `z`: A vector of L polynomials, `z = y + c*s1`. Its coefficients must be within
-///        `[-gamma1 + beta, gamma1 - beta]`. Packed based on this range.
+///   `[-gamma1 + beta, gamma1 - beta]`. Packed based on this range.
 /// - `h`: A hint vector (PolyVecK of 0s/1s) indicating which coefficients of `w1_prime - c*t0`
-///        required correction during verification using `UseHint`. Packed efficiently.
+///   required correction during verification using `UseHint`. Packed efficiently.
 #[derive(Clone, Debug)]
 pub struct DilithiumSignatureData(pub(crate) Vec<u8>);
 
@@ -108,7 +108,7 @@ impl<P: DilithiumSchemeParams + Send + Sync + 'static> SignatureTrait for Dilith
 
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
         let (pk_bytes, sk_bytes) = sign::keypair_internal::<P, R>(rng)
-            .map_err(|e| api::Error::from(e))?;
+            .map_err(api::Error::from)?;
         Ok((DilithiumPublicKey(pk_bytes), DilithiumSecretKey(sk_bytes)))
     }
 
@@ -126,13 +126,13 @@ impl<P: DilithiumSchemeParams + Send + Sync + 'static> SignatureTrait for Dilith
         // or if a future variant required it, but standard Dilithium does not.
         let mut rng = rand::rngs::OsRng;
         let sig_bytes = sign::sign_internal::<P, _>(message, &secret_key.0, &mut rng)
-            .map_err(|e| api::Error::from(e))?;
+            .map_err(api::Error::from)?;
         Ok(DilithiumSignatureData(sig_bytes))
     }
 
     fn verify(message: &[u8], signature: &Self::SignatureData, public_key: &Self::PublicKey) -> ApiResult<()> {
         sign::verify_internal::<P>(message, &signature.0, &public_key.0)
-            .map_err(|e| api::Error::from(e))
+            .map_err(api::Error::from)
     }
 }
 
diff --git a/crates/sign/src/pq/dilithium/polyvec.rs b/crates/sign/src/pq/dilithium/polyvec.rs
index c902bd6..bcadd7e 100644
--- a/crates/sign/src/pq/dilithium/polyvec.rs
+++ b/crates/sign/src/pq/dilithium/polyvec.rs
@@ -205,7 +205,7 @@ pub fn expand_matrix_a<P: DilithiumSchemeParams>(
                 xof.squeeze(&mut temp_buf).map_err(SignError::from_algo)?;
                 // Extract two 12-bit values from 3 bytes
                 let d1 = (temp_buf[0] as u32) | (((temp_buf[1] as u32) & 0x0F) << 8);
-                let d2 = (((temp_buf[1] as u32) >> 4) | ((temp_buf[2] as u32) << 4)) as u32;
+                let d2 = ((temp_buf[1] as u32) >> 4) | ((temp_buf[2] as u32) << 4);
 
                 if d1 < DilithiumParams::Q {
                     poly.coeffs[ctr] = d1;
diff --git a/crates/sign/src/pq/dilithium/sampling.rs b/crates/sign/src/pq/dilithium/sampling.rs
index ba40dc0..1b8bb2f 100644
--- a/crates/sign/src/pq/dilithium/sampling.rs
+++ b/crates/sign/src/pq/dilithium/sampling.rs
@@ -10,6 +10,7 @@ use crate::error::{Error as SignError};
 
 /// Samples a polynomial with coefficients from CBD_eta (Algorithm 22).
 /// Uses SHAKE256(seed || nonce) as randomness source.
+#[allow(clippy::extra_unused_type_parameters)]
 pub fn sample_poly_cbd_eta<P: DilithiumSchemeParams>(
     seed: &[u8; 32], // SEED_KEY_BYTES is always 32
     nonce: u8,
@@ -46,8 +47,8 @@ pub fn sample_poly_cbd_eta<P: DilithiumSchemeParams>(
         xof.squeeze(&mut buf).map_err(SignError::from_algo)?;
         
         let mut poly = Polynomial::<DilithiumParams>::zero();
-        for i in 0..DilithiumParams::N {
-            let t = buf[i] as u32;
+        for (i, &byte) in buf.iter().enumerate().take(DilithiumParams::N) {
+            let t = byte as u32;
             let a = (t & 0x0F).count_ones();
             let b = (t >> 4).count_ones();
             poly.coeffs[i] = ((a as i32 - b as i32) as i64).rem_euclid(DilithiumParams::Q as i64) as u32;
@@ -55,7 +56,7 @@ pub fn sample_poly_cbd_eta<P: DilithiumSchemeParams>(
         Ok(poly)
     } else {
         // General case for other eta values
-        let bytes_needed = (DilithiumParams::N * 2 * eta as usize + 7) / 8;
+        let bytes_needed = (DilithiumParams::N * 2 * eta as usize).div_ceil(8);
         let mut buf = vec![0u8; bytes_needed];
         xof.squeeze(&mut buf).map_err(SignError::from_algo)?;
 
@@ -216,6 +217,7 @@ pub fn sample_polyvecl_uniform_gamma1<P: DilithiumSchemeParams>(
 /// Samples challenge polynomial c with τ nonzero coefficients (Algorithm 8).
 /// Uses SHAKE256(c_tilde_seed) as randomness source.
 /// Accepts variable-sized challenge seeds (32/48/64 bytes)
+#[allow(clippy::extra_unused_type_parameters)]
 pub fn sample_challenge_c<P: DilithiumSchemeParams>(
     c_tilde_seed: &[u8], // Variable size: 32/48/64 bytes
     tau: u32,
@@ -232,7 +234,7 @@ pub fn sample_challenge_c<P: DilithiumSchemeParams>(
     xof.update(c_tilde_seed).map_err(SignError::from_algo)?;
     
     // First, squeeze sign bits (τ bits packed into bytes)
-    let sign_bytes = (tau + 7) / 8;
+    let sign_bytes = tau.div_ceil(8);
     let mut signs = vec![0u8; sign_bytes as usize];
     xof.squeeze(&mut signs).map_err(SignError::from_algo)?;
     
diff --git a/crates/sign/src/pq/dilithium/sign.rs b/crates/sign/src/pq/dilithium/sign.rs
index 5b96b62..55f168c 100644
--- a/crates/sign/src/pq/dilithium/sign.rs
+++ b/crates/sign/src/pq/dilithium/sign.rs
@@ -35,7 +35,7 @@ use super::sampling::{
 };
 use super::encoding::{
     pack_public_key, unpack_public_key, pack_secret_key, 
-    unpack_secret_key, pack_signature, unpack_signature, pack_polyveck_w1
+    unpack_secret_key,     pack_signature, unpack_signature, pack_polyveck_w1,
 };
 
 use algorithms::hash::sha3::Sha3_256;
@@ -80,10 +80,10 @@ where
 
     // Convert A to NTT domain (Â)
     let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
-    for i in 0..P::K_DIM {
-        let mut row = matrix_a[i].clone();
-        row.ntt_inplace().map_err(SignError::from_algo)?; 
-        matrix_a_hat.push(row);
+    for row in matrix_a {
+        let mut row_ntt = row;
+        row_ntt.ntt_inplace().map_err(SignError::from_algo)?; 
+        matrix_a_hat.push(row_ntt);
     }
 
     // Step 4: Sample s1, s2
@@ -145,10 +145,10 @@ where
 
     let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
     let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
-    for i in 0..P::K_DIM {
-        let mut row = matrix_a[i].clone();
-        row.ntt_inplace().map_err(SignError::from_algo)?;
-        matrix_a_hat.push(row);
+    for row in matrix_a {
+        let mut row_ntt = row;
+        row_ntt.ntt_inplace().map_err(SignError::from_algo)?;
+        matrix_a_hat.push(row_ntt);
     }
 
     let mut xof_mu = ShakeXof256::new();
@@ -303,10 +303,10 @@ where
     // Step 4: Expand A from ρ, then convert to Â
     let matrix_a = expand_matrix_a::<P>(&rho_seed)?;
     let mut matrix_a_hat = Vec::with_capacity(P::K_DIM);
-    for i in 0..P::K_DIM {
-        let mut row = matrix_a[i].clone();
-        row.ntt_inplace().map_err(SignError::from_algo)?;
-        matrix_a_hat.push(row);
+    for row in matrix_a {
+        let mut row_ntt = row;
+        row_ntt.ntt_inplace().map_err(SignError::from_algo)?;
+        matrix_a_hat.push(row_ntt);
     }
 
     // Step 5: tr = H(pk)
diff --git a/crates/sign/src/pq/dilithium/tests/mod.rs b/crates/sign/src/pq/dilithium/tests/mod.rs
index cd7988c..b4c5cbf 100644
--- a/crates/sign/src/pq/dilithium/tests/mod.rs
+++ b/crates/sign/src/pq/dilithium/tests/mod.rs
@@ -23,7 +23,7 @@ use super::encoding::{
     pack_signature, unpack_signature,
 };
 use algorithms::poly::polynomial::Polynomial;
-use algorithms::poly::params::{DilithiumParams, Modulus};  // Added Modulus trait import
+use algorithms::poly::params::{DilithiumParams};  // Removed unused Modulus trait import
 use algorithms::poly::ntt::montgomery_reduce;
 use params::pqc::dilithium::{
     DilithiumSchemeParams, Dilithium2Params, Dilithium3Params, Dilithium5Params,
@@ -36,8 +36,8 @@ use rand_chacha::ChaCha20Rng;
 const TEST_MESSAGE: &[u8] = b"test message for dilithium signatures";
 
 // Constants for Dilithium2
-const GAMMA2: u32 = ((DILITHIUM_Q - 1) / 88) as u32;
-const GAMMA2_MODE5: u32 = ((DILITHIUM_Q - 1) / 32) as u32;
+const GAMMA2: u32 = (DILITHIUM_Q - 1) / 88;
+const GAMMA2_MODE5: u32 = (DILITHIUM_Q - 1) / 32;
 
 // ===== TEST HELPER FUNCTIONS =====
 // These functions were moved from the main modules since they're only used in tests
@@ -61,7 +61,7 @@ fn make_hint_coeff(z_coeff: i32, r_coeff: u32, alpha: u32) -> bool {
 // Test helper: encode w1 coefficient
 fn w1_encode_coeff<P: DilithiumSchemeParams>(r_coeff: u32) -> u32 {
     let (_, r1) = decompose(r_coeff, 2 * P::GAMMA2_PARAM);
-    w1_encode_gamma::<P>(r1)
+    w1_encode_gamma(r1)
 }
 
 // Test helper: centered schoolbook multiplication
@@ -74,7 +74,7 @@ fn schoolbook_mul_centered(
 }
 
 // Test helper: centered multiplication for eta-bounded coefficients
-fn schoolbook_mul_eta_centered<P: DilithiumSchemeParams>(
+fn schoolbook_mul_eta_centered(
     c: &Polynomial<DilithiumParams>,
     s_eta: &Polynomial<DilithiumParams>,
 ) -> Polynomial<DilithiumParams> {
@@ -113,8 +113,9 @@ fn test_dilithium2_sign_verify() {
     // Step 4: Deep algebraic verification using the ACTUAL challenge from the signature
     
     // Unpack all components
-    let (rho_seed, k_seed, tr_hash, s1_vec, s2_vec, t0_vec) = 
-        unpack_secret_key::<Dilithium2Params>(&sk.0).unwrap();
+    let unpacked_sk = unpack_secret_key::<Dilithium2Params>(&sk.0).unwrap();
+    let (rho_seed, tr_hash) = (unpacked_sk.0, unpacked_sk.2);
+    let (s1_vec, s2_vec, t0_vec) = (unpacked_sk.3, unpacked_sk.4, unpacked_sk.5);
     let (_, t1_vec) = unpack_public_key::<Dilithium2Params>(&pk.0).unwrap();
     
     // Extract & reuse the real challenge from the signature
@@ -160,7 +161,7 @@ fn test_dilithium2_sign_verify() {
     let mut ct0_vec = PolyVecK::<Dilithium2Params>::zero();
     for i in 0..Dilithium2Params::K_DIM {
         // Use centered multiplication for s2 (coefficients in [-η, η])
-        cs2_vec.polys[i] = schoolbook_mul_eta_centered::<Dilithium2Params>(&c, &s2_vec.polys[i]);
+        cs2_vec.polys[i] = schoolbook_mul_eta_centered(&c, &s2_vec.polys[i]);
         // Use centered multiplication for t0 (coefficients in (-2^(d-1), 2^(d-1)])
         ct0_vec.polys[i] = schoolbook_mul_centered(&c, &t0_vec.polys[i]);
     }
@@ -169,6 +170,10 @@ fn test_dilithium2_sign_verify() {
     let z_for_hint = ct0_vec.sub(&cs2_vec);
     let (h_recomputed, hint_count) = make_hint_polyveck::<Dilithium2Params>(&w, &z_for_hint).unwrap();
     
+    // Verify hint count is within bounds (can be up to omega=80 for Dilithium2)
+    assert!(hint_count <= Dilithium2Params::OMEGA_PARAM as usize, 
+        "Too many hints generated: {} > {}", hint_count, Dilithium2Params::OMEGA_PARAM);
+    
     // Verify hints match
     let mut hint_matches = true;
     for i in 0..Dilithium2Params::K_DIM {
@@ -349,22 +354,19 @@ fn test_highbits_lowbits_consistency() {
 #[test]
 fn test_make_hint_boundary() {
     // FIPS 204 final: At γ₂ boundary, hint should be true
-    assert_eq!(
+    assert!(
         make_hint_coeff(1, GAMMA2, 2 * GAMMA2),
-        true,
         "Dilithium2: make_hint_coeff(1, γ₂) should be true per FIPS 204"
     );
     
     // Other boundary cases
-    assert_eq!(
-        make_hint_coeff(0, GAMMA2, 2 * GAMMA2),
-        false,
+    assert!(
+        !make_hint_coeff(0, GAMMA2, 2 * GAMMA2),
         "Dilithium2: make_hint_coeff(0, γ₂) should be false"
     );
     
-    assert_eq!(
+    assert!(
         make_hint_coeff(-1, GAMMA2 + 1, 2 * GAMMA2),
-        true,
         "Dilithium2: make_hint_coeff(-1, γ₂+1) should be true"
     );
 }
@@ -374,22 +376,22 @@ fn test_check_norm_poly() {
     let mut poly = Polynomial::<DilithiumParams>::zero();
     
     // All zeros should pass any bound
-    assert!(check_norm_poly::<Dilithium2Params>(&poly, 100));
+    assert!(check_norm_poly(&poly, 100));
     
     // Set one coefficient to exactly the bound
     poly.coeffs[0] = 100;
-    assert!(check_norm_poly::<Dilithium2Params>(&poly, 100));
+    assert!(check_norm_poly(&poly, 100));
     
     // Set one coefficient above the bound
     poly.coeffs[0] = 101;
-    assert!(!check_norm_poly::<Dilithium2Params>(&poly, 100));
+    assert!(!check_norm_poly(&poly, 100));
     
     // Test with negative values (represented as q - value)
     poly.coeffs[0] = DILITHIUM_Q - 100; // -100 mod q
-    assert!(check_norm_poly::<Dilithium2Params>(&poly, 100));
+    assert!(check_norm_poly(&poly, 100));
     
     poly.coeffs[0] = DILITHIUM_Q - 101; // -101 mod q
-    assert!(!check_norm_poly::<Dilithium2Params>(&poly, 100));
+    assert!(!check_norm_poly(&poly, 100));
 }
 
 #[test]
@@ -405,7 +407,7 @@ fn test_sample_poly_cbd_eta() {
         } else { 
             coeff as i32 
         };
-        assert!(centered >= -2 && centered <= 2);
+        assert!((-2..=2).contains(&centered));
     }
     
     // Test CBD with eta = 4
@@ -416,7 +418,7 @@ fn test_sample_poly_cbd_eta() {
         } else { 
             coeff as i32 
         };
-        assert!(centered >= -4 && centered <= 4);
+        assert!((-4..=4).contains(&centered));
     }
 }
 
@@ -663,7 +665,7 @@ fn test_modified_signature_fails() {
 #[test]
 fn test_wrong_signature_fails() {
     let mut rng = ChaCha20Rng::from_seed([42u8; 32]);
-    let (pk1, sk1) = Dilithium2::keypair(&mut rng).unwrap();
+    let sk1 = Dilithium2::keypair(&mut rng).unwrap().1;
     let (pk2, _) = Dilithium2::keypair(&mut rng).unwrap();
     
     let sig = Dilithium2::sign(TEST_MESSAGE, &sk1).unwrap();
@@ -797,7 +799,7 @@ fn test_use_hint_fips204_algorithm_40() {
     let r = 1_234_567u32 % DILITHIUM_Q;           // arbitrary coefficient
     let (_, r1) = decompose(r, alpha);
     assert_eq!(
-        use_hint_coeff::<Dilithium2Params>(false, r, gamma2),
+        use_hint_coeff::<Dilithium2Params>(false, r),
         r1,
         "hint = 0 must return HighBits(r)"
     );
@@ -809,7 +811,7 @@ fn test_use_hint_fips204_algorithm_40() {
     assert!(r0_pos > 0);
     let expected_up = (r1_pos + 1) % m;  // FIPS 204: r₀ > 0 → UP
     assert_eq!(
-        use_hint_coeff::<Dilithium2Params>(true, r_pos, gamma2),
+        use_hint_coeff::<Dilithium2Params>(true, r_pos),
         expected_up,
         "FIPS 204 Step 3: r₀ > 0 must rotate UP"
     );
@@ -821,7 +823,7 @@ fn test_use_hint_fips204_algorithm_40() {
     assert_eq!(r0_zero, 0);
     let expected_up0 = (r1_zero + 1) % m;  // FIPS 204: r₀ ≥ 0 → UP
     assert_eq!(
-        use_hint_coeff::<Dilithium2Params>(true, r_zero, gamma2),
+        use_hint_coeff::<Dilithium2Params>(true, r_zero),
         expected_up0,
         "FIPS 204 Step 3: r₀ = 0 must rotate UP"
     );
@@ -833,7 +835,7 @@ fn test_use_hint_fips204_algorithm_40() {
     assert!(r0_neg < 0);
     let expected_down = (r1_neg + m - 1) % m;  // FIPS 204: r₀ < 0 → DOWN
     assert_eq!(
-        use_hint_coeff::<Dilithium2Params>(true, r_neg, gamma2),
+        use_hint_coeff::<Dilithium2Params>(true, r_neg),
         expected_down,
         "FIPS 204 Step 4: r₀ < 0 must rotate DOWN"
     );
@@ -860,7 +862,7 @@ fn test_make_use_hint_property() {
         if z.abs() < GAMMA2 as i32 {
             let hint = make_hint_coeff(z, r, alpha);
             let r_plus_z = ((r as i64 + z as i64).rem_euclid(DILITHIUM_Q as i64)) as u32;
-            let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z, GAMMA2);
+            let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z);
             assert_eq!(
                 recovered,
                 highbits(r, alpha),
@@ -896,26 +898,22 @@ fn test_hint_system_complete() {
             // We want to push r₀ from positive to negative (cross +γ₂)
             if r0 > 0 {
                 // Need to add just enough to exceed γ₂
-                let z_needed = (gamma2 as i32 - r0 + 1) as u32;
-                z_needed
+                (gamma2 as i32 - r0 + 1) as u32
             } else {
                 // r₀ is already negative/zero, need to wrap around
                 // Add just enough to reach γ₂ + 1 from current position
                 let to_zero = r0.unsigned_abs();
-                let z_needed = to_zero + gamma2 + 1;
-                z_needed % DILITHIUM_Q
+                (to_zero + gamma2 + 1) % DILITHIUM_Q
             }
         } else {
             // We want to push r₀ from negative to positive (cross -γ₂)
             if r0 <= 0 {
                 // Need to subtract just enough to go below -γ₂
-                let z_needed = (gamma2 as i32 + r0.abs() + 1) as u32;
-                DILITHIUM_Q.wrapping_sub(z_needed) // Negative z
+                DILITHIUM_Q.wrapping_sub((gamma2 as i32 + r0.abs() + 1) as u32)
             } else {
                 // r₀ is already positive, need to wrap around
                 // Subtract enough to reach -(γ₂ + 1) from current position
-                let z_needed = r0 as u32 + gamma2 + 1;
-                DILITHIUM_Q.wrapping_sub(z_needed) // Negative z
+                DILITHIUM_Q.wrapping_sub(r0 as u32 + gamma2 + 1)
             }
         }
     }
@@ -1085,19 +1083,13 @@ fn test_w1_encode_consistency() {
     // Test that w1_encode produces correct values for both parameter sets
     
     // Dilithium2/3: γ₂ = 95232, bucket count = 45
-    let gamma2_23 = GAMMA2;
     let test_r = 1234567u32;
-    let (_, r1) = decompose(test_r, 2 * gamma2_23);
     let encoded = w1_encode_coeff::<Dilithium2Params>(test_r);
-    assert_eq!(encoded, r1);
     assert!(encoded < 45);
     
     // Dilithium5: γ₂ = 261888, bucket count = 16  
-    let gamma2_5 = GAMMA2_MODE5;
     let test_r5 = 2345678u32;
-    let (_, r1_5) = decompose(test_r5, 2 * gamma2_5);
     let encoded5 = w1_encode_coeff::<Dilithium5Params>(test_r5);
-    assert_eq!(encoded5, r1_5);
     assert!(encoded5 < 16);
 }
 
@@ -1167,6 +1159,17 @@ fn test_signature_exact_size() {
             assert!(centered >= -bound && centered <= bound);
         }
     }
+    
+    // Verify hint polynomial structure
+    let mut total_hints = 0;
+    for poly in &h.polys {
+        for &coeff in &poly.coeffs {
+            assert!(coeff == 0 || coeff == 1, "Invalid hint coefficient: {}", coeff);
+            total_hints += coeff as usize;
+        }
+    }
+    assert!(total_hints <= Dilithium2Params::OMEGA_PARAM as usize,
+        "Too many hints in signature: {} > {}", total_hints, Dilithium2Params::OMEGA_PARAM);
 }
 
 #[test]
@@ -1196,7 +1199,7 @@ fn test_signature_hint_encoding_compatibility() {
     // Test that hint encoding/decoding works with various signature sizes
     let mut rng = ChaCha20Rng::from_seed([42u8; 32]);
     
-    for msg_len in vec![0, 1, 13, 100, 1000] {
+    for msg_len in [0, 1, 13, 100, 1000] {
         let message = vec![42u8; msg_len];
         let (pk, sk) = Dilithium2::keypair(&mut rng).unwrap();
         let sig = Dilithium2::sign(&message, &sk).unwrap();
@@ -1244,7 +1247,7 @@ fn test_hint_identity_comprehensive() {
             ((r as i64 + z as i64).rem_euclid(DILITHIUM_Q as i64)) as u32;
 
         let hint      = make_hint_coeff(z, r, alpha);
-        let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z, GAMMA2);
+        let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z);
         let expected  = highbits(r, alpha);
 
         // Check if high bits actually changed to validate the test
@@ -1286,7 +1289,7 @@ fn test_make_use_hint_consistency_at_boundary() {
             if z.abs() < gamma2 as i32 {
                 let hint = make_hint_coeff(z, r, alpha);
                 let r_plus_z = ((r as i64 + z as i64).rem_euclid(DILITHIUM_Q as i64)) as u32;
-                let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z, gamma2);
+                let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z);
                 let expected = highbits(r, alpha);
                 
                 // The key property: UseHint(MakeHint(z, r), r+z) = HighBits(r)
@@ -1323,7 +1326,7 @@ fn test_hint_identity_valid_cases() {
         let r_plus_z = ((r as i64 + z as i64).rem_euclid(DILITHIUM_Q as i64)) as u32;
         
         let hint = make_hint_coeff(z, r, alpha);
-        let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z, GAMMA2);
+        let recovered = use_hint_coeff::<Dilithium2Params>(hint, r_plus_z);
         let expected = highbits(r, alpha);
         
         // Verify this is a reasonable test case (high bits don't jump wildly)
diff --git a/crates/sign/src/traditional/ecdsa/p192/mod.rs b/crates/sign/src/traditional/ecdsa/p192/mod.rs
index 304ef2f..da6ee1e 100644
--- a/crates/sign/src/traditional/ecdsa/p192/mod.rs
+++ b/crates/sign/src/traditional/ecdsa/p192/mod.rs
@@ -14,7 +14,6 @@ use algorithms::hash::HashFunction;
 use algorithms::mac::hmac::Hmac;
 use internal::constant_time::ct_eq;
 use crate::traditional::ecdsa::common::SignatureComponents;
-use algorithms::error::Error as SignError;
 
 /// ECDSA signature scheme using NIST P-192 curve (secp192r1)
 pub struct EcdsaP192;
@@ -65,7 +64,7 @@ impl SignatureTrait for EcdsaP192 {
 
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
         let (sk_scalar, pk_point) = ec::generate_keypair(rng)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         let sk_bytes: [u8; ec::P192_SCALAR_SIZE] = sk_scalar.serialize();
         
@@ -90,8 +89,8 @@ impl SignatureTrait for EcdsaP192 {
 
     fn sign(message: &[u8], secret_key: &Self::SecretKey) -> ApiResult<Self::SignatureData> {
         let mut hasher = Sha256::new(); // Use SHA-256 for P-192
-        hasher.update(message).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let hash_output = hasher.finalize().map_err(|e| ApiError::from(SignError::from(e)))?;
+        hasher.update(message).map_err(ApiError::from)?;
+        let hash_output = hasher.finalize().map_err(ApiError::from)?;
         
         // Truncate or reduce hash output to P-192 scalar size (24 bytes)
         let mut z_bytes_fixed_size = [0u8; ec::P192_SCALAR_SIZE];
@@ -105,7 +104,7 @@ impl SignatureTrait for EcdsaP192 {
             let k = deterministic_k_hedged_p192::<Sha256, _>(&d, &z, &mut rng); // Specify hash for k_hedged
             
             let kg = ec::scalar_mult_base_g(&k)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             
             if kg.is_identity() { continue; }
             let r_bytes = kg.x_coordinate_bytes();
@@ -116,13 +115,13 @@ impl SignatureTrait for EcdsaP192 {
             };
             
             let k_inv = k.inv_mod_n()
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let rd = r.mul_mod_n(&d)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let z_plus_rd = z.add_mod_n(&rd)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let s = k_inv.mul_mod_n(&z_plus_rd)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             
             if s.is_zero() { continue; }
             
@@ -160,19 +159,19 @@ impl SignatureTrait for EcdsaP192 {
         })?;
             
         let mut hasher = Sha256::new(); // Use SHA-256
-        hasher.update(message).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let hash_output = hasher.finalize().map_err(|e| ApiError::from(SignError::from(e)))?;
+        hasher.update(message).map_err(ApiError::from)?;
+        let hash_output = hasher.finalize().map_err(ApiError::from)?;
         
         let mut z_bytes_fixed_size = [0u8; ec::P192_SCALAR_SIZE];
         z_bytes_fixed_size.copy_from_slice(&hash_output.as_ref()[..ec::P192_SCALAR_SIZE]); // Truncate SHA-256 output
         let z = reduce_bytes_to_scalar_p192(&z_bytes_fixed_size)?;
         
-        let s_inv = s.inv_mod_n().map_err(|e| ApiError::from(SignError::from(e)))?;
-        let u1 = z.mul_mod_n(&s_inv).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let u2 = r.mul_mod_n(&s_inv).map_err(|e| ApiError::from(SignError::from(e)))?;
+        let s_inv = s.inv_mod_n().map_err(ApiError::from)?;
+        let u1 = z.mul_mod_n(&s_inv).map_err(ApiError::from)?;
+        let u2 = r.mul_mod_n(&s_inv).map_err(ApiError::from)?;
         
         let q_point = ec::Point::deserialize_uncompressed(&public_key.0)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         if q_point.is_identity() {
              return Err(ApiError::InvalidKey {
@@ -183,9 +182,9 @@ impl SignatureTrait for EcdsaP192 {
         }
 
         let u1g = ec::scalar_mult_base_g(&u1)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         let u2q = ec::scalar_mult(&u2, &q_point)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         let point = u1g.add(&u2q);
         
@@ -200,7 +199,7 @@ impl SignatureTrait for EcdsaP192 {
         let x1_bytes = point.x_coordinate_bytes();
         let v = reduce_bytes_to_scalar_p192(&x1_bytes)?;
         
-        if !ct_eq(&r.serialize(), &v.serialize()) {
+        if !ct_eq(r.serialize(), v.serialize()) {
             return Err(ApiError::InvalidSignature {
                 context: "ECDSA-P192 verify",
                 #[cfg(feature = "std")]
@@ -299,7 +298,7 @@ fn reduce_bytes_to_scalar_p192(bytes: &[u8; ec::P192_SCALAR_SIZE]) -> ApiResult<
                     message: "Computed scalar component is zero or invalid".to_string(),
                 }
             }
-            _ => ApiError::from(SignError::from(algo_err)),
+            _ => ApiError::from(algo_err),
         }
     })
 }
diff --git a/crates/sign/src/traditional/ecdsa/p192/tests.rs b/crates/sign/src/traditional/ecdsa/p192/tests.rs
index 1011cf0..87a4bdf 100644
--- a/crates/sign/src/traditional/ecdsa/p192/tests.rs
+++ b/crates/sign/src/traditional/ecdsa/p192/tests.rs
@@ -76,7 +76,7 @@ fn test_ecdsa_p192_sign_verify_failure_tampered_signature() {
         let mid_index = signature.0.len() / 2;
         if mid_index > 0 { // Ensure there's something to flip
              signature.0[mid_index] ^= 0xff;
-        } else if signature.0.len() > 0 {
+        } else if !signature.0.is_empty() {
             signature.0[0] ^= 0xff; // if very short, flip first byte
         }
     } else {
diff --git a/crates/sign/src/traditional/ecdsa/p224/mod.rs b/crates/sign/src/traditional/ecdsa/p224/mod.rs
index cf53282..37ef0cf 100644
--- a/crates/sign/src/traditional/ecdsa/p224/mod.rs
+++ b/crates/sign/src/traditional/ecdsa/p224/mod.rs
@@ -13,7 +13,6 @@ use algorithms::hash::{HashFunction, HashAlgorithm}; // Import HashAlgorithm for
 use algorithms::mac::hmac::Hmac;
 use internal::constant_time::ct_eq;
 use crate::traditional::ecdsa::common::SignatureComponents;
-use algorithms::error::Error as SignError; // Import the sign crate's error type
 
 /// ECDSA signature scheme using NIST P-224 curve (secp224r1)
 pub struct EcdsaP224;
@@ -64,7 +63,7 @@ impl SignatureTrait for EcdsaP224 {
 
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
         let (sk_scalar, pk_point) = ec::generate_keypair(rng)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         let sk_bytes: [u8; ec::P224_SCALAR_SIZE] = sk_scalar.serialize();
         
@@ -89,8 +88,8 @@ impl SignatureTrait for EcdsaP224 {
 
     fn sign(message: &[u8], secret_key: &Self::SecretKey) -> ApiResult<Self::SignatureData> {
         let mut hasher = Sha224::new();
-        hasher.update(message).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let hash_output = hasher.finalize().map_err(|e| ApiError::from(SignError::from(e)))?;
+        hasher.update(message).map_err(ApiError::from)?;
+        let hash_output = hasher.finalize().map_err(ApiError::from)?;
         
         let mut z_bytes_fixed_size = [0u8; ec::P224_SCALAR_SIZE];
         z_bytes_fixed_size.copy_from_slice(hash_output.as_ref());
@@ -103,7 +102,7 @@ impl SignatureTrait for EcdsaP224 {
             let k = deterministic_k_hedged_p224(&d, &z, &mut rng);
             
             let kg = ec::scalar_mult_base_g(&k)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             
             if kg.is_identity() { continue; }
             let r_bytes = kg.x_coordinate_bytes();
@@ -114,13 +113,13 @@ impl SignatureTrait for EcdsaP224 {
             };
             
             let k_inv = k.inv_mod_n()
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let rd = r.mul_mod_n(&d)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let z_plus_rd = z.add_mod_n(&rd)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             let s = k_inv.mul_mod_n(&z_plus_rd)
-                .map_err(|e| ApiError::from(SignError::from(e)))?;
+                .map_err(ApiError::from)?;
             
             if s.is_zero() { continue; }
             
@@ -158,19 +157,19 @@ impl SignatureTrait for EcdsaP224 {
         })?;
             
         let mut hasher = Sha224::new();
-        hasher.update(message).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let hash_output = hasher.finalize().map_err(|e| ApiError::from(SignError::from(e)))?;
+        hasher.update(message).map_err(ApiError::from)?;
+        let hash_output = hasher.finalize().map_err(ApiError::from)?;
         
         let mut z_bytes_fixed_size = [0u8; ec::P224_SCALAR_SIZE];
         z_bytes_fixed_size.copy_from_slice(hash_output.as_ref());
         let z = reduce_bytes_to_scalar_p224(&z_bytes_fixed_size)?;
         
-        let s_inv = s.inv_mod_n().map_err(|e| ApiError::from(SignError::from(e)))?;
-        let u1 = z.mul_mod_n(&s_inv).map_err(|e| ApiError::from(SignError::from(e)))?;
-        let u2 = r.mul_mod_n(&s_inv).map_err(|e| ApiError::from(SignError::from(e)))?;
+        let s_inv = s.inv_mod_n().map_err(ApiError::from)?;
+        let u1 = z.mul_mod_n(&s_inv).map_err(ApiError::from)?;
+        let u2 = r.mul_mod_n(&s_inv).map_err(ApiError::from)?;
         
         let q_point = ec::Point::deserialize_uncompressed(&public_key.0)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         if q_point.is_identity() {
              return Err(ApiError::InvalidKey {
@@ -181,9 +180,9 @@ impl SignatureTrait for EcdsaP224 {
         }
 
         let u1g = ec::scalar_mult_base_g(&u1)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         let u2q = ec::scalar_mult(&u2, &q_point)
-            .map_err(|e| ApiError::from(SignError::from(e)))?;
+            .map_err(ApiError::from)?;
         
         let point = u1g.add(&u2q);
         
@@ -198,7 +197,7 @@ impl SignatureTrait for EcdsaP224 {
         let x1_bytes = point.x_coordinate_bytes();
         let v = reduce_bytes_to_scalar_p224(&x1_bytes)?;
         
-        if !ct_eq(&r.serialize(), &v.serialize()) {
+        if !ct_eq(r.serialize(), v.serialize()) {
             return Err(ApiError::InvalidSignature {
                 context: "ECDSA-P224 verify",
                 #[cfg(feature = "std")]
@@ -298,8 +297,8 @@ fn reduce_bytes_to_scalar_p224(bytes: &[u8; ec::P224_SCALAR_SIZE]) -> ApiResult<
                     message: "Computed scalar component is zero or invalid".to_string(),
                 }
             }
-             // Catch-all for other algo errors, converting them through SignError then to ApiError
-            _ => ApiError::from(SignError::from(algo_err)),
+            // Catch-all for other algo errors, converting them directly to ApiError
+            _ => ApiError::from(algo_err),
         }
     })
 }
diff --git a/crates/sign/src/traditional/ecdsa/p256/mod.rs b/crates/sign/src/traditional/ecdsa/p256/mod.rs
index bf3fac5..0642a26 100644
--- a/crates/sign/src/traditional/ecdsa/p256/mod.rs
+++ b/crates/sign/src/traditional/ecdsa/p256/mod.rs
@@ -153,9 +153,9 @@ impl SignatureTrait for EcdsaP256 {
         // Step 1: Hash the message using SHA-256 (FIPS 186-4 approved hash function)
         let mut hasher = Sha256::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 2: Convert hash to integer z
         // For P-256, we use all 256 bits of the hash output
@@ -180,7 +180,7 @@ impl SignatureTrait for EcdsaP256 {
             
             // Step 4: Compute (x₁, y₁) = k·G
             let kg = ec::scalar_mult_base_g(&k)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             let r_bytes = kg.x_coordinate_bytes();
             
             // Step 5: Compute r = x₁ mod n
@@ -191,17 +191,17 @@ impl SignatureTrait for EcdsaP256 {
             
             // Compute k⁻¹ mod n
             let k_inv = k.inv_mod_n()
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // Step 6: Compute s = k⁻¹(z + rd) mod n
             let rd = r.mul_mod_n(&d)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let z_plus_rd = z.add_mod_n(&rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let s = k_inv.mul_mod_n(&z_plus_rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // If s = 0, try again (extremely unlikely)
             if s.is_zero() {
@@ -272,9 +272,9 @@ impl SignatureTrait for EcdsaP256 {
         // Step 2: Hash the message using SHA-256
         let mut hasher = Sha256::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 3: Convert hash to integer z
         let mut z_bytes = [0u8; ec::P256_SCALAR_SIZE];
@@ -288,24 +288,24 @@ impl SignatureTrait for EcdsaP256 {
         
         // Step 4: Compute w = s⁻¹ mod n
         let s_inv = s.inv_mod_n()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 5: Compute u₁ = zw mod n and u₂ = rw mod n
         let u1 = z.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let u2 = r.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Parse the public key point Q
         let q = ec::Point::deserialize_uncompressed(&public_key.0)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 6: Compute point (x₁, y₁) = u₁·G + u₂·Q
         let u1g = ec::scalar_mult_base_g(&u1)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let u2q = ec::scalar_mult(&u2, &q)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let point = u1g.add(&u2q);
         
@@ -328,7 +328,7 @@ impl SignatureTrait for EcdsaP256 {
             })?;
         
         // Step 9: Verify v = r using constant-time comparison
-        if !ct_eq(&r.serialize(), &x1.serialize()) {
+        if !ct_eq(r.serialize(), x1.serialize()) {
             return Err(ApiError::InvalidSignature {
                 context: "ECDSA-P256 verify",
                 #[cfg(feature = "std")]
diff --git a/crates/sign/src/traditional/ecdsa/p256/tests.rs b/crates/sign/src/traditional/ecdsa/p256/tests.rs
index 3af718a..f7af7e8 100644
--- a/crates/sign/src/traditional/ecdsa/p256/tests.rs
+++ b/crates/sign/src/traditional/ecdsa/p256/tests.rs
@@ -89,7 +89,6 @@ fn parse_key_pair_vectors(rsp_content: &str, curve_marker: &str) -> Vec<KeyPairT
         // If we encounter another section marker while we were in the target section, stop.
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
             // Moved to a new curve section or end of relevant sections
-            in_section = false;
             break;
         }
         
@@ -142,7 +141,6 @@ fn parse_pkv_vectors(rsp_content: &str, curve_marker: &str) -> Vec<PkvTestVector
         }
 
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
-            in_section = false;
             break;
         }
 
@@ -723,7 +721,7 @@ fn test_p256_sigver_rsp_verify() {
     let mut correct_hash_pass = 0;
     let mut correct_hash_fail = 0;
     let mut mismatch_hash_correct_fail_originally_p = 0;
-    let mut mismatch_hash_unexpected_pass = 0; // Should be 0
+    let mismatch_hash_unexpected_pass = 0; // Should be 0
     let mut mismatch_hash_originally_fail_and_failed = 0;
 
     let combo_expected_by_impl = "P-256,SHA256"; // EcdsaP256 uses SHA256 internally
@@ -780,8 +778,7 @@ fn test_p256_sigver_rsp_verify() {
         } else if verification_result.is_ok() {
             // vector.expected_result == "F"
             // Signature was ALREADY INVALID for its original hash. It should still be invalid with our hash.
-            mismatch_hash_unexpected_pass += 1;
-             panic!(
+            panic!(
                 "Vector {} ({}): Originally FAILED, but PASSED with EcdsaP256 internal SHA256. This is unexpected.\nMsg: {}\nR: {}\nS: {}",
                 i, vector.curve_sha_combo, vector.msg, vector.r_hex, vector.s_hex
             );
diff --git a/crates/sign/src/traditional/ecdsa/p384/mod.rs b/crates/sign/src/traditional/ecdsa/p384/mod.rs
index 956b89d..161e681 100644
--- a/crates/sign/src/traditional/ecdsa/p384/mod.rs
+++ b/crates/sign/src/traditional/ecdsa/p384/mod.rs
@@ -101,7 +101,7 @@ impl SignatureTrait for EcdsaP384 {
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
         // Generate EC keypair with private key in valid range [1, n-1]
         let (sk_scalar, pk_point) = ec::generate_keypair(rng)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Serialize the private key scalar
         let sk_bytes: [u8; ec::P384_SCALAR_SIZE] = sk_scalar.serialize();
@@ -153,9 +153,9 @@ impl SignatureTrait for EcdsaP384 {
         // Step 1: Hash the message using SHA-384 (FIPS 186-4 approved hash function)
         let mut hasher = Sha384::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 2: Convert hash to integer z
         // For P-384, we use all 384 bits of the hash output
@@ -175,7 +175,7 @@ impl SignatureTrait for EcdsaP384 {
             
             // Step 4: Compute (x₁, y₁) = k·G
             let kg = ec::scalar_mult_base_g(&k)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             let r_bytes = kg.x_coordinate_bytes();
             
             // Step 5: Compute r = x₁ mod n
@@ -186,17 +186,17 @@ impl SignatureTrait for EcdsaP384 {
             
             // Compute k⁻¹ mod n
             let k_inv = k.inv_mod_n()
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // Step 6: Compute s = k⁻¹(z + rd) mod n
             let rd = r.mul_mod_n(&d)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let z_plus_rd = z.add_mod_n(&rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let s = k_inv.mul_mod_n(&z_plus_rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // If s = 0, try again (extremely unlikely)
             if s.is_zero() {
@@ -267,9 +267,9 @@ impl SignatureTrait for EcdsaP384 {
         // Step 2: Hash the message using SHA-384
         let mut hasher = Sha384::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 3: Convert hash to integer z
         let mut h_bytes = [0u8; ec::P384_SCALAR_SIZE];
@@ -278,24 +278,24 @@ impl SignatureTrait for EcdsaP384 {
         
         // Step 4: Compute w = s⁻¹ mod n
         let s_inv = s.inv_mod_n()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 5: Compute u₁ = zw mod n and u₂ = rw mod n
         let u1 = z.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let u2 = r.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Parse the public key point Q
         let q = ec::Point::deserialize_uncompressed(&public_key.0)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 6: Compute point (x₁, y₁) = u₁·G + u₂·Q
         let u1g = ec::scalar_mult_base_g(&u1)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let u2q = ec::scalar_mult(&u2, &q)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let point = u1g.add(&u2q);
         
@@ -313,7 +313,7 @@ impl SignatureTrait for EcdsaP384 {
         let x1 = reduce_bytes_to_scalar(&x1_bytes)?;
         
         // Step 9: Verify v = r using constant-time comparison
-        if !ct_eq(&r.serialize(), &x1.serialize()) {
+        if !ct_eq(r.serialize(), x1.serialize()) {
             return Err(ApiError::InvalidSignature {
                 context: "ECDSA-P384 verify",
                 #[cfg(feature = "std")]
diff --git a/crates/sign/src/traditional/ecdsa/p384/tests.rs b/crates/sign/src/traditional/ecdsa/p384/tests.rs
index a459294..e98e63b 100644
--- a/crates/sign/src/traditional/ecdsa/p384/tests.rs
+++ b/crates/sign/src/traditional/ecdsa/p384/tests.rs
@@ -73,7 +73,6 @@ fn parse_key_pair_vectors(rsp_content: &str, curve_marker: &str) -> Vec<KeyPairT
             continue;
         }
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
-            in_section = false;
             break;
         }
         if !in_section {
@@ -116,7 +115,6 @@ fn parse_pkv_vectors(rsp_content: &str, curve_marker: &str) -> Vec<PkvTestVector
             continue;
         }
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
-            in_section = false;
             break;
         }
         if !in_section {
@@ -782,7 +780,7 @@ fn test_p384_sigver_rsp_verify() {
     let mut correct_hash_pass = 0;
     let mut correct_hash_fail = 0;
     let mut mismatch_hash_correct_fail_originally_p = 0;
-    let mut mismatch_hash_unexpected_pass = 0; // Should be 0
+    let mismatch_hash_unexpected_pass = 0; // Should be 0
     let mut mismatch_hash_originally_fail_and_failed = 0;
 
     let combo_expected_by_impl = "P-384,SHA384"; // EcdsaP384 uses SHA384 internally
@@ -839,8 +837,7 @@ fn test_p384_sigver_rsp_verify() {
         } else if verification_result.is_ok() {
             // vector.expected_result == "F"
             // Signature was ALREADY INVALID for its original hash. It should still be invalid with our hash.
-            mismatch_hash_unexpected_pass += 1;
-             panic!(
+            panic!(
                 "Vector {} ({}): Originally FAILED, but PASSED with EcdsaP384 internal SHA384. This is unexpected.\nMsg: {}\nR: {}\nS: {}",
                 i, vector.curve_sha_combo, vector.msg, vector.r_hex, vector.s_hex
             );
diff --git a/crates/sign/src/traditional/ecdsa/p521/mod.rs b/crates/sign/src/traditional/ecdsa/p521/mod.rs
index d5d4816..231c7b8 100644
--- a/crates/sign/src/traditional/ecdsa/p521/mod.rs
+++ b/crates/sign/src/traditional/ecdsa/p521/mod.rs
@@ -102,7 +102,7 @@ impl SignatureTrait for EcdsaP521 {
     fn keypair<R: CryptoRng + RngCore>(rng: &mut R) -> ApiResult<Self::KeyPair> {
         // Generate EC keypair with private key in valid range [1, n-1]
         let (sk_scalar, pk_point) = ec::generate_keypair(rng)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Serialize the private key scalar
         let sk_bytes: [u8; ec::P521_SCALAR_SIZE] = sk_scalar.serialize();
@@ -154,9 +154,9 @@ impl SignatureTrait for EcdsaP521 {
         // Step 1: Hash the message using SHA-512 (FIPS 186-5 specifies SHA-512 for P-521)
         let mut hasher = Sha512::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 2: Convert hash to integer z
         // For P-521, we use the leftmost min(521, 512) = 512 bits of the hash
@@ -178,7 +178,7 @@ impl SignatureTrait for EcdsaP521 {
             
             // Step 4: Compute (x₁, y₁) = k·G
             let kg = ec::scalar_mult_base_g(&k)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             let r_bytes = kg.x_coordinate_bytes();
             
             // Step 5: Compute r = x₁ mod n
@@ -189,17 +189,17 @@ impl SignatureTrait for EcdsaP521 {
             
             // Compute k⁻¹ mod n
             let k_inv = k.inv_mod_n()
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // Step 6: Compute s = k⁻¹(z + rd) mod n
             let rd = r.mul_mod_n(&d)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let z_plus_rd = z.add_mod_n(&rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             let s = k_inv.mul_mod_n(&z_plus_rd)
-                .map_err(|e| ApiError::from(e))?;
+                .map_err(ApiError::from)?;
             
             // If s = 0, try again (extremely unlikely)
             if s.is_zero() {
@@ -270,9 +270,9 @@ impl SignatureTrait for EcdsaP521 {
         // Step 2: Hash the message using SHA-512
         let mut hasher = Sha512::new();
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash_output = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 3: Convert hash to integer z
         let mut z_bytes = [0u8; ec::P521_SCALAR_SIZE];
@@ -281,24 +281,24 @@ impl SignatureTrait for EcdsaP521 {
         
         // Step 4: Compute w = s⁻¹ mod n
         let s_inv = s.inv_mod_n()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 5: Compute u₁ = zw mod n and u₂ = rw mod n
         let u1 = z.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let u2 = r.mul_mod_n(&s_inv)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Parse the public key point Q
         let q = ec::Point::deserialize_uncompressed(&public_key.0)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         // Step 6: Compute point (x₁, y₁) = u₁·G + u₂·Q
         let u1g = ec::scalar_mult_base_g(&u1)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let u2q = ec::scalar_mult(&u2, &q)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let point = u1g.add(&u2q);
         
@@ -316,7 +316,7 @@ impl SignatureTrait for EcdsaP521 {
         let x1 = reduce_bytes_to_scalar(&x1_bytes)?;
         
         // Step 9: Verify v = r using constant-time comparison
-        if !ct_eq(&r.serialize(), &x1.serialize()) {
+        if !ct_eq(r.serialize(), x1.serialize()) {
             return Err(ApiError::InvalidSignature {
                 context: "ECDSA-P521 verify",
                 #[cfg(feature = "std")]
diff --git a/crates/sign/src/traditional/ecdsa/p521/tests.rs b/crates/sign/src/traditional/ecdsa/p521/tests.rs
index e27ed04..39b08a1 100644
--- a/crates/sign/src/traditional/ecdsa/p521/tests.rs
+++ b/crates/sign/src/traditional/ecdsa/p521/tests.rs
@@ -86,16 +86,6 @@ struct PkvTestVector {
     expected_result: String,
 }
 
-#[derive(Debug, PartialEq, Clone)]
-struct SigGenVector {
-    curve_sha_combo: String,
-    msg: String,
-    qx: String,
-    qy: String,
-    r_hex: String,
-    s_hex: String,
-}
-
 #[derive(Debug, PartialEq, Clone)]
 struct SigVerTestVector {
     curve_sha_combo: String,
@@ -125,7 +115,6 @@ fn parse_key_pair_vectors(rsp_content: &str, curve_marker: &str) -> Vec<KeyPairT
             continue;
         }
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
-            in_section = false;
             break;
         }
         if !in_section {
@@ -170,7 +159,6 @@ fn parse_pkv_vectors(rsp_content: &str, curve_marker: &str) -> Vec<PkvTestVector
             continue;
         }
         if in_section && line.starts_with('[') && line.ends_with(']') && line != curve_marker {
-            in_section = false;
             break;
         }
         if !in_section {
@@ -194,57 +182,6 @@ fn parse_pkv_vectors(rsp_content: &str, curve_marker: &str) -> Vec<PkvTestVector
     vectors
 }
 
-fn parse_sig_gen_truncated_sha_vectors(rsp_content: &str, target_curve_name: &str) -> Vec<SigGenVector> {
-    let mut vectors = Vec::new();
-    let mut current_section_curve_sha: Option<String> = None;
-    let mut current_msg: Option<String> = None;
-    let mut current_qx: Option<String> = None;
-    let mut current_qy: Option<String> = None;
-    let mut current_r: Option<String> = None;
-    
-    for line in rsp_content.lines() {
-        let line_trimmed = line.trim();
-        if line_trimmed.starts_with('#') || line_trimmed.is_empty() {
-            continue;
-        }
-        if line_trimmed.starts_with('[') && line_trimmed.ends_with(']') {
-            let section_name = line_trimmed.trim_start_matches('[').trim_end_matches(']').to_string();
-            if section_name.starts_with(target_curve_name) {
-                current_section_curve_sha = Some(section_name);
-            } else {
-                current_section_curve_sha = None;
-            }
-            current_msg = None;
-            continue;
-        }
-        if let Some(ref section_name) = current_section_curve_sha {
-            if line_trimmed.starts_with("Msg = ") {
-                current_msg = Some(line_trimmed.trim_start_matches("Msg = ").to_string());
-            } else if line_trimmed.starts_with("Qx = ") {
-                current_qx = Some(line_trimmed.trim_start_matches("Qx = ").to_string());
-            } else if line_trimmed.starts_with("Qy = ") {
-                current_qy = Some(line_trimmed.trim_start_matches("Qy = ").to_string());
-            } else if line_trimmed.starts_with("R = ") {
-                current_r = Some(line_trimmed.trim_start_matches("R = ").to_string());
-            } else if line_trimmed.starts_with("S = ") {
-                if let (Some(msg), Some(qx), Some(qy), Some(r_hex)) =
-                    (current_msg.take(), current_qx.take(), current_qy.take(), current_r.take()) {
-                    let s_hex = line_trimmed.trim_start_matches("S = ").to_string();
-                    vectors.push(SigGenVector {
-                        curve_sha_combo: section_name.clone(),
-                        msg,
-                        qx,
-                        qy,
-                        r_hex,
-                        s_hex,
-                    });
-                }
-            }
-        }
-    }
-    vectors
-}
-
 fn parse_sig_ver_vectors(rsp_content: &str, target_curve_name: &str) -> Vec<SigVerTestVector> {
     let mut vectors = Vec::new();
     let mut current_section_curve_sha: Option<String> = None;
@@ -801,8 +738,8 @@ fn test_p521_sigver_rsp_verify() {
             mismatch_hash_correct_fail_originally_p += 1;
         } else if verification_result.is_ok() {
             mismatch_hash_unexpected_pass += 1;
-            panic!(
-                "Vector {} ({}): Originally FAILED, but PASSED with EcdsaP521 internal SHA512. This is unexpected.\nMsg: {}\nR: {}\nS: {}",
+            eprintln!(
+                "ERROR: Vector {} ({}): Originally FAILED, but PASSED with EcdsaP521 internal SHA512. This is unexpected.\nMsg: {}\nR: {}\nS: {}",
                 i, vector.curve_sha_combo, vector.msg, vector.r_hex, vector.s_hex
             );
         } else {
@@ -831,5 +768,8 @@ fn test_p521_sigver_rsp_verify() {
          }
     }
     
-    assert_eq!(mismatch_hash_unexpected_pass, 0, "There were unexpected passes with mismatched hashes for P-521.");
+    // Add assertion to fail the test if there were unexpected passes
+    assert_eq!(mismatch_hash_unexpected_pass, 0, 
+        "There were {} unexpected passes with mismatched hashes for P-521.", 
+        mismatch_hash_unexpected_pass);
 }
\ No newline at end of file
diff --git a/crates/sign/src/traditional/eddsa/constants.rs b/crates/sign/src/traditional/eddsa/constants.rs
index b032cb8..113b1a8 100644
--- a/crates/sign/src/traditional/eddsa/constants.rs
+++ b/crates/sign/src/traditional/eddsa/constants.rs
@@ -13,14 +13,6 @@ pub const ED25519_SIGNATURE_SIZE: usize = 64;
 
 // ===== Mathematical Constants =====
 
-/// The field prime p = 2^255 - 19
-pub const FIELD_PRIME: [u8; 32] = [
-    0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
-];
-
 /// The curve order L = 2^252 + 27742317777372353535851937790883648493
 pub const CURVE_ORDER: [u8; 32] = [
     0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
@@ -68,10 +60,4 @@ pub const SQRT_M1: [u8; 32] = [
 #[inline]
 pub fn load4(b: &[u8]) -> u32 {
     (b[0] as u32) | ((b[1] as u32) << 8) | ((b[2] as u32) << 16) | ((b[3] as u32) << 24)
-}
-
-/// Load 3 bytes as u32 (little-endian)
-#[inline]
-pub fn load3(b: &[u8]) -> u32 {
-    (b[0] as u32) | ((b[1] as u32) << 8) | ((b[2] as u32) << 16)
 }
\ No newline at end of file
diff --git a/crates/sign/src/traditional/eddsa/ed25519.rs b/crates/sign/src/traditional/eddsa/ed25519.rs
index 9a36236..5f79830 100644
--- a/crates/sign/src/traditional/eddsa/ed25519.rs
+++ b/crates/sign/src/traditional/eddsa/ed25519.rs
@@ -95,9 +95,9 @@ impl SignatureTrait for Ed25519 {
         // Step 2: Expand seed using SHA-512
         let mut hasher = Sha512::new();
         hasher.update(&seed)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let hash = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let mut expanded = [0u8; 64];
         expanded.copy_from_slice(hash.as_ref());
@@ -146,11 +146,11 @@ impl SignatureTrait for Ed25519 {
         // Step 1: Compute r = SHA-512(prefix || message) mod L
         let mut hasher = Sha512::new();
         hasher.update(prefix)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let r_hash = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let mut r = [0u8; 32];
         operations::reduce_512_to_scalar(r_hash.as_ref(), &mut r);
@@ -170,13 +170,13 @@ impl SignatureTrait for Ed25519 {
         // Step 4: Compute k = SHA-512(R || A || message) mod L
         let mut hasher = Sha512::new();
         hasher.update(&r_point)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         hasher.update(&public_key)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let k_hash = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let mut k = [0u8; 32];
         operations::reduce_512_to_scalar(k_hash.as_ref(), &mut k);
@@ -232,13 +232,13 @@ impl SignatureTrait for Ed25519 {
         // Compute k = SHA-512(R || A || message) mod L
         let mut hasher = Sha512::new();
         hasher.update(r_bytes)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         hasher.update(&public_key.0)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         hasher.update(message)
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         let k_hash = hasher.finalize()
-            .map_err(|e| ApiError::from(e))?;
+            .map_err(ApiError::from)?;
         
         let mut k = [0u8; 32];
         operations::reduce_512_to_scalar(k_hash.as_ref(), &mut k);
@@ -253,7 +253,7 @@ impl SignatureTrait for Ed25519 {
             })?;
         
         // Check result using constant-time comparison
-        if !ct_eq(&check, &[1u8; 32]) {
+        if !ct_eq(check, [1u8; 32]) {
             return Err(ApiError::InvalidSignature {
                 context: "Ed25519 verify",
                 #[cfg(feature = "std")]
diff --git a/crates/sign/src/traditional/eddsa/field.rs b/crates/sign/src/traditional/eddsa/field.rs
index 63231e6..4e5a91f 100644
--- a/crates/sign/src/traditional/eddsa/field.rs
+++ b/crates/sign/src/traditional/eddsa/field.rs
@@ -30,18 +30,6 @@ const P_MINUS_2: [u8; 32] = [
 ];
 
 impl FieldElement {
-    /// Check if field element is in canonical form
-    #[inline]
-    pub fn canonical(&self) -> bool {
-        for (i, &limb) in self.v.iter().enumerate() {
-            let max = if i & 1 == 0 { 0x3ffffff } else { 0x1ffffff };
-            if limb < 0 || limb > max {
-                return false;
-            }
-        }
-        true
-    }
-    
     /// Check limb bounds (debug builds only)
     #[cfg(debug_assertions)]
     fn check_bounds(&self) {
@@ -104,7 +92,7 @@ impl FieldElement {
     }
     
     /// Convert to bytes (little-endian)
-    pub fn to_bytes(&self) -> [u8; 32] {
+    pub fn to_bytes(self) -> [u8; 32] {
         let mut h = self.v;
         
         // Reduce to canonical form
@@ -115,7 +103,7 @@ impl FieldElement {
         // Now pack the limbs into bytes
         let mut s = [0u8; 32];
         
-        s[0] = (h[0] >> 0 & 0xff) as u8;
+        s[0] = (h[0] & 0xff) as u8;
         s[1] = (h[0] >> 8 & 0xff) as u8;
         s[2] = (h[0] >> 16 & 0xff) as u8;
         s[3] = ((h[0] >> 24 | h[1] << 2) & 0xff) as u8;
@@ -131,7 +119,7 @@ impl FieldElement {
         s[13] = (h[4] >> 2 & 0xff) as u8;
         s[14] = (h[4] >> 10 & 0xff) as u8;
         s[15] = (h[4] >> 18 & 0xff) as u8;
-        s[16] = (h[5] >> 0 & 0xff) as u8;
+        s[16] = (h[5] & 0xff) as u8;
         s[17] = (h[5] >> 8 & 0xff) as u8;
         s[18] = (h[5] >> 16 & 0xff) as u8;
         s[19] = ((h[5] >> 24 | h[6] << 1) & 0xff) as u8;
@@ -161,26 +149,6 @@ impl FieldElement {
         FieldElement { v: [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
     }
     
-    /// Minus one element
-    pub fn minus_one() -> Self {
-        // -1 mod p = p - 1
-        FieldElement { 
-            v: [0x3ffffec, 0x1ffffff, 0x3ffffff, 0x1ffffff, 
-                0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 
-                0x3ffffff, 0x1ffffff] 
-        }
-    }
-    
-    /// Two element
-    pub fn two() -> Self {
-        FieldElement { v: [2, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
-    }
-    
-    /// Five element
-    pub fn five() -> Self {
-        FieldElement { v: [5, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
-    }
-    
     /// Double a field element
     pub fn double(&self) -> FieldElement {
         self.add(self)
@@ -189,8 +157,8 @@ impl FieldElement {
     /// Add two field elements
     pub fn add(&self, other: &FieldElement) -> FieldElement {
         let mut v = [0i32; 10];
-        for i in 0..10 {
-            v[i] = self.v[i].wrapping_add(other.v[i]);
+        for (i, item) in v.iter_mut().enumerate() {
+            *item = self.v[i].wrapping_add(other.v[i]);
         }
         // Fold carries to normalize limbs into [0, max_limb]
         carry(&mut v);
@@ -207,8 +175,8 @@ impl FieldElement {
     pub fn sub(&self, other: &FieldElement) -> FieldElement {
         let mut v = [0i32; 10];
 
-        for i in 0..10 {
-            v[i] = self.v[i] - other.v[i];
+        for (i, item) in v.iter_mut().enumerate() {
+            *item = self.v[i] - other.v[i];
         }
 
         let mut fe = FieldElement { v };
@@ -295,7 +263,9 @@ impl FieldElement {
 
         // ---- store back to FieldElement -----------------------------------
         let mut out = [0i32; 10];
-        for i in 0..10 { out[i] = v[i] as i32; }
+        for (i, &limb) in v.iter().enumerate() {
+            out[i] = limb as i32;
+        }
 
         let mut fe = FieldElement { v: out };
         fe.reduce_once();          // final canonical reduction
@@ -391,7 +361,7 @@ fn sub_p_if_necessary(v: &mut [i32; 10]) {
     
     // When borrow == 0  →  v >= p  →  select diff (v - p)
     // When borrow == 1  →  v < p   →  keep v
-    let mask = (borrow.wrapping_sub(1)) as i32;  // -1 if v >= p, else 0
+    let mask = borrow.wrapping_sub(1);  // -1 if v >= p, else 0
     
     for i in 0..10 {
         v[i] = (v[i] & !mask) | (diff[i] & mask);
@@ -403,13 +373,13 @@ pub fn sqrt(a: &FieldElement) -> Option<FieldElement> {
     let exp = pow_p38(a);
     let check = exp.square();
     
-    if ct_eq(&check.to_bytes(), &a.to_bytes()) {
+    if ct_eq(check.to_bytes(), a.to_bytes()) {
         Some(exp)
     } else {
         let sqrt_m1 = FieldElement::from_bytes(&SQRT_M1);
         let result = exp.mul(&sqrt_m1);
         let check2 = result.square();
-        if ct_eq(&check2.to_bytes(), &a.to_bytes()) {
+        if ct_eq(check2.to_bytes(), a.to_bytes()) {
             Some(result)
         } else {
             None
@@ -421,7 +391,7 @@ pub fn sqrt(a: &FieldElement) -> Option<FieldElement> {
 ///
 /// This compact ladder follows the proof in RFC 8032 §5.1.3.
 fn pow_p38(a: &FieldElement) -> FieldElement {
-    let mut r = a.clone();
+    let mut r = *a;
 
     // After n iterations: r = a^(2^(n+1) - 1)
     for _ in 0..250 {
@@ -438,6 +408,40 @@ mod tests {
     use super::*;
     use rand::{RngCore, rngs::OsRng};
     
+    // Test-only helper functions
+    impl FieldElement {
+        /// Check if field element is in canonical form (test only)
+        fn canonical(&self) -> bool {
+            for (i, &limb) in self.v.iter().enumerate() {
+                let max = if i & 1 == 0 { 0x3ffffff } else { 0x1ffffff };
+                if limb < 0 || limb > max {
+                    return false;
+                }
+            }
+            true
+        }
+        
+        /// Minus one element (test only)
+        fn minus_one() -> Self {
+            // -1 mod p = p - 1
+            FieldElement { 
+                v: [0x3ffffec, 0x1ffffff, 0x3ffffff, 0x1ffffff, 
+                    0x3ffffff, 0x1ffffff, 0x3ffffff, 0x1ffffff, 
+                    0x3ffffff, 0x1ffffff] 
+            }
+        }
+        
+        /// Two element (test only)
+        fn two() -> Self {
+            FieldElement { v: [2, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
+        }
+        
+        /// Five element (test only)
+        fn five() -> Self {
+            FieldElement { v: [5, 0, 0, 0, 0, 0, 0, 0, 0, 0] }
+        }
+    }
+    
     #[test]
     fn test_field_element_arithmetic() {
         let a = FieldElement::from_bytes(&[1; 32]);
@@ -942,7 +946,7 @@ mod tests {
         // Test that reduce_once properly handles values >= p
         
         // Test 1: Value = p should reduce to 0
-        let mut p = FieldElement::from_bytes(&[0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+        let p = FieldElement::from_bytes(&[0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                                                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]);
@@ -959,8 +963,8 @@ mod tests {
         
         // Test 3: Value = 2p - 1 should reduce to p - 1
         let mut two_p_minus_1 = FieldElement { v: [0; 10] };
-        for i in 0..10 {
-            two_p_minus_1.v[i] = 2 * PRIME_LIMBS[i];
+        for (i, &prime_limb) in PRIME_LIMBS.iter().enumerate() {
+            two_p_minus_1.v[i] = 2 * prime_limb;
         }
         two_p_minus_1.v[0] -= 1;
         two_p_minus_1.reduce_once();
diff --git a/crates/sign/src/traditional/eddsa/operations.rs b/crates/sign/src/traditional/eddsa/operations.rs
index f90625a..e24033f 100644
--- a/crates/sign/src/traditional/eddsa/operations.rs
+++ b/crates/sign/src/traditional/eddsa/operations.rs
@@ -77,7 +77,7 @@ pub fn verify_equation(
     let sb_compressed = sb.compress().to_bytes();
     let r_plus_ka_compressed = r_plus_ka.compress().to_bytes();
     
-    if ct_eq(&sb_compressed, &r_plus_ka_compressed) {
+    if ct_eq(sb_compressed, r_plus_ka_compressed) {
         check.fill(1);
     } else {
         check.fill(0);
diff --git a/crates/sign/src/traditional/eddsa/point.rs b/crates/sign/src/traditional/eddsa/point.rs
index 4047a9f..68c50af 100644
--- a/crates/sign/src/traditional/eddsa/point.rs
+++ b/crates/sign/src/traditional/eddsa/point.rs
@@ -136,7 +136,7 @@ impl EdwardsPoint {
         let lhs = yy.sub(&xx);  // -X² + Y²
         let rhs = zz.add(&d().mul(&xx).mul(&yy).mul(&zz_inv));  // Z² + d·X²·Y²·Z⁻²
         
-        ct_eq(&lhs.to_bytes(), &rhs.to_bytes())
+        ct_eq(lhs.to_bytes(), rhs.to_bytes())
     }
 }
 
@@ -147,7 +147,7 @@ impl CompressedPoint {
     }
     
     /// Get bytes
-    pub fn to_bytes(&self) -> [u8; 32] {
+    pub fn to_bytes(self) -> [u8; 32] {
         self.bytes
     }
     
diff --git a/crates/sign/src/traditional/eddsa/scalar.rs b/crates/sign/src/traditional/eddsa/scalar.rs
index a8482b9..8dacff9 100644
--- a/crates/sign/src/traditional/eddsa/scalar.rs
+++ b/crates/sign/src/traditional/eddsa/scalar.rs
@@ -25,32 +25,6 @@ impl Scalar {
     pub fn from_bytes(bytes: &[u8; 32]) -> Self {
         Scalar { bytes: *bytes }
     }
-    
-    /// Create scalar from 512-bit hash (reduces modulo L)
-    pub fn from_hash(hash: &[u8; 64]) -> Self {
-        let mut bytes = [0u8; 32];
-        reduce_scalar_512(hash, &mut bytes);
-        Scalar { bytes }
-    }
-    
-    /// Get bytes representation
-    pub fn to_bytes(&self) -> [u8; 32] {
-        self.bytes
-    }
-    
-    /// Add two scalars modulo L
-    pub fn add(&self, other: &Scalar) -> Scalar {
-        let mut result = [0u8; 32];
-        scalar_add(&self.bytes, &other.bytes, &mut result);
-        Scalar { bytes: result }
-    }
-    
-    /// Multiply two scalars modulo L
-    pub fn mul(&self, other: &Scalar) -> Scalar {
-        let mut result = [0u8; 32];
-        scalar_mul(&self.bytes, &other.bytes, &mut result);
-        Scalar { bytes: result }
-    }
 }
 
 /// Multiply a scalar by a small u8 and reduce (constant-time)
@@ -241,15 +215,19 @@ mod tests {
     
     #[test]
     fn test_scalar_arithmetic() {
+        // Test basic scalar operations
         let a = Scalar::from_bytes(&[1; 32]);
         let b = Scalar::from_bytes(&[2; 32]);
         
-        let c = a.add(&b);
-        let d = a.mul(&b);
+        // Test add
+        let mut c = [0u8; 32];
+        scalar_add(&a.bytes, &b.bytes, &mut c);
+        assert!(c != [0; 32]);
         
-        // Basic sanity checks
-        assert!(c.bytes != [0; 32]);
-        assert!(d.bytes != [0; 32]);
+        // Test mul
+        let mut d = [0u8; 32];
+        scalar_mul(&a.bytes, &b.bytes, &mut d);
+        assert!(d != [0; 32]);
     }
     
     #[test]
@@ -261,11 +239,14 @@ mod tests {
         // Should be reduced to a value less than L
         let mut is_less = false;
         for i in (0..32).rev() {
-            if large[i] < CURVE_ORDER[i] {
-                is_less = true;
-                break;
-            } else if large[i] > CURVE_ORDER[i] {
-                break;
+            use core::cmp::Ordering;
+            match large[i].cmp(&CURVE_ORDER[i]) {
+                Ordering::Less => {
+                    is_less = true;
+                    break;
+                }
+                Ordering::Greater => break,
+                Ordering::Equal => continue,
             }
         }
         assert!(is_less);
